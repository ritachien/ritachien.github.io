<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Alpha Camp 學期 3 結業心得</title>
      <link href="/posts/984151cd/"/>
      <url>/posts/984151cd/</url>
      
        <content type="html"><![CDATA[<p>學期 3 的課程也告一段落了，我也正式從 Alpha Camp 畢業了!<br>回想起當初那個程式小白的自己，好像也才半年多前的事而已。  </p><span id="more"></span><p>相較於前面幾個學期，學期 3 可以明顯感覺到課程內容的份量重了很多。以往可以提前一週完成進度的我，開始變成每週壓死線的交作業。每個章節都需要花更多的時間進行思考、理解、搜尋相關資料和實作。隨著課程進度的推進，我開始變得越來越沒有自信心，因為知道自己不懂的東西實在是太多了!  </p><p><img src="https://i.pinimg.com/564x/61/c7/a2/61c7a26f952b8fd9094c1d6da2bf279c.jpg">  </p><blockquote><p>圖片來源: <a href="https://pin.it/2rFifQw">Pinterest</a>  </p></blockquote><p>之後就是一連串的自我懷疑:  </p><ul><li>這些東西我真的都讀懂了嗎?  </li><li>我學會的東西夠多了嗎?  </li><li>現在的我已經有能力找到軟體工程師的工作了嗎?</li></ul><p>這些疑惑時不時的在腦海中盤旋，我也開始變得焦慮、挫折。這時候真的感謝 AC 助教們的鼓勵，我開始回顧過去半年間的自己。從一行程式碼都不會寫的我，到現在已經可以做出擁有不同功能的 web app，而這中間也才花不到一年的時間。樂觀的想，至少現在的我比以前會的東西更多了、至少我能知道自己還有哪些地方需要補強，不像以前想問問題都不知道可以問什麼。  </p><p>學期三的同學們也給了我很大的幫助!互相討論各種問題、互相督促學習進度的推進、互相對寫作業出現各種 bug 的哀號😆，都讓我在這條路上走得不寂寞、走得更有動力!</p><p>回顧在 AC 學習的這段時間，學習是辛苦的，但也是快樂的。每天都可以感受到自己正在進步，這不就是我當初離職後想追求的生活嗎? 希望能找個持續學習的產業和工作，讓自己在工作的同時能繼續成長。也許我現在懂得不夠多，但只要一步一腳印，就能離理想中的自己越來越近!  </p><p>接下來要花一點時間把學期三匆匆學過的內容弄懂，然後就要邁向求職之路了! 加油!</p>]]></content>
      
      
      <categories>
          
          <category> 課程心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alpha Camp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode】231. Power of two</title>
      <link href="/posts/bbce68bd/"/>
      <url>/posts/bbce68bd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>來源: Leetcode<br>難度: easy<br>題目: <a href="https://leetcode.com/problems/power-of-two/">231. Power of two</a>  </p></blockquote><span id="more"></span><h2 id="解法一-遞迴"><a href="#解法一-遞迴" class="headerlink" title="解法一(遞迴)"></a>解法一(遞迴)</h2><p>檢查一個數字 n 是不是 2 的 x 次方，就是看他有沒有 1 和 2 以外的因數。所以只要把 n 不斷除以 2 ，看看最後結果是不是 1 就知道了。剛好之前在 CS50 課程有學過遞迴的概念，這題剛好可以拿來用!  </p><p>  要使用遞迴必須要設定停止條件，要不然函式會無止境的呼叫自己繼續執行下去。這邊設定的停止條件是 <code>n === 1</code>，也就是上層傳進來的參數 <code>(n / 2) === 1</code> (除了 2 之外只有 1 這個因數)。另外檢查 n 為非正整數情況須一律傳回 <code>false</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isPowerOfTwo = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isPowerOfTwo</span>(n / <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二-位元運算子"><a href="#解法二-位元運算子" class="headerlink" title="解法二(位元運算子)"></a>解法二(位元運算子)</h2><blockquote><p>解題方式參考: <a href="https://leetcode.com/problems/power-of-two/discuss/1638735/Power-of-Two">tmleyncodes 分享的題解</a>  </p></blockquote><p>這題因為是檢查 2 的次方，所以還有另一種特別的解法。電腦語言是用「二進位」來書寫的，所以可以利用二進位的特性，使用位元運算子來解題。  </p><table><thead><tr><th>數字</th><th>二進位</th></tr></thead><tbody><tr><td>8</td><td>1000</td></tr><tr><td>7</td><td>0111</td></tr><tr><td><code>&amp;</code> 結果</td><td>0000</td></tr><tr><td>位元運算子 <code>&amp;</code> 會回傳兩個運算元對於每個 bit 做 AND 的結果。如下表表示， <code>&amp;</code> 會比較每一個 bit ，如果兩者都是 1 會回傳 1，如果有一方不是 1 則會回傳 0。</td><td></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isPowerOfTwo = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">return</span> (n &amp; (n - <span class="hljs-number">1</span>)) === <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>express-handlebars 模板副檔名設定</title>
      <link href="/posts/285e8af7/"/>
      <url>/posts/285e8af7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在學習使用 <code>express-handlebars</code> 時，看到有個自訂參數 <code>extname</code> 可以自由調整想使用的副檔名，但各種範例都是設定成 <code>hbs</code> 。於是，好奇的我就開始了各種副檔名實驗……  </p><span id="more"></span><h2 id="官方範例"><a href="#官方範例" class="headerlink" title="官方範例"></a>官方範例</h2><blockquote><p>實驗版本:<br>node.js @16.14.2<br>express @4.17.1<br>express-handlebars @4.0.2  </p></blockquote><ul><li>最原始寫法。  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br>app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&#x27;handlebars&#x27;</span>,<span class="hljs-title function_">exphbs</span>())<br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;handlebars&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>變更副檔名為 <code>.hbs</code> 範例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br>app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&#x27;hbs&#x27;</span>,<span class="hljs-title function_">exphbs</span>(&#123; <span class="hljs-attr">extname</span>: <span class="hljs-string">&#x27;.hbs&#x27;</span> &#125;))<br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;hbs&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="錯誤的理解"><a href="#錯誤的理解" class="headerlink" title="錯誤的理解"></a>錯誤的理解</h2><p>在剛開始學習時，我以為模板是可以自由命名的。我對那兩行的理解是:  </p><ol><li>建立一個模板引擎，並將它命名為 <code>handlebars 或 hbs</code>。  </li><li>將 app.js 的模板引擎設成名字叫 <code>handlebars 或 hbs</code> 的模板。  </li><li>如果想變更使用的副檔名，只需要在用 <code>extname</code> 參數設定即可。</li></ol><p>以上錯誤的理解導致開發過程中噴錯，但錯在哪裡我實在搞不清楚，於是就開始了接下來的實驗!  </p><h2 id="實驗記錄"><a href="#實驗記錄" class="headerlink" title="實驗記錄"></a>實驗記錄</h2><blockquote><p>以下實驗都是基於上面的錯誤理解來進行設置!</p></blockquote><ul><li><p>狀況1: <code>extname</code> 設置為 <code>.hbs</code> 但樣板引擎名稱維持 <code>handlebars</code>。<br>結果: 檔案 <code>index.hbs</code> 無法順利讀取。<br><img src="/../Blog-image/posts/2022-07-15_hbs-test1.webp" alt="tset1">  </p></li><li><p>狀況2: 副檔名全部用 <code>.handlebars</code> ，只變更樣板引擎名稱為 <code>text</code>。<br>結果: 所有的 view 都讀不到。<br><img src="/../Blog-image/posts/2022-07-15_hbs-test2.webp" alt="test2">  </p></li><li><p>狀況3: 副檔名、樣板引擎名稱都用 123 可正常 render……<br><img src="/../Blog-image/posts/2022-07-15_hbs-test3.webp" alt="test3">  </p></li><li><p>狀況4: layouts 副檔名和 extname 相同， 其他 views 副檔名及模板名稱都維持 <code>.hbs</code>。<br>結果: 全部都可以正常 render……<br><img src="/../Blog-image/posts/2022-07-15_hbs-test4.webp" alt="test4"></p></li></ul><h2 id="實驗結果"><a href="#實驗結果" class="headerlink" title="實驗結果"></a>實驗結果</h2><h3 id="1-view-engine-setting-的值會預設成為查找-views-的副檔名"><a href="#1-view-engine-setting-的值會預設成為查找-views-的副檔名" class="headerlink" title="1. view engine setting 的值會預設成為查找 views 的副檔名"></a>1. <code>view engine</code> setting 的值會預設成為查找 views 的副檔名</h3><p>在進行完前 3 項實驗後，我又仔細去閱讀了官方文件，然後找到了以下說明:  </p><blockquote><p>Note: Setting the app’s “view engine” setting will make that value the default file extension used for looking up views.  </p></blockquote><p>依照說明，這個 setting 只會影響查找 views 時的副檔名。從前 3 次實驗也可以看出，發生渲染錯誤的都是 setting 和 views 副檔名不同的情況。  </p><h3 id="2-extname-設定只針對-layouts"><a href="#2-extname-設定只針對-layouts" class="headerlink" title="2. extname 設定只針對 layouts"></a>2. <code>extname</code> 設定只針對 layouts</h3><p>依照前項說明， layouts 的部分並不會受到 <code>view engine</code> setting 的影響。於是，我做了第 4 次實驗，也得到了最後的答案。  </p><p>根據實驗結果可以發現， <code>extname</code> 設定確實只影響到 layouts 的副檔名設置。  </p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這個實驗是我在 4 月初時進行的，當時是我第一次花很多時間實驗不同寫法的結果。雖然最後發現我就是官方文件閱讀的不夠詳細，但這個過程對我很有幫助。整個實驗就像學習如何除錯一樣，用刪去法逐一排除各種可能，最後找到需要的答案；在官方文件的查找及閱讀上也有了一次特別的練習。  </p><p>雖然花了不少時間，但這對我後續的學習經歷起到不小的影響。在後來的學習途中遇到疑問時，我也會先從查找文件或 google 資訊開始，最後實際執行看看結果是否如找到的資訊所述一致。在遇到學習資源過時時，也不再太過不知所措，而是可以自己找到解決的辦法!  </p>]]></content>
      
      
      <categories>
          
          <category> Coding 解惑實驗室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> express </tag>
            
            <tag> express-handlebars </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【實作練習】簡易記帳本</title>
      <link href="/posts/ed3d149f/"/>
      <url>/posts/ed3d149f/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 Express 製作簡易記帳本的紀錄。  </p><span id="more"></span><h2 id="為何會選擇這個專案？"><a href="#為何會選擇這個專案？" class="headerlink" title="為何會選擇這個專案？"></a>為何會選擇這個專案？</h2><p>近期在學習用 Express 進行開發，陸陸續續接觸到了不同的知識，包含 CRUD 、登入&#x2F;登出功能、資料庫…等技術。如果要將這些階段性學習的知識進行融會貫通，找一個專案實作會是一個不錯的方法。藉由實踐來驗證自己是否已掌握這些技術知識，並且有能力將他們成功運用在未來開發的專案裡。簡易記帳本是個經典的實作專案，上述提到的內容也都可以一併在這個專案進行實踐。  </p><h2 id="使用了什麼技術？"><a href="#使用了什麼技術？" class="headerlink" title="使用了什麼技術？"></a>使用了什麼技術？</h2><ol><li>Express 框架搭配 express-handlebars 樣板引擎搭建簡易網路應用程式。<br>使用 Express 建立後端伺服器、用 express-handlebars 為各個頁面建立樣板，之後只需要將資料隨著 HTTP request 傳入，就可以將資料快速的帶入模板中。因為樣板的重複利用，除了可以減少開發時間，也可以讓各個頁面看起來更統一、更有一致性。  </li><li>使用 Mongoose 連線 Mongodb 管理、操作資料庫。<br>這個專案需要紀錄的重要資料有「使用者資訊」、「支出紀錄」，使用資料庫管理是個比較安全也比較有效率的方式。利用「資料連結」的設置，可以確保使用者只能看見屬於自己的資訊，也可以利用資料庫的 Schema 設計進行後端再次驗證，確保使用者提供的資料符合要求規格。  </li><li>採用 RESTful 路由設計。<br>RESTful 路由設計是「合作開發」常見的路由設計方式，採用統一的設計規則可以讓不同開發者直接依循規則進行開發，避免各自風格不同造成的衝突問題。另外，直觀的 HTTP request method 也讓人對資源進行什麼樣的操作一目瞭然。  </li><li>運用 passport.js 進行身分驗證。<br>HTTP 有無狀態 (stateless) 的限制，每個 HTTP request 都被單獨對待，也就是它不會主動儲存狀態資訊。使用 passport.js 可以將使用者的登入狀態進行保存，達到對使用者操作權限的管理目的。  </li><li>利用 bcrypt.js 對使用者密碼進行加密保護。<br>如果沒有使用雜湊來對使用者資料進行加密，使用者私密資料將會被直接儲存進資料庫裡。此時只要擁有資料庫的操作權限，就有極大可能可以直接獲取使用者私密資料(例如：密碼)。私密資料的外洩會侵害到使用者權益，因此加密保護是必要的措施。  </li><li>部署到 Heroku。</li></ol><h2 id="哪部分相對能掌握？哪裡花了最多時間？"><a href="#哪部分相對能掌握？哪裡花了最多時間？" class="headerlink" title="哪部分相對能掌握？哪裡花了最多時間？"></a>哪部分相對能掌握？哪裡花了最多時間？</h2><p>Express server 搭建到 CRUD 功能開發及路由設計相對熟悉，之前開發過的 Todo-List 和餐廳清單都有使用到同樣技術，因此幾乎能完全掌握。  </p><p>之前只有用過 <code>Promise.then()</code> 的寫法來處理非同步語法，過程中總是覺得「包得太多層」讓資料傳遞跟執行順序較難一目了然。這次專案嘗試改用 async&#x2F;await 方式來處理非同步語法，花了多一點時間熟悉。  </p><h2 id="過程中碰到什麼困難？又如何克服？"><a href="#過程中碰到什麼困難？又如何克服？" class="headerlink" title="過程中碰到什麼困難？又如何克服？"></a>過程中碰到什麼困難？又如何克服？</h2><p>最大的困難其實就是「萬事起頭難」。包含專案功能的開發路徑、順序、時間管理…等，一開始其實毫無頭緒，要做的事情很多，不知道從哪裡開始比較好。後來我參考了之前專案的 commit message ，先大致把要做的事情進行排序、切分，變成一個個更小的任務。後來依照規劃按部就班，成功的將需求功能一一完成。  </p><h2 id="過程中有對哪個技術有特別深刻的學習？"><a href="#過程中有對哪個技術有特別深刻的學習？" class="headerlink" title="過程中有對哪個技術有特別深刻的學習？"></a>過程中有對哪個技術有特別深刻的學習？</h2><p>其實上述並不是遇到的全部問題，這個專案也大量練習了「找出問題、解決問題」的方法。開發過程中閱讀錯誤訊息、下對關鍵字、成功 Debug 的不斷循環加深了我對於開發工具的理解。  </p><p>另外，比較印象深刻的是 <code>failureFlash</code> 和 <code>failureMessage</code> 的使用。在查資料的過程中看到<a href="https://medium.com/tds-note/how-failure-message-works-in-passport-js-512e453af8a3">這篇</a>的使用說明部落格。我從這篇文章學到了除了 README 以外，也可以從閱讀套件原始程式碼的方式來了解工具的使用方法，之後也成功的將原本寫的 code 更加精簡！  </p>]]></content>
      
      
      <categories>
          
          <category> 課程心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AlphaCamp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git checkout 介紹(switch、restore)</title>
      <link href="/posts/ebe5fbdc/"/>
      <url>/posts/ebe5fbdc/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在搜尋 Git 相關資料時發現， <code>git checkout</code> 要做的事情真的好多啊！很多發問平台上也有不少被這個指令的功能弄到很混淆的人，甚至 Git 官方也新出了兩個指令 <code>git switch</code> 和 <code>git restore</code> 來拆分 <code>git checkout</code> 的工作。  </p><span id="more"></span><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><blockquote><p>Switch branches or restore working tree files.  </p></blockquote><p>先看看 Git 的官方說明，很明確的說出 <code>git checkout</code> 可以切換分支和還原檔案內容。但可能是想要讓指令工作單一化，或是讓使用者在使用上較直覺及不易混淆， Git 官方於 2019 年 2.23.0 Release Notes 釋出的兩個指令 <code>git switch</code> 和 <code>git restore</code> 來拆分這兩個功能。  </p><p>接下來會直接針對兩個新指令做介紹，目前使用上覺得新指令比較直覺，如果跟我一樣還在學習指令的階段，建議可以學習新指令來使用。但如果還是習慣 <code>git checkout</code> 也沒關係，這個指令仍可以繼續使用，沒有被 Git 棄用。  </p><p>接下來針對 <code>git switch</code> 和 <code>git restore</code> 的說明也會一併提供 <code>git checkout</code> 的指令，只要擇一使用即可。  </p><h2 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h2><p><code>git switch</code> 指令主要的工作是在分支間切換，或在 <code>commit hash</code> 間切換。  </p><h3 id="切換分支"><a href="#切換分支" class="headerlink" title="切換分支"></a>切換分支</h3><p>切換分支時， Git 會把 HEAD 指標指向目標分支，此時檔案將呈現分支指標的版本。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch &lt;branch-name&gt;<br>git checkout &lt;branch-name&gt;<br></code></pre></td></tr></table></figure><h3 id="查看指定提交版本"><a href="#查看指定提交版本" class="headerlink" title="查看指定提交版本"></a>查看指定提交版本</h3><p><code>git switch</code> 可以在提供指定提交版本的 <code>commit hash</code> 後，將 HEAD 指標移向該 commit 上。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接指定查看某的提交版本</span><br>git switch -d &lt;commit-hash&gt;    <span class="hljs-comment"># (-d for --detach)</span><br>git checkout &lt;commit-hash&gt;<br></code></pre></td></tr></table></figure><p>除了直接提供 <code>commit hash</code> 的方法外，也可以指定「相對於 HEAD 指標」的版本。這種方式會將 HEAD 指標以當下位置為基準進行移動。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移動到 HEAD 的前一個 commit</span><br>git switch -d HEAD~1    <span class="hljs-comment"># (-d for --detach)</span><br>git checkout HEAD~1<br></code></pre></td></tr></table></figure><p>通常情況下 HEAD 都會指向分支，如果使用以上指令讓 HEAD 指向特定的 commit (也就是指向非分支指標)，則會發生 <strong><a href="https://git-scm.com/docs/git-checkout#_detached_head">Detached HEAD</a></strong> 。 Detached HEAD 訊息只是作為提醒，<br>表示目前 HEAD 不指向任何一個分支。但仍然可以進行檔案瀏覽、編輯、提交及建立新的分支。在 Detached HEAD 的狀態下如果不新建分支就直接提交 commit，因為該提交不在任一分支上，日後可能不易查找。如果想離開 Detached HEAD 狀態，除了直接切換到指定分支外，也可以使用以下指令回到最近一次操作的分支：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch -<br></code></pre></td></tr></table></figure><h3 id="新建並切換分支"><a href="#新建並切換分支" class="headerlink" title="新建並切換分支"></a>新建並切換分支</h3><p><code>git switch</code> 也可以用來新建分支。該指令會從 HEAD 指向的 commit 長出新的分支，並切換到該分支上。  </p><blockquote><p>需要特別注意的是，在新建分支時，使用 <code>git switch</code> 和使用 <code>git checkout</code> 所使用的參數不一樣。  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch -c &lt;branch-name&gt;      <span class="hljs-comment">#(-c for --create)</span><br>git checkout -b &lt;branch-name&gt;    <br></code></pre></td></tr></table></figure><h2 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a>git restore</h2><p><code>git restore</code> 的功能是讓檔案內容恢復到指定的版本。</p><h3 id="檔案內容回復到指定版本"><a href="#檔案內容回復到指定版本" class="headerlink" title="檔案內容回復到指定版本"></a>檔案內容回復到指定版本</h3><p>這個操作並不會對提交歷史有任何的影響，只是讓檔案的「內容」回復到較早之前的版本，也就是「棄用」新編輯的內容。在 <code>git add</code> 之前，可以不斷地重複使用以下指令來讓內容變成之前版本的樣子。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 讓檔案回到最近一次 HEAD 指向版本的樣子</span><br>git restore &lt;files&gt;<br>git checkout HEAD &lt;files&gt;<br>git checkout -- &lt;files&gt;<br><br><span class="hljs-comment"># 讓檔案回到指定 commit 版本的樣子(用 HEAD 的相對位置來指定)</span><br>git restore -s HEAD~2 &lt;files&gt;    <span class="hljs-comment"># (-s for --source)</span><br>git checkout HEAD~2 &lt;files&gt;<br></code></pre></td></tr></table></figure><h3 id="檔案從-staged-清單移除"><a href="#檔案從-staged-清單移除" class="headerlink" title="檔案從 staged 清單移除"></a>檔案從 staged 清單移除</h3><p>如果使用 <code>git add</code> 將檔案 staged 之後，發現這不是我要提交的樣子，希望將檔案從 staged 清單移出，那就可以使用以下指令：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git restore -S &lt;files&gt;    <span class="hljs-comment"># (-S for --staged)</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 git stash 暫存工作進度</title>
      <link href="/posts/1fa590b6/"/>
      <url>/posts/1fa590b6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在進行開發時，偶爾會有進行到一半必須切換分支處理別的工作的情況，這時候使用 <code>git stash</code> 暫存指令就會是個好選擇。  </p><span id="more"></span><h2 id="暫存進度-git-stash"><a href="#暫存進度-git-stash" class="headerlink" title="暫存進度(git stash)"></a>暫存進度(git stash)</h2><p>在新進度尚未提交(commit)時切換分支，可能會遇到兩種情況：  </p><ol><li>目前進度跟著一起移動到新的分支。  </li><li>因為發現潛在的衝突(conflict)， Git 不讓我切換分支。</li></ol><p>如果不希望這兩種情況中的任一種發生，可以使用 <code>git stash</code> 將目前「已追蹤」的檔案進度移入暫存區。  </p><blockquote><p>需特別注意的是：<code>git stash</code> 只會將「staged」和「unstaged」的檔案進度移入暫存區。如果有新增的「untracked file」，並需先用 <code>git add</code> 加入 staged 清單才會被一起移入暫存區。  </p></blockquote><p>這時候會發現進度已經回復到上一次提交的樣子了，而使用 <code>git status</code> 也只會看到「untracked file」被列出來。  </p><p><code>git stash</code> 可以建立多個暫存紀錄，不管是在同個分支上建立多個暫存、或是不同分支上建立多個暫存都可以，這些暫存紀錄會用建立時間「由新到舊」保存。  </p><h2 id="顯示暫存清單-git-stash-list"><a href="#顯示暫存清單-git-stash-list" class="headerlink" title="顯示暫存清單(git stash list)"></a>顯示暫存清單(git stash list)</h2><p>既然可以建立多個暫存，如果想套用其中一個暫存紀錄怎麼辦？這時候就可以用 <code>git stash list</code> 指令列出暫存紀錄清單。  </p><p>如圖所示，每個暫存項目會有個項目「序號」，從 0 開始由新到舊增加序號，並一併記錄是在哪個分支的哪個提交紀錄建立的。由於「暫存」並不像提交一樣有 commit message 可以做區分，所以僅能靠以上的資訊辨別不同的暫存內容。  </p><p><img src="/../Blog-image/posts/2022-06-09-gitStashList.webp" alt="git stash list">  </p><h2 id="恢復暫存進度"><a href="#恢復暫存進度" class="headerlink" title="恢復暫存進度"></a>恢復暫存進度</h2><p>有了暫存進度後，如果想要回復或者說套用暫存進度，有兩種方法可以使用。分別是 <code>pop</code> 和 <code>apply</code> ，兩者的差別在於套用進度之後，暫存紀錄的消失與否。暫存進度的套用不限建立暫存的分支使用，可用於任何一個分支。如果沒有指定某個序號的紀錄，預設會套用最新一次的暫存紀錄。  </p><p>偶爾在套用暫存進度時會產生衝突，這時只要像處理 merge conflict 一樣，將內容調整成希望的樣子，並用 <code>git add</code> 確認套用即可。  </p><h3 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h3><p>使用 <code>git stash pop</code> 套用進度時，原本在暫存區的紀錄「會」從清單中消失。可以使用的指令如下：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 套用最新一筆暫存紀錄</span><br>git stash pop<br><br><span class="hljs-comment"># 套用指定暫存紀錄</span><br>git stash pop stash@&#123;序號&#125;<br></code></pre></td></tr></table></figure><p>執行之後再次用 <code>git stash list</code> 就會發現紀錄從清單中消失了！  </p><h3 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h3><p>如果我們希望在多個分支套用相同的暫存內容，則可以使用 <code>git stash apply</code> ，該 指令執行後原本在暫存區的紀錄「不會」從清單中消失，可以繼續在其他地方使用。指令如下：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 套用最新一筆暫存紀錄</span><br>git stash apply<br><br><span class="hljs-comment"># 套用指定暫存紀錄</span><br>git stash apply stash@&#123;序號&#125;<br></code></pre></td></tr></table></figure><p>執行之後再次用 <code>git stash list</code> 會發現紀錄仍然存在清單中沒變。  </p><h2 id="刪除暫存進度"><a href="#刪除暫存進度" class="headerlink" title="刪除暫存進度"></a>刪除暫存進度</h2><p>建立暫存後也不一定要使用，可以直接刪除暫存紀錄。指令如下：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 刪除指定暫存紀錄</span><br>git stash drop stash@&#123;序號&#125;<br><br><span class="hljs-comment"># 刪除全部暫存紀錄</span><br>git stash clear<br></code></pre></td></tr></table></figure><p>執行之後再次用 <code>git stash list</code> 就會發現紀錄從清單中消失了！  </p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 git log 查看提交歷史紀錄</title>
      <link href="/posts/1e45a9f8/"/>
      <url>/posts/1e45a9f8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果在開發過程中有好好的撰寫提交訊息，就可以直接從過去的提交紀錄看出專案的開發歷史，也能看出各分支目前的開發進度到哪裡。  </p><span id="more"></span><h2 id="查看提交紀錄-git-log"><a href="#查看提交紀錄-git-log" class="headerlink" title="查看提交紀錄(git log)"></a>查看提交紀錄(git log)</h2><h3 id="列出提交歷史"><a href="#列出提交歷史" class="headerlink" title="列出提交歷史"></a>列出提交歷史</h3><p>除了輔助的圖像介面軟體，我們也可以直接用指令查看提交歷史紀錄。如果直接使用 <code>git log</code> ，則會列出 commitID 、提交人資訊、日期時間和提交訊息(如下圖)。這些紀錄是由新到舊列出來，也就是越上面的紀錄越新。  </p><blockquote><p>按下 <code>q</code> 鍵就可以退出 git log 畫面。  </p></blockquote><p><img src="/../Blog-image/posts/2022-06-08-gitLog.webp" alt="git log">  </p><p>上面的範例圖片列出了兩筆提交紀錄，可以看出第一筆有比較長的提交說明。如果在提交時不使用 <code>-m</code> 參數而直接使用 <code>git commit</code> ，就可以撰寫多行的提交訊息，將這次進行的修改內容做更詳細的說明。使用 <code>git log</code> 時，這些說明會被完整的列出來。  </p><h3 id="單行式紀錄-oneline-參數"><a href="#單行式紀錄-oneline-參數" class="headerlink" title="單行式紀錄(--oneline 參數)"></a>單行式紀錄(--oneline 參數)</h3><p>如果不需要查看完整的提交訊息，只是希望查看簡易的提交紀錄，可以使用 <code>--oneline</code> 參數來簡化列出的資訊。使用這個參數之後，提交紀錄會以單行的方式呈現，只會列出 commitID 和第一行的提交訊息。  </p><p><img src="/../Blog-image/posts/2022-06-08-gitLog-oneline.webp" alt="git log oneline">  </p><h3 id="圖像化紀錄-graph-參數"><a href="#圖像化紀錄-graph-參數" class="headerlink" title="圖像化紀錄(--graph 參數)"></a>圖像化紀錄(--graph 參數)</h3><p>較大或較多分支的專案常會用 SourceTree 之類的圖像化軟體來查看分支的動向，但其實 Git 也可以用指令達到類似的功能，那就是使用 <code>--graph</code> 參數。  </p><blockquote><p>請忽略很爛的 commit message……這只是一個備份用的 repo！  </p></blockquote><p><img src="/../Blog-image/posts/2022-06-08-gitLog-graph.webp" alt="git log graph">  </p><h2 id="其他補充"><a href="#其他補充" class="headerlink" title="其他補充"></a>其他補充</h2><p>除了以上列出的兩種外，還有很多其他參數可以用來指定提交紀錄呈現的格式、範圍篩選…其他資訊，這邊就不一一列示，想要研究或嘗試的，可以直接到 <a href="https://git-scm.com/book/zh-tw/v2/Git-%E5%9F%BA%E7%A4%8E-%E6%AA%A2%E8%A6%96%E6%8F%90%E4%BA%A4%E7%9A%84%E6%AD%B7%E5%8F%B2%E8%A8%98%E9%8C%84">Git 官方說明</a>查詢。  </p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Branch(清單、新建、刪除、重新命名、切換)</title>
      <link href="/posts/93113df5/"/>
      <url>/posts/93113df5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 Git 時，不管是在自己的專案開發或多人合作的專案，分支(Branch)都是個很重要的功能。它可以讓不同的事情「同步進行」，不會相互影響、也不需要互相等待。這篇主要針對建立、刪除、切換及重新命名來介紹。  </p><span id="more"></span><h2 id="查看分支清單-git-branch"><a href="#查看分支清單-git-branch" class="headerlink" title="查看分支清單(git branch)"></a>查看分支清單(<code>git branch</code>)</h2><p>每個分支都會有一個指標，告訴使用者這個分支目前的進度到哪裡，這個指標會指向該分支最新的 commit。所以只要建立一個新的 commit ，這個指標就會同步向前。  </p><p>當想要查看現有分支時，可以執行 <code>git branch</code> 指令。它會列出專案裡所有的<strong>有指標</strong>的分支，並在所在分支上用 <code>*</code> 標註。  </p><p><img src="/../Blog-image/posts/2022-06-06_gitBranch.webp" alt="git branch">  </p><br/><p>如果想在查看所有分支的同時，列出該分支指標分別在哪個 commit 上，則可以使用 <code>git branch -v</code> 。<br><code>-v</code> 是 <a href="https://git-scm.com/docs/git-branch#Documentation/git-branch.txt--v">verbose</a> 參數，可以查看本地端分支更詳細得訊息。如果使用 <code>-vv</code> 則可以連遠端儲存庫的指標都一起列出來。  </p><p><img src="/../Blog-image/posts/2022-06-06_gitBranchVerbose.webp" alt="git branch verbose">  </p><p>而比較特別的是，在我們新建了一個儲存庫 (執行 <code>git init</code>) 後，Git 雖然會直接幫我們建立一個分支 <code>main</code> (也可能是 <code>master</code> ，要看當初安裝 Git 時選哪個選項)，但是因為沒有任何一個 commit 存在，<code>main</code> 分支的指標沒有指向任何東西。這時如果使用 <code>git branch</code> 指令，並不會看到任何分支。在這種情況下 commit ，Git 會自動在 <code>main</code> 分支上 commit 並將 <code>main</code> 分支的指標移到這個 commit 上。  </p><h2 id="什麼是-HEAD"><a href="#什麼是-HEAD" class="headerlink" title="什麼是 HEAD"></a>什麼是 HEAD</h2><h3 id="HEAD-介紹"><a href="#HEAD-介紹" class="headerlink" title="HEAD 介紹"></a>HEAD 介紹</h3><p>HEAD 也是一種指標，它會指向使用者目前所在的 commit 位置。一般來說， HEAD 都會指向所在分支最新的 commit(也就是該分支的指標位置)。  </p><blockquote><p>如果使用 sourcetree 查看，HEAD 會是一個空心的圓圈。</p></blockquote><h3 id="detached-HEAD"><a href="#detached-HEAD" class="headerlink" title="detached HEAD"></a>detached HEAD</h3><p>有一種例外情況是使用 <code>git checkout &lt;commit&gt;</code> ，也就是查看特定的 commit 版本，這種情況下 HEAD 就會指向該 commit 而不是指向分支指標，也就是 HEAD 不在任何一個分支指標上(即使該 commit 是某分支的指標位置也一樣)，會出現 <code>detached HEAD</code> 訊息。  </p><p>不過看到這個訊息也不用太緊張，它只是做個提醒而已，仍然可以瀏覽檔案和編輯。如果希望從這個 commit 開始做些新進度，也可以直接從這裡建立新分支。  </p><h2 id="新建分支-git-branch-lt-branch-name-gt"><a href="#新建分支-git-branch-lt-branch-name-gt" class="headerlink" title="新建分支(git branch &lt;branch-name&gt;)"></a>新建分支(<code>git branch &lt;branch-name&gt;</code>)</h2><p>要建立新的分支，只要使用 <code>git branch &lt;branch-name&gt;</code> 指令即可。需要注意的是，他會從 HEAD 的指標位置「長出」新分支，但是 HEAD 位置仍然維持在原分支上，不會移動到新分支上。  </p><p>所以就要提到一個特殊情況，前面有提到，剛建立一個儲存庫時並沒有 commit 存在，所以也沒有 HEAD 指標。如果我們的第一個 commit 不想用預設的 <code>main</code> 分支，而是想直接 commit 在自己新建的分支上，直接使用 <code>git branch &lt;branch-name&gt;</code> 的話， Git 會因為無法從 HEAD 產生新分支而跳出錯誤訊息。這時候可以使用 <code>git switch -c &lt;branch-name&gt;</code> 來處理。</p><h2 id="切換分支-git-switch-lt-branch-name-gt"><a href="#切換分支-git-switch-lt-branch-name-gt" class="headerlink" title="切換分支(git switch &lt;branch-name&gt;)"></a>切換分支(<code>git switch &lt;branch-name&gt;</code>)</h2><p><code>git switch</code> 是比較近期出現的指令(2019年 Git 2.23 Release Notes 釋出)。原本要切換分支是使用 <code>git checkout &lt;branch-name&gt;</code> ，這個指令還是可以用，只是 <code>git checkout</code> 的功能較多，容易造成使用上的混淆，因此可以改用新指令 <code>git switch &lt;branch-name&gt;</code>。  </p><p>使用 <code>git switch &lt;branch-name&gt;</code> 可以直接切換分支，將 HEAD 指標移向該分支指標。另外，使用 <code>-c</code> 參數(create) 可以直接切換到新建立的分支。  </p><h2 id="刪除分支-git-branch-d-lt-branch-name-gt"><a href="#刪除分支-git-branch-d-lt-branch-name-gt" class="headerlink" title="刪除分支(git branch -d &lt;branch-name&gt;)"></a>刪除分支(<code>git branch -d &lt;branch-name&gt;</code>)</h2><p>要刪除一個分支的話，首先要確認自己目前「不在」要刪除的分支上，接著要確認該分支是否已經和它的上游分支「merge」。  </p><p>刪除分支可以使用兩種參數： <code>-d</code> 和 <code>-D</code> 。 <code>-d</code> 會檢查要刪除的分支是否已經和它的上游分支合併，如果沒有則會跳出提示訊息。 <code>-D</code> 則是無論是否進行過合併分支都要直接進行刪除，因此在使用上要特別小心。  </p><h2 id="重新命名分支-git-branch-m-lt-new-name-gt"><a href="#重新命名分支-git-branch-m-lt-new-name-gt" class="headerlink" title="重新命名分支(git branch -m &lt;new-name&gt;)"></a>重新命名分支(<code>git branch -m &lt;new-name&gt;</code>)</h2><p>重新命名一個分支則是要確認自己目前「在」目標分支上，然後使用 <code>-m</code> 參數加上新名字來重新命名。  </p><p>如果有使用過 <code>git commit -m</code> 來進行 commit 的話，可能會對 <code>-m</code> 這個參數感到混淆，這邊特別說明一下。在 git commit 時的 <code>-m</code> 參數是「message」的意思；而 git branch 時的 <code>-m</code> 參數則是「move」的意思。</p><p>在 command line 的世界裡，「move」可以用來移動檔案和重新命名。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把 abc.txt 重新命名為 123.txt</span><br><span class="hljs-built_in">mv</span> abc.txt 123.txt<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的 markdown 語法</title>
      <link href="/posts/71aa6829/"/>
      <url>/posts/71aa6829/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期寫專案 README 和 Blog 常常會用到 markdown ，整理一篇常用語法！可以直接點左邊目錄，跳到相對應的主題位置。  </p><blockquote><p>參考資料：<a href="https://markdown.tw/">https://markdown.tw/</a></p></blockquote><span id="more"></span><h2 id="標題"><a href="#標題" class="headerlink" title="標題"></a>標題</h2><p>Markdown支援 Setext 和 atx 兩種形式的標題語法。但因為 Setext 語法僅分兩級標題，使用 atx 語法會比較有撰寫彈性及方便，下面列出的是 atx 語法的標題。  </p><p>標題會自動佔滿一整行。不同級別的標題使用起來會有字體大小、粗細…等樣式上的差別。  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 這是一級標題</span><br><span class="hljs-section">## 這是二級標題</span><br><span class="hljs-section">### 這是三級標題</span><br><span class="hljs-section">#### 這是四級標題</span><br><span class="hljs-section">##### 這是五級標題</span><br><span class="hljs-section">###### 這是六級標題</span><br></code></pre></td></tr></table></figure><h2 id="區塊引言"><a href="#區塊引言" class="headerlink" title="區塊引言"></a>區塊引言</h2><p>Markdown使用email形式的區塊引言， <code>&gt;</code> 會強迫斷行。  </p><p>區塊引言可以有階層(如下圖所示)，只要根據層數加上不同數量的 <code>&gt;</code> 即可。引言的區塊內也可以使用其他的Markdown語法，包括標題、清單、程式碼區塊…等。  </p><blockquote><p>一級區塊引言</p><blockquote><p>二級區塊引言</p><blockquote><p>三級區塊引言</p></blockquote></blockquote></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 一級區塊引言</span><br>&gt;&gt; 二級區塊引言<br>&gt;&gt;&gt; 三級區塊引言<br></code></pre></td></tr></table></figure><h2 id="清單"><a href="#清單" class="headerlink" title="清單"></a>清單</h2><p>清單分為「有序清單」和「無序清單」。</p><ul><li>在項目標記後面則一定要接著至少一個空白或tab。  </li><li>如果清單項目間用空行分開， Markdown會把項目的內容在輸出時用 <code>&lt;p&gt;</code> 標籤包起來。</li></ul><p><strong>無序清單( unordered list )</strong> 可以使用星號(<code>*</code>)、加號(<code>+</code>)或是減號(<code>-</code>)作為標記。無論哪種寫法，呈現出來的結果都一樣。</p><ul><li>無序清單範例</li></ul><ul><li>無序清單範例</li></ul><ul><li>無序清單範例</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 無序清單範例<br><span class="hljs-bullet">+</span> 無序清單範例<br><span class="hljs-bullet">-</span> 無序清單範例<br></code></pre></td></tr></table></figure><p><strong>有序清單( ordered list )</strong> 則是以數字加上英文句點(<code>.</code>)作為標記，項目標記後面則一定要接著至少一個空白或tab。比較特別的是，目前在清單標記上使用的數字並不會影響輸出的HTML結果。</p><ol><li>有序清單一</li><li>有序清單二</li><li>有序清單三</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序清單一<br><span class="hljs-bullet">2.</span> 有序清單二<br><span class="hljs-bullet">8.</span> 有序清單三(如上範例呈現，數字並不影響結果)<br></code></pre></td></tr></table></figure><h2 id="程式碼區塊及上色"><a href="#程式碼區塊及上色" class="headerlink" title="程式碼區塊及上色"></a>程式碼區塊及上色</h2><p>撰寫程式碼區塊時可以用兩行的三個反引號(`&#96;&#96;)包裹程式碼，如果第一行的三個反引號(`&#96;&#96;)後面有加上程式語言名稱，它會自動辨識關鍵字並上色。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">// markdown 撰寫語法如下:<br><span class="hljs-code">```js(語言名稱)</span><br><span class="hljs-code">console.log(&#x27;Hello World!&#x27;)</span><br><span class="hljs-code">```</span>\(為了讓它能正常顯示，所以加了跳脫符號&quot;\&quot;，實際撰寫時不加)<br></code></pre></td></tr></table></figure><h2 id="引入圖片"><a href="#引入圖片" class="headerlink" title="引入圖片"></a>引入圖片</h2><p>markdown 語法也可以貼上圖片，寫法如下方範例。圖片說明等同 HTML <code>&lt;img&gt;</code> 的 <code>alt</code> property；而括號裡面填上圖片網址或在專案裡面的相對位置都可以。  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">圖片說明</span>](<span class="hljs-link">圖片 URL</span>)<br></code></pre></td></tr></table></figure><h2 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h2><p>即 HTML 的 <code>&lt;a&gt;</code> 。有些支援「文內跳轉」的地方，也可以在括號內填入文章的錨點。  </p><p>連結寫法有「參考式連結」和「行內形式連結」。</p><ul><li>參考式連結可以讓文件更像是瀏覽器最後產生的結果，把一些標記相關的資訊移到段落文字之外，不讓文章的閱讀感覺被打斷。有興趣研究的可以到文章開頭提供的網址查看。  </li><li>平常不會一次寫太多連結時，行內形式連結寫起來較直覺，所以這邊只提供「行內形式連結」寫法。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">連結文字</span>](<span class="hljs-link">連結 URL</span>)<br></code></pre></td></tr></table></figure><h2 id="字體變化"><a href="#字體變化" class="headerlink" title="字體變化"></a>字體變化</h2><p><strong>粗體</strong><br><strong>也是粗體</strong><br><em>斜體</em><br><em>也是斜體</em>  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**粗體**</span><br><span class="hljs-strong">__也是粗體__</span><br><span class="hljs-emphasis">*斜體*</span><br><span class="hljs-emphasis">_也是斜體_</span><br></code></pre></td></tr></table></figure><h2 id="插入空白行"><a href="#插入空白行" class="headerlink" title="插入空白行"></a>插入空白行</h2><p>有些東西屬於「行內元素」，在 markdown 語法裡的 Enter(換行)會被自動忽略。比如平常編輯兩個段落文字時，使用 Enter 就會自動換行開始新段落，但在 markdown 裡則是使用兩個半型空格(<code>  </code>)。  </p><p>使用兩個半型空格(<code>  </code>)後會強制換行產生新段落。在兩個段落間多插入一行或多行空白行則會在兩段落間增加一點段落間距(margin)，但空白行的數量並不影響間距大小。如果真的想呈現多行空白行，則可使用 HTML 元素 <code>&lt;br/&gt;</code> 來達成。  </p><h2 id="分隔線"><a href="#分隔線" class="headerlink" title="分隔線"></a>分隔線</h2><p>在一行中用三個或以上的星號、減號、底線來建立一個分隔線，行內不能有其他東西。<br>符號中間可以插入空格。下面每種寫法都可以建立分隔線：  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> <span class="hljs-emphasis">* *</span><br><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">*</span>**</span><span class="hljs-strong">**</span><br><span class="hljs-strong">- - -</span><br><span class="hljs-strong">---------------------------------------</span><br><span class="hljs-strong">__<span class="hljs-emphasis">_</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">_</span> <span class="hljs-emphasis">_ _</span></span><br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>markdown 也可以畫表格，但樣式較簡單無彈性。僅有基本的表格、對齊功能，而沒有「合併儲存格」的功能。  </p><p>製作表格方式也很簡單，只要「畫」出來即可。用 <code>|</code> 畫出表格的左右框線；在表頭和內容中間必須插入一行 <code>|----|</code> ( <code>-</code> 數量不限)，同時可以用 <code>:</code> 來調整文字的對齊方式，使用方式如下方範例。 </p><table><thead><tr><th>這是表頭1</th><th align="center">這是表頭2</th><th align="left">這是表頭3</th><th align="right">這是表頭4</th></tr></thead><tbody><tr><td>預設</td><td align="center">置中</td><td align="left">靠左</td><td align="right">靠右</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 這是表頭1 | 這是表頭2 | 這是表頭3 | 這是表頭4 |<br>| --------- | :-------: | :-------- | --------: |<br>| 預設      |   置中    | 靠左      |      靠右 |<br></code></pre></td></tr></table></figure><h2 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h2><p>使用 markdown 在寫作上更方便，但相對來說排版和樣式上的彈性就小很多了。如果希望有更多樣式上的變化(如：顏色…等)，就需要直接用 HTML 來書寫了！  </p>]]></content>
      
      
      <categories>
          
          <category> Cheat Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cheat Sheet </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 git commit --amend 修改 commit 紀錄</title>
      <link href="/posts/362cfd32/"/>
      <url>/posts/362cfd32/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 Git 時，偶爾會在 commit 過程中發生一些小失誤，不管是 typo 或是部分檔案忘記加入 staged files 清單一起 commit。這種時候，<code>git commit --amend</code> 就是一個很方便的指令了。</p><span id="more"></span><h2 id="amend-參數介紹"><a href="#amend-參數介紹" class="headerlink" title="--amend 參數介紹"></a>--amend 參數介紹</h2><p>根據 <a href="https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---amend">Git 官方說明</a>，加上 <code>--amend</code> 參數會在「當前分支」產生一筆<strong>新的 commit</strong> 來取代最近一次的 commit 紀錄。如果沒有在使用 <code>--amend</code> 參數的同時追加使用 <code>-m</code>、<code>-F</code> 或 <code>-c</code> …等參數，預設會將當前分支最近一筆的 commit message 帶入用作修改預設值。  </p><p>值得注意的是，說明提到「新的 commit」。表示 <code>--amend</code> 是用新的 commit 取代舊的，而不是直接修改原始 commit 內容，所以編號會被修改。  </p><blockquote><p>由於是產生一筆新的 commit ，所以最好只在尚未 push 到遠端儲存庫時使用。  </p></blockquote><h2 id="amend-使用"><a href="#amend-使用" class="headerlink" title="--amend 使用"></a>--amend 使用</h2><p><code>git commit --amend</code> 使用時會像 <code>git commit</code> 一樣跳出預設文字編輯器，只是跳出時已將當前分支最近一次的 commit message 帶入。  </p><h3 id="只修改-commit-message"><a href="#只修改-commit-message" class="headerlink" title="只修改 commit message"></a>只修改 commit message</h3><p>當只想修改最近一次 commit 的 commit message (因為錯字或其他原因)，不想變動 commit 的其他內容(檔案、作者訊息…等)。下面的指令可以二擇一使用：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 會跳出文字編輯器(自動帶入前一個 commit message)</span><br>git commit --amend<br><br><span class="hljs-comment"># 直接輸入新的 commit message</span><br>git commit --amend -m <span class="hljs-string">&quot;新的 commit message&quot;</span><br></code></pre></td></tr></table></figure><h3 id="將漏掉的檔案加進最近一次的-commit-裡"><a href="#將漏掉的檔案加進最近一次的-commit-裡" class="headerlink" title="將漏掉的檔案加進最近一次的 commit 裡"></a>將漏掉的檔案加進最近一次的 commit 裡</h3><p>有時候進行多個檔案的編輯，在進行 <code>git add</code> 時不小心漏掉了幾個檔案沒有加到。則可以用下列方式修改：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 將檔案加入 staged files</span><br>git add file1.txt file2.txt<br><br><span class="hljs-comment"># 修改最近一次 commit</span><br>git commit --amend<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 設置及基礎使用(add &amp; commit)</title>
      <link href="/posts/6adb515e/"/>
      <url>/posts/6adb515e/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>隨著使用 Git 一段時間了，一開始一頭霧水的操作也比較有概念了，是時候整理筆記了!<br>當然，為了訓練自己盡快習慣命令列介面，操作過程中全部使用命令列介面(真的不習慣的人還是有圖形化介面可以用)，常用指令可以參考 <a href="../800dd5f5">Terminal 常用指令</a>。</p><span id="more"></span><h2 id="Git-安裝及設定"><a href="#Git-安裝及設定" class="headerlink" title="Git 安裝及設定"></a>Git 安裝及設定</h2><blockquote><p>作業系統： windows 10</p></blockquote><ul><li><p>到 <a href="https://git-scm.com/">Git 官方網站</a>進行下載並安裝。  </p></li><li><p>打開 Git bash 或任何自己慣用的命令列介面。</p></li><li><p>設定 <code>name</code> 和 <code>email</code>。<br>如下圖所示， Git 在建立一個版本紀錄時，會給這個紀錄 「commit 編號」、「Author name」、「Author email」、建立時間和「版本訊息(commit message)」…等訊息。在多人合作的專案中，當需要對特定版本進行討論時，知道版本建立人的資訊就非常的重要。  </p><p><img src="/../Blog-image/posts/2022-06-02_gitLog.webp" alt="git Log Screenshot">  </p><p>「Author name」是希望讓其他人知道的稱呼方式、「Author email」則是聯絡資訊。通常不會頻繁更換這兩個資訊，所以可以直接用全域( <code>--global</code> )設定即可。如果有傳遞 <code>--global</code> 參數，只需要設定這一次，之後都會直接套用此資訊。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 不限執行目錄</span><br>git config --global user.name <span class="hljs-string">&quot;想顯示的名稱&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;想顯示的聯絡方式&quot;</span><br><br><span class="hljs-comment"># 完成後可執行以下命令來檢查設定結果</span><br>git config --list<br></code></pre></td></tr></table></figure><p><strong>備註：如果特定專案想用不同的名字或電子郵件，只需要在該專案目錄內執行不加 <code>--global</code> 參數的命令進行設定即可。</strong></p></li></ul><h2 id="為專案建立-Git-repository"><a href="#為專案建立-Git-repository" class="headerlink" title="為專案建立 Git repository"></a>為專案建立 Git repository</h2><ul><li><p>當我們打算使用 Git 來追蹤專案時，只需要進入該專案的資料夾(根目錄)並執行：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>它會在當前目錄裡建立 <code>.git</code> 資料夾(隱形資料夾)，並在裡面紀錄專案的版本紀錄。  </p></li><li><p>如果想在當前目錄建立新的專案資料夾並追蹤，執行以下指令：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init &lt;folder_name&gt;<br></code></pre></td></tr></table></figure><p>它會在當前目錄建立新資料夾，並在資料夾內建立 <code>.git</code> 資料夾(隱形資料夾)來追蹤專案。</p></li></ul><hr><ul><li><p>一個 Git repository 原則上會追蹤資料夾內的每個檔案(除了 ignore 清單)，所以要注意不要在 repository 裡建立另一個 repository。  </p></li><li><p>如果要刪除整個專案的追蹤紀錄，只要刪除 <code>.git</code> 資料夾即可。</p></li></ul><h2 id="什麼是-commit？"><a href="#什麼是-commit？" class="headerlink" title="什麼是 commit？"></a>什麼是 commit？</h2><p>Git commit 類似「存檔」的動作，他會紀錄檔案的「快照」。因為是快照，所以它可以將版本進行比較、回復、合併…等操作。  </p><ul><li>不同 commit 間的比較，就是比對兩個版本「快照」不同的地方。  </li><li>「回復成之前的版本」就是讓檔案回到指定版本快照的樣子。  </li><li>「合併」就是將指定的幾個版本中不同的地方都保留，並留下新的快照。</li></ul><h2 id="Git-status-說明"><a href="#Git-status-說明" class="headerlink" title="Git status 說明"></a>Git status 說明</h2><h3 id="三種-status"><a href="#三種-status" class="headerlink" title="三種 status"></a>三種 status</h3><p>要使用 Git 來做版本追蹤，首先要知道被追蹤專案裡的檔案處於哪種狀態？  </p><p>Git repository 會將專案裡的所有檔案分成以下幾種狀態 ——  </p><ol><li>Untracked files：Git 尚未追蹤的檔案。沒有提交(commit)過、也還沒用 <code>git add</code> 指令加入追蹤清單。  </li><li>Unstaged files：編輯中的檔案，還沒有打算把當下進度「拍照」。  </li><li>Staged files：編輯告一段落，決定把檔案當下進度進行「快照」。  </li><li>Committed：版本「快照」完成，並留下該版本的相關訊息。</li></ol><p>不同的檔案可能處於不同的狀態，可以用以下指令來查看專案中檔案處於哪種狀態。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><h3 id="git-status-指令"><a href="#git-status-指令" class="headerlink" title="git status 指令"></a>git status 指令</h3><p>執行 <code>git status</code> 指令後會列出尚未進行提交(commit)的檔案清單，並分成三個部分(有內容的才會顯示) ——  </p><ol><li>Changes to be committed：即已經用 <code>git add</code> 加入等待提交的檔案清單。  </li><li>Changes not staged for commit：即已追蹤的檔案(以前提交過)，目前編輯中，還沒使用 <code>git add</code> 改變狀態的清單。  </li><li>Untracked files：即尚未追蹤的檔案(沒有提交過)，也還沒使用 <code>git add</code> 開始追蹤的清單。</li></ol><blockquote><p>Untracked files 對 Git 版本管理來說是「還不存在」的檔案，因為還沒告訴 Git 去關注檔案的異動。與已追蹤的檔案相比，執行某些指令時會被 Git 忽略。  </p></blockquote><p><img src="/../Blog-image/posts/2022-06-02_gitStatus.webp" alt="git status"></p><h2 id="建立-commit-add-amp-commit"><a href="#建立-commit-add-amp-commit" class="headerlink" title="建立 commit (add &amp; commit)"></a>建立 commit (add &amp; commit)</h2><p>接下來要介紹的兩個指令可以讓檔案在不同的 status 中移動。初學階段最常用到的兩個指令分別是 <code>git add</code> 跟 <code>git commit</code>。  </p><h3 id="git-add-指令"><a href="#git-add-指令" class="headerlink" title="git add 指令"></a>git add 指令</h3><p>git add 作用：把檔案加入等待「快照」的清單中。如果再次執行 <code>git status</code> ，會發現指定檔案已經從 Unstaged files 清單移到 Staged files 清單中了。   </p><p>Git 每次建立新版本時，並不限於「一個」檔案的快照，而是可以一口氣幫多個檔案進行「快照」。使用 <code>git add</code> 指令的目的就是將指定的檔案加入等候「快照」的清單中。使用 <code>git add</code> 指令時，須將檔案的副檔名一併寫上。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加入一個指定檔案</span><br>git add test1.txt<br><br><span class="hljs-comment"># 加入多個指定檔案</span><br>git add test1.txt test2.txt test3.txt<br></code></pre></td></tr></table></figure><p>當我們想要將 Unstaged files 清單中的所有檔案一口氣加到 Staged files 清單時，可以執行另一個指令：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure><h3 id="git-commit-m-指令"><a href="#git-commit-m-指令" class="headerlink" title="git commit -m 指令"></a>git commit -m 指令</h3><p>git commit 作用：為這次建立的新版本進行快照，並添加說明訊息。執行這個指令會將 Staged files 清單中的所有檔案進行「快照」、加入版本資訊(編號、作者資訊、說明訊息、時間…等)，完成後 Staged files 清單中會恢復空白狀態。  </p><p>Git 預設的文字編輯器是 Vim ，他是一個對初學者來說相對不友善的工具(但很多 coding 大大很愛用)，如果沒有使用過這個工具，可能會連怎麼輸入或怎麼離開都不知道。當我們輸入 <code>git commit</code> 時，它會自動開啟 Vim 來讓你輸入 commit message ，為了避免初學時期碰到「進退兩難」的情況，通常會先使用 <code>git commit -m</code> 指令替代。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;想要加入的訊息放在雙引號裡&quot;</span><br></code></pre></td></tr></table></figure><p>加入 <code>-m</code> 這個參數，可以讓我們在進行 commit 指令的同時，直接加入「單行」的 commit message ，不會另外跳出 Vim 介面來進行編輯。  </p><p>這時，如果我們執行 <code>git log</code> 查看版本紀錄，就會發現多了一筆最新加入的 commit 版本了！  </p><h3 id="變更預設文字編輯器"><a href="#變更預設文字編輯器" class="headerlink" title="變更預設文字編輯器"></a>變更預設文字編輯器</h3><p>如前面說明提到，使用  <code>git commit</code> 指令會跳出當初在安裝 Git 時選定的文字編輯器(預設是 Vim)。如果想變更成其他文字編輯器，可以到 <a href="https://git-scm.com/book/en/v2/Appendix-C%3A-Git-Commands-Setup-and-Config">Github 官方文件</a>找到想使用的編輯器，並在命令列介面輸入右邊提供的指令即可。  </p><h2 id="Git-指令練習"><a href="#Git-指令練習" class="headerlink" title="Git 指令練習"></a>Git 指令練習</h2><blockquote><p>練習題目：<a href="https://www.notion.so/Committing-Basics-Exercise-3dc1ef1873ce45e68cedd2265710d7d8">題目內容</a><br>題目來源：<a href="https://www.udemy.com/course/git-and-github-bootcamp/">The Git &amp; Github Bootcamp  ——Colt Steele</a>  </p></blockquote><p>這個練習只用到了上面介紹的指令，也是初學階段最常用到的指令。可以先點開連結試著做一次，如果遇到問題再參考下面列出的作法。  </p><div class="note note-info no-icon 題目執行指令範例">            <ol><li><p>Create a new folder called <code>Shopping</code>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> Shopping<br></code></pre></td></tr></table></figure></li><li><p>Initialize a new git repo inside of the Shopping folder (make sure you’re not already inside of a Git repo!)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> Shopping<br>git init<br></code></pre></td></tr></table></figure></li><li><p>Make a new file called <code>yard.txt</code>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> yard.txt<br></code></pre></td></tr></table></figure></li><li><p>Make another new file called <code>groceries.txt</code>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> groceries.txt<br></code></pre></td></tr></table></figure></li><li><p>Make a commit that includes both empty files.  The message should be “create yard and groceries lists”  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add yard.txt groceries.txt<br>git commit -m <span class="hljs-string">&quot;create yard and groceries lists&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>In the <code>yard.txt</code> file, add the following changes:<br>  - 2 bags of potting soil<br>  - 1 bag of worm castings</p></li><li><p>In the groceries.txt file, add the following:<br>  - 4 tomatoes<br>  - 6 shallots<br>  - 1 fennel bulb</p></li><li><p>Make a new commit, including ONLY the changes from the <code>groceries.txt</code> file.  The commit message should be “add ingredients for tomato soup”  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add groceries.txt<br>git commit -m <span class="hljs-string">&quot;add ingredients for tomato soup&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>Make a second commit including ONLY the changes to the <code>yard.txt</code> file.  It should have the commit message “add items needed for garden box”  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add yard.txt<br>git commit -m <span class="hljs-string">&quot;add items needed for garden box&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>Next up, add the following line to the end of <code>groceries.txt</code><br>- couple of seed potatos</p></li><li><p>In the <code>yard.txt</code> file, change the first line so that it says “3 bags of potting soil” instead of “2 bags of potting soil”<br>- 3 bags of potting soil<br>- 1 bag of worm castings</p></li><li><p>Make a commit that includes the changes to BOTH files.  The message should read “add items needed to grow potatoes”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;add items needed to grow potatoes&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>Use a Git command to display a list of the commits. You should see 4!  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure></li></ol>          </div>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Terminal 常用指令</title>
      <link href="/posts/800dd5f5/"/>
      <url>/posts/800dd5f5/</url>
      
        <content type="html"><![CDATA[<p>在使用指令介面時，偶爾會忘記特定指令。所以建立一篇 cheat sheet 方便之後需要時查詢。  </p><span id="more"></span><h2 id="快速鍵"><a href="#快速鍵" class="headerlink" title="快速鍵"></a>快速鍵</h2><table><thead><tr><th>Windows 快速鍵</th><th>MacOS 快速鍵</th><th>用途</th></tr></thead><tbody><tr><td><code>tab</code></td><td><code>tab</code></td><td>輸入部分，可自動補齊後面內容</td></tr><tr><td><code>↑</code> <code>↓</code></td><td><code>↑</code> <code>↓</code></td><td>跳出之前用過的指令，可直接 enter 執行</td></tr></tbody></table><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><table><thead><tr><th>Windows 指令</th><th>MacOS 指令</th><th>用途</th></tr></thead><tbody><tr><td>cd ..</td><td>cd ..</td><td>進入上層資料夾</td></tr><tr><td>cd <code>path</code></td><td>cd <code>path</code></td><td>進入指定資料夾</td></tr><tr><td>clear</td><td>clear</td><td>清空終端機內容</td></tr><tr><td>ls</td><td>ls</td><td>列出當前目錄裡的所有內容</td></tr><tr><td>ls -a</td><td>ls -a</td><td>列出當前目錄裡的所有內容(含隱藏檔案)</td></tr><tr><td>mkdir <code>folder name(s)</code></td><td>mkdir <code>folder name(s)</code></td><td>新建一個或多個資料夾</td></tr><tr><td>start .</td><td>open .</td><td>打開當前目錄的圖形化介面</td></tr><tr><td>pwd</td><td>pwd</td><td>列出當前位置路徑</td></tr><tr><td>rm <code>file name(s)</code></td><td>rm <code>file name(s)</code></td><td>刪除一個或多個檔案</td></tr><tr><td>rm -rf <code>folder name(s)</code></td><td>rm -rf <code>folder name(s)</code></td><td>刪除一個或多個資料夾(及其內容)<br/>(r &#x3D; recursive, f &#x3D; force)</td></tr><tr><td>touch <code>file name(s)</code></td><td>touch <code>file name(s)</code></td><td>新建一個或多個檔案</td></tr></tbody></table><p>備註：在命令列進行「刪除」不會將檔案&#x2F;資料夾移到資源回收筒，而是直接刪除。  </p>]]></content>
      
      
      <categories>
          
          <category> Cheat Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cheat Sheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS50x(2022)】Complexity and Big O Notation</title>
      <link href="/posts/6466fe30/"/>
      <url>/posts/6466fe30/</url>
      
        <content type="html"><![CDATA[<p>在上 CS50x 第三週的演算法時，總覺得對「時間複雜度」的理解不夠清楚，因此另外找了課程做補充。  </p><span id="more"></span><blockquote><p>課程連結： <a href="https://www.udemy.com/course/algorithm-data-structure/">資料結構與演算法(JavaScript)</a>  </p></blockquote><h2 id="演算法"><a href="#演算法" class="headerlink" title="演算法"></a>演算法</h2><h3 id="什麼是演算法？"><a href="#什麼是演算法？" class="headerlink" title="什麼是演算法？"></a>什麼是演算法？</h3><blockquote><p>Algorithms means step-by-step instructions for solving problems. —— CS50x  </p></blockquote><p>簡單來說，就是解決一個特定問題的步驟的集合。這個「問題」並不是狹義上的問題，而是一個想要達成的「目標」，而演算法就是達成這個目標所需經歷的過程。  </p><p>以第一週的二分搜尋法舉例，從拿到電話簿到找到電話號碼中間經過的13個步驟，就是所謂的演算法。  </p><table><thead><tr><th align="center">Input</th><th align="center">Algorithm</th><th align="center">Output</th></tr></thead><tbody><tr><td align="center">A phone book</td><td align="center"><img src="/../Blog-image/posts/2022-04-29_pseudocode.webp" alt="pseudocode"></td><td align="center">Find phone number</td></tr></tbody></table><br><br><h3 id="如何比較演算法？"><a href="#如何比較演算法？" class="headerlink" title="如何比較演算法？"></a>如何比較演算法？</h3><blockquote><p><strong>Time</strong> and <strong>Space</strong> are the concerns. The less time it takes, the better it is.<br> —— 資料結構與演算法(JavaScript)課程  </p></blockquote><p>解決同一個問題可以有很多種不同的方法，每個方法的效率也不一樣。一個好的演算法，就是能用更有效率的方式解決問題。在電腦科學的世界裡，通常會用兩個面向來衡量演算法的效率：  </p><ol><li><p><strong>時間複雜度(Time Complexity)：</strong> 如果直接為執行過程計時，通常結果會受到多方因素的影響(硬體設備、輸入資料規模…等)，所以直接計時是比較沒有參考價值的。而時間複雜度指的是執行過程中所需經過的「步驟數量」，這個在稍後會有比較詳細的說明。  </p></li><li><p><strong>空間複雜度(Space Complexity)：</strong> 是指一支程式在執行時需要耗費多少的記憶體資源。</p></li></ol><p>有時候我們需要在這兩者之間做取捨。就像我們平常在買電腦時一樣，如果希望電腦跑得快一點，就要多投資在硬體資源上；反之，如果想要節省硬體資源成本，可能就會花較多的時間成本。  </p><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><h3 id="時間複雜度的計算"><a href="#時間複雜度的計算" class="headerlink" title="時間複雜度的計算"></a>時間複雜度的計算</h3><p>前面提到，時間複雜度指的是執行過程中所需經過的「步驟數量」。一個加法、減法、乘法、除法、比較…等都分別算一個步驟，不同規模的輸入資料可能會影響執行步驟的數量。例如：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>            --&gt; 經過<span class="hljs-number">2</span>個步驟<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span>    --&gt; 經過<span class="hljs-number">4</span>個步驟<br></code></pre></td></tr></table></figure><p>範例一：等差級數的相加，如果使用 for 迴圈執行。則 <code>step == n</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">addition</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    result += i;<br>    step ++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>範例二：等差級數的相加，如果使用梯形的面積公式執行，則 <code>step == 3</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">addition</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-type">int</span> result = (<span class="hljs-number">1</span> + n) * n / <span class="hljs-number">2</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>範例三：雙重迴圈執行步驟，則 <code>step == n 平方</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">addition</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <br>  <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      step++<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>從上面的例子可以看出，時間複雜度常常跟 input 資料的規模 <code>n</code> 有一定的關聯性。通常 <code>n</code> 越大，需要執行的步驟也越多。</p><h3 id="時間複雜度的表示方式"><a href="#時間複雜度的表示方式" class="headerlink" title="時間複雜度的表示方式"></a>時間複雜度的表示方式</h3><p>一個演算法的時間複雜度有三種：  </p><ol><li><strong>Big O notation：</strong> 指「最壞」情況下需要經過的步驟數量。  </li><li><strong>Big Ω notation：</strong> 指「最好」情況下需要經過的步驟數量。  </li><li><strong>Big Θ notation：</strong> 表示「最好」和「最壞」相等的情況。</li></ol><p>三種複雜度中，最需要考量的是 Big O notation ，因為它是衡量一個演算法「最大成本」的基準。常見的時間複雜度如下表：<code>O(1)</code>、<code>O(log n)</code>、<code>O(n)</code>、<code>O(nlog n)</code>、<code>O(n^2)</code>。其中， <code>n</code> 指的是資料規模，<code>()</code> 中則表示步驟數量。  </p><p>在表示步驟數量時有幾個慣例：  </p><ol><li>Constant doesn’t matter (例如：如果執行步驟為 <code>O(3n)</code> 會直接用 <code>O(n)</code> 表示。)  </li><li>Small Terms don’t matter (例如：如果執行步驟為 <code>O(n^2+3n+1)</code> 會直接用 <code>O(n^2)</code> 表示。)  </li><li>Logarithm Base doesn’t matter (例如：如果執行步驟為 <code>O(log2 n)</code> 會直接用 <code>O(log n)</code> 表示。)</li></ol><p>其原因為，如果資料量大到一定程度，以上 3 個條件對步驟數量的影響會大幅度縮小。用以下表格例子，在 <code>n</code> 和 <code>n + 1500</code> 的結果看來，當資料規模逐漸變大，除了影響最大的 <code>n</code> 以外，<code>1500</code> 的影響力在逐漸縮小。<br><img src="/../Blog-image/posts/2022-05-26_TimeComplexity.webp" alt="time complexity"></p><h2 id="演算法的優化"><a href="#演算法的優化" class="headerlink" title="演算法的優化"></a>演算法的優化</h2><p>由前面的說明可以看出，一個演算法的設計對執行效率有很大的影響。  </p><p>拿前面的等差數列相加為例：如果使用 for 迴圈執行，則 <code>step == n</code>；如果使用梯形的面積公式執行，則 <code>step == 3</code>。</p><table><thead><tr><th>Algorithm</th><th align="center">Step</th><th align="center">Big O notation</th></tr></thead><tbody><tr><td>for 迴圈</td><td align="center">n</td><td align="center">O(n)</td></tr><tr><td>梯形公式</td><td align="center">3</td><td align="center">O(1)</td></tr></tbody></table><p>隨著資料量的變大， for 迴圈需要花費的時間越來越長，而梯形公式則可以維持同樣的計算時間。因此我們可以說，在計算等差數列相加時，梯形公式是一個較好的演算法。  </p><p>當我們想優化演算法時，就要盡可能地將 Big O notation 降低，以達到更好的效率。  </p>]]></content>
      
      
      <categories>
          
          <category> CS50 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS50x </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS50x(2022)】ProblemSet3 - Tideman 題解(Selection sort)</title>
      <link href="/posts/d7ed27d2/"/>
      <url>/posts/d7ed27d2/</url>
      
        <content type="html"><![CDATA[<p>這是目前在 CS50x 課程中遇到的最難的題目了，如果不把思考邏輯好好整理一遍，下次再回顧應該還是要花很多時間理解一遍。  </p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這一篇是使用 Selection sort 方式解題，如果想使用其他排序法，可直接使用以下連結，除了排序法之外的內文都是一樣的。  </p><blockquote><p><a href="../ab8ef72d">Tideman 題解(Bubble sort)</a>。</p></blockquote><h2 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h2><p>題目出自 Harvard CS50x 課程第三週作業練習，可先看看<a href="https://cs50.harvard.edu/x/2022/psets/3/tideman/">題目說明</a>再往下看。  </p><p>在一般的選舉活動中，通常是採取<strong>相對多數決</strong>或是<strong>絕對多數決</strong>，也就是候選人只要得到一定數目選票即可獲得勝利。然而 <a href="https://en.wikipedia.org/wiki/Ranked_pairs"><strong>Tideman method</strong></a> 是採用完全不同的邏輯。Tideman method 或稱 Ranked pairs 是指在每一張選票上寫上對所有候選人的意向排序，把所有選票上的候選人兩兩互相比較得出一個符合多數人的排序結果，而排名第一的人就是最後的獲勝者。  </p><p>目前這樣簡單的介紹可能還有點抽象，接下來或做個詳細的說明。  </p><h2 id="程式結構及邏輯"><a href="#程式結構及邏輯" class="headerlink" title="程式結構及邏輯"></a>程式結構及邏輯</h2><p>先來看看題目提供的邏輯架構：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 定義候選人數目為 9 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 9</span><br><br><span class="hljs-comment">// 一個 9x9 的表格，每一格紀錄選票排序上，候選人[i] &gt; 候選人[j]的選票有幾張。</span><br><span class="hljs-type">int</span> preferences[MAX][MAX];<br><br><span class="hljs-comment">// 一個 9x9 的表格，每一格紀錄 boolean 值，說明候選人[i]和候選人[j]之間的箭頭關係是否被鎖定。</span><br><span class="hljs-type">bool</span> locked[MAX][MAX];<br><br><span class="hljs-comment">// 定義新的資料型別 &quot;pair&quot;，這個型別會記錄 winner 和 loser 在 array 裡的 index(integer)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> winner;<br>    <span class="hljs-type">int</span> loser;<br>&#125;<br><span class="hljs-built_in">pair</span>;<br><br><span class="hljs-comment">// Array of candidates</span><br><span class="hljs-built_in">string</span> candidates[MAX];             <span class="hljs-comment">// 一個紀錄所有候選人的 array</span><br><span class="hljs-built_in">pair</span> pairs[MAX * (MAX - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];    <span class="hljs-comment">// 一個紀錄所有 pair 的 array</span><br><br><span class="hljs-type">int</span> pair_count;<br><span class="hljs-type">int</span> candidate_count;<br><br><span class="hljs-comment">// Function prototypes</span><br><span class="hljs-comment">// 作業需要完成的 6 個 function</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">vote</span><span class="hljs-params">(<span class="hljs-type">int</span> rank, <span class="hljs-built_in">string</span> name, <span class="hljs-type">int</span> ranks[])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">record_preferences</span><span class="hljs-params">(<span class="hljs-type">int</span> ranks[])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">add_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sort_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_winner</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-built_in">string</span> argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 確認 terminal 提供的參數是否正確</span><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: tideman [candidate ...]\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 把 terminal 提供的候選人名字寫進 candidates 列表裡</span><br>    candidate_count = argc - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (candidate_count &gt; MAX)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Maximum number of candidates is %i\n&quot;</span>, MAX);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        candidates[i] = argv[i + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 locked 表格，讓每一格都是 false </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            locked[i][j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    pair_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> voter_count = get_int(<span class="hljs-string">&quot;Number of voters: &quot;</span>);<br><br>    <span class="hljs-comment">// 取得每一張選票內容</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; voter_count; i++)<br>    &#123;<br>        <span class="hljs-comment">// 定義選票排序 array: ranks[i] 是投票者排序第 i 名的候選人 index</span><br>        <span class="hljs-type">int</span> ranks[candidate_count];<br><br>        <span class="hljs-comment">// 取得每一個排序的候選人 index</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            <span class="hljs-built_in">string</span> name = get_string(<span class="hljs-string">&quot;Rank %i: &quot;</span>, j + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (!vote(j, name, ranks))<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid vote.\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 將選票結果更新到 preferences 表格</span><br>        record_preferences(ranks);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    add_pairs();<br>    sort_pairs();<br>    lock_pairs();<br>    print_winner();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>題目要求完成 6 個 function 來執行投票&#x2F;開票作業，接下來會針對每個 function 做詳細說明。  </p><h2 id="vote"><a href="#vote" class="headerlink" title="vote"></a>vote</h2><p>投票者每在選票上填入一個名字就會執行一次，將填入的名字放進紀錄選票的陣列 <code>ranks[]</code> 中。這個函式共引入了 3 個參數：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">vote</span><span class="hljs-params">(<span class="hljs-type">int</span> rank, <span class="hljs-built_in">string</span> name, <span class="hljs-type">int</span> ranks[])</span><br><span class="hljs-type">int</span> rank        <span class="hljs-comment">// 目前填入的名字在選票排序的第幾位</span><br><span class="hljs-built_in">string</span> name     <span class="hljs-comment">// 填入的名稱</span><br><span class="hljs-type">int</span> ranks[]     <span class="hljs-comment">// 記錄這張選票所有排序的 array</span><br></code></pre></td></tr></table></figure><p>首先，為了排除廢票狀況，要先檢查填入的名字是否存在候選人清單中，如果存在則填入 ranks[] 清單並回傳 <code>true</code>；反之則回傳 <code>false</code>。這邊用到一個 library： <a href="https://manual.cs50.io/3/strcmp">strcmp()</a> 來比對字串是否相同，所以要記得在檔案最上方加入 <code>#include &lt;string.h&gt;</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Update ranks given a new vote</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">vote</span><span class="hljs-params">(<span class="hljs-type">int</span> rank, <span class="hljs-built_in">string</span> name, <span class="hljs-type">int</span> ranks[])</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-comment">// Check if vote to person in candidates list</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(name, candidates[i]) == <span class="hljs-number">0</span>)<br>        &#123;<br>            ranks[rank] = i;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="record-preferences"><a href="#record-preferences" class="headerlink" title="record_preferences"></a>record_preferences</h2><p>每填完一張選票，就將這張選票每兩位候選人間的意願關係填入 <code>preferences</code> 表格中。這邊就要先解釋<a href="#%E7%A8%8B%E5%BC%8F%E7%B5%90%E6%A7%8B%E5%8F%8A%E9%82%8F%E8%BC%AF">原始題目line8</a> 的變數 <code>int preferences[MAX][MAX]</code> 了。<code>int</code> 代表這個陣列填入的資料型別是<strong>整數</strong>，後面的 <code>[MAX]</code> 則是代表表格的<strong>列數</strong>和<strong>欄數</strong>，而 MAX 的值在 line5 設定為 9。</p><h3 id="preferences-row-col-二維表格"><a href="#preferences-row-col-二維表格" class="headerlink" title="preferences[row][col] 二維表格"></a>preferences[row][col] 二維表格</h3><p><code>preferences[row][col]</code> 是一個二維陣列，假設 <code>[row]</code> 和 <code>[col]</code> 都是 3 ，表格畫起來如下圖：  </p><div style="max-width: fit-content"><table><thead><tr><th>candidates[index]</th><th align="center">Alice [0]</th><th align="center">Bob [1]</th><th align="center">Charlie [2]</th></tr></thead><tbody><tr><td>Alice [0]</td><td align="center">0</td><td align="center">Alice &gt; Bob 的選票張數</td><td align="center">Alice &gt; Charlie 的選票張數</td></tr><tr><td>Bob [1]</td><td align="center">Bob &gt; Alice 的選票張數</td><td align="center">0</td><td align="center">Bob &gt; Charlie 的選票張數</td></tr><tr><td>Charlie [2]</td><td align="center">Charlie &gt; Alice 的選票張數</td><td align="center">Charlie &gt; Bob 的選票張數</td><td align="center">0</td></tr></tbody></table></div><h3 id="選票意向解讀"><a href="#選票意向解讀" class="headerlink" title="選票意向解讀"></a>選票意向解讀</h3><table><thead><tr><th>選票</th><th>說明(比對上圖)</th></tr></thead><tbody><tr><td>1. Alice<br>2. Charlie<br>3. Bob</td><td>1. Alice 贏過 Bob 和 Charlie，所以 preferences[0][1] 和 preferences[0][2] 各加 1<br>2. Charlie 贏過 Bob，所以 preferences[2][1] 加 1。<br>3. Bob 沒贏過任何人，不對表格做任何改變。</td></tr></tbody></table><hr><p>來看看函式的 prototype：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">record_preferences</span><span class="hljs-params">(<span class="hljs-type">int</span> ranks[])</span><br><span class="hljs-type">void</span>         <span class="hljs-comment">// 沒有回傳值</span><br><span class="hljs-type">int</span> ranks[]  <span class="hljs-comment">// 使用 candidates[] 的 index 來紀錄選票中候選人排序的陣列</span><br></code></pre></td></tr></table></figure><p>如同上面舉的例子，當完成一張選票 <code>ranks[]</code> 時，依序迭代每個順位的候選人，將他們的比較結果填入 <code> preferences</code> 表格中。<code>i</code> 代表選票的第 i 順位，<code>j</code> 則代表 i 以外的其他候選人。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Update preferences given one voter&#x27;s ranks</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">record_preferences</span><span class="hljs-params">(<span class="hljs-type">int</span> ranks[])</span><br>&#123;<br>    <span class="hljs-comment">// Person of each rank on ballot</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            <span class="hljs-comment">// Plus number of voters who prefer i over j</span><br>            preferences[ranks[i]][ranks[j]] += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="add-pairs"><a href="#add-pairs" class="headerlink" title="add_pairs"></a>add_pairs</h2><p>在投完所有票及更新 <code>preferences</code> 表格後，從表格中挑出所有獲勝的組合。假設投完票後的意向表格如下：  </p><div style="max-width: fit-content"><table><thead><tr><th>candidates[index]</th><th align="center">Alice [0]</th><th align="center">Bob [1]</th><th align="center">Charlie [2]</th></tr></thead><tbody><tr><td>Alice [0]</td><td align="center">0</td><td align="center">3</td><td align="center">1</td></tr><tr><td>Bob [1]</td><td align="center">1</td><td align="center">0</td><td align="center">2</td></tr><tr><td>Charlie [2]</td><td align="center">3</td><td align="center">2</td><td align="center">0</td></tr></tbody></table></div><p>交叉比對確認兩候選人間的勝敗後，將候選人 <code>index</code> 記錄進 line23 <code>pairs</code> 陣列裡。前面有定義過 (line14-19)， <code>pair</code> 這個型別的陣列裡面會記錄 winner 跟 loser 的 index(要注意先後順序)。<a href="#%E7%A8%8B%E5%BC%8F%E7%B5%90%E6%A7%8B%E5%8F%8A%E9%82%8F%E8%BC%AF"><em>原始題目(行號)</em></a>  </p><p>依照上表範例：  </p><ul><li>Alice 對 Bob 的票數 preferences[0][1] &gt; preferences[1][0]，所以將 <code>&#123;0, 1&#125;</code> 放入 <code>pairs</code> 陣列。  </li><li>Alice 對 Charlie 的票數 preferences[0][2] &lt; preferences[2][0]，所以將 <code>&#123;2, 0&#125;</code> 放入 <code>pairs</code> 陣列。  </li><li>Bob 對 Charlie 的票數 preferences[1][2] &#x3D;&#x3D; preferences[2][1]，沒有勝者，所以不加入 <code>pairs</code>。</li></ul><hr><p>綜上所述， <code>add_pairs</code> 函式只要迭代整個表格找出勝者加入 <code>pairs</code> 即可。特別注意的是，因為我們只要找出勝者，所以不對 <code>if (preferences[i][j] == preferences[j][i])</code> 的情況做任何處理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Record pairs of candidates where one is preferred over the other</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">add_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            <span class="hljs-comment">// If one way arrow (i over j)</span><br>            <span class="hljs-keyword">if</span> (preferences[i][j] &gt; preferences[j][i])<br>            &#123;<br>                pairs[pair_count].winner = i;<br>                pairs[pair_count].loser = j;<br>                pair_count++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sort-pairs-Bubble-sort"><a href="#sort-pairs-Bubble-sort" class="headerlink" title="sort_pairs (Bubble sort)"></a>sort_pairs (Bubble sort)</h2><p>Bubble sort 的原理是和相鄰的項目做比較，並和相鄰項目交換位置，直到完成升冪或降冪的排序。舉例說明，有一個陣列 array[5] &#x3D; {2, 4, 5, 3, 1}，如果我要把它由小到大排序：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 原始陣列</span><br><span class="hljs-built_in">array</span>[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-comment">// Step1: index[0] 跟 index[1] 比較，若遇到較小的就交換位置</span><br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125; <br><br><span class="hljs-comment">// Step2: index[1] 跟 index[2] 比較，若遇到較小的就交換位置</span><br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">// Step3: index[2] 跟 index[3] 比較，若遇到較小的就交換位置</span><br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">// Step4: index[3] 跟 index[4] 比較，若遇到較小的就交換位置</span><br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">// 重複 step1~4 直到排序完成</span><br></code></pre></td></tr></table></figure><p>會看到較大的數字會像泡泡一樣逐漸向右浮出。  </p><hr><p>題目要求將 <code>pairs</code> 陣列由大到小排列。比大小需要<strong>數值</strong>，但 <code>pairs</code> 陣列紀錄的只是勝者和敗者，我們可以拿獲勝的<strong>力度</strong>來為每對候選人作排序。  </p><p>獲勝的<strong>力度</strong>指的是「<strong>覺得A候選人勝過B候選人的票數</strong>」。舉前面 <a href="#add_pairs">add_pairs範例表格</a>來說， Alice 勝過 Bob 的力度是 3。</p><p>接著，就如同 bubble sort 說明一樣，取出 <code>pairs</code> 陣列中相鄰的 <code>pair strength</code> (preferences[winner][loser])進行比較並互相交換，最後完成降冪排列。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sort_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pair_count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>        &#123;<br>            <span class="hljs-type">int</span> current_pair_strength = preferences[pairs[j].winner][pairs[j].loser];<br>            <span class="hljs-type">int</span> next_pair_strength = preferences[pairs[j + <span class="hljs-number">1</span>].winner][pairs[j + <span class="hljs-number">1</span>].loser];<br>            <span class="hljs-keyword">if</span> (current_pair_strength &lt; next_pair_strength)<br>            &#123;<br>                <span class="hljs-built_in">pair</span> temp = pairs[j];<br>                pairs[j] = pairs[j + <span class="hljs-number">1</span>];<br>                pairs[j + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lock-pairs"><a href="#lock-pairs" class="headerlink" title="lock_pairs"></a>lock_pairs</h2><p>這個步驟的目的是為了在所有的 pairs 之間做取捨。如果直接採用所有的 pair，選舉結果可能會出現:<br>A &gt; B 、 B &gt; C 、 C &gt; A 這種找不到最終勝利者的情形。而 lock_pairs 是將 pair_strength 由大到小分別做檢查，如果沒有變成死循環的 pair 就採用(lock)，變成死循環的 pair 就棄用。<br><br></p><blockquote><p>備註：此部分說明參考【<a href="https://gist.github.com/nicknapoli82/6c5a1706489e70342e9a0a635ae738c9">nicknapoli82&#x2F;cs50_Tideman_cycle-explanation.md</a>】  </p></blockquote><p>舉例來說，現在有的候選人和 sorted pairs 資料如下:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Candidates[<span class="hljs-number">4</span>] = [a, b, c, d]<br>Sorted Pairs = [&#123;d, a&#125;, &#123;a, b&#125;, &#123;b, c&#125;, &#123;c, a&#125;, &#123;d, b&#125;, &#123;d, c&#125;]<br></code></pre></td></tr></table></figure><p>之後將 sorted pairs 依序拿出來做檢查，如果不是死循環則生成排序鏈。<br><code>sorted pairs[0]</code> : d &gt; a ，lock ，排序鏈 <code>d &gt; a</code> 。<br><code>sorted pairs[1]</code> : a &gt; b ，lock ，排序鏈 <code>d &gt; a &gt; b</code> 。<br><code>sorted pairs[2]</code> : b &gt; c ，lock ，排序鏈 <code>d &gt; a &gt; b &gt; c</code> 。<br><code>sorted pairs[3]</code> : c &gt; a ，形成死循環，棄用此 pair，排序鏈維持 <code>d &gt; a &gt; b &gt; c</code> 。<br><code>sorted pairs[4]</code> : d &gt; b ，lock ，排序鏈維持 <code>d &gt; a &gt; b &gt; c</code> 。<br><code>sorted pairs[5]</code> : d &gt; c ，lock ，排序鏈維持 <code>d &gt; a &gt; b &gt; c</code> 。  </p><p>此時，詳細排序鏈應該長這樣：  </p><div style="max-width: 150px"><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">a</th></tr></thead><tbody><tr><td align="center"></td><td align="center">↗</td><td align="center">↓</td></tr><tr><td align="center">d</td><td align="center">→</td><td align="center">b</td></tr><tr><td align="center"></td><td align="center">↘</td><td align="center">↓</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">c</td></tr></tbody></table></div><p>最後寫出的 locked[4][4] 表格如下，有單向箭頭的為 true：  </p><div style="max-width: fit-content"><table><thead><tr><th>candidate[index]</th><th>a [0]</th><th>b [1]</th><th>c [2]</th><th>d [3]</th></tr></thead><tbody><tr><td>a [0]</td><td>false</td><td>true</td><td>true</td><td>false</td></tr><tr><td>b [1]</td><td>false</td><td>false</td><td>true</td><td>false</td></tr><tr><td>c [2]</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>d [3]</td><td>true</td><td>true</td><td>true</td><td>false</td></tr></tbody></table></div><hr><p>依照上面的說明，<code>lock_pairs</code> function 的邏輯為：檢查是否有死循環，沒有則為 true。(前面已將整張表格預設為 false，所以如果 <code>locked[winner][loser] = false</code> ，不做任何處理。)  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Lock pairs into the candidate graph in order, without creating cycles</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pair_count; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> winner = pairs[i].winner;<br>        <span class="hljs-type">int</span> loser = pairs[i].loser;<br><br>        <span class="hljs-keyword">if</span> (!cycle_occurred(winner, loser))<br>        &#123;<br>            locked[winner][loser] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>接下來則是規畫檢查死循環的步驟，新建一個 function <code>cycle_occurred</code>。  </p><p>因為我們是依照 pair_strength 的順序來鎖定的，所以檢查的方式就是把 winner 和 loser 反過來查表，看看會不會和目前已經鎖定的 pairs 形成死循環，如果 <code>locked[loser][winner] == true</code> 就表示造成死循環。  </p><p>另外，前面有提到排序鏈長這樣 <code>d &gt; a &gt; b &gt; c</code> ，但其實它包含了 <code>d &gt; a</code> 、 <code>d &gt; b</code>、 <code>d &gt; c</code> 這三個路線，如下圖:  </p><div style="max-width: 150px"><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">a</th></tr></thead><tbody><tr><td align="center"></td><td align="center">↗</td><td align="center">↓</td></tr><tr><td align="center">d</td><td align="center">→</td><td align="center">b</td></tr><tr><td align="center"></td><td align="center">↘</td><td align="center">↓</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">c</td></tr></tbody></table></div><p>如果我要確定 <code>d &gt; c</code> 會不會造成死循環，同時也必須要對其他路線做確認，所以使用 for loop 來迭代每個候選人。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Check if cycle occurred</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">cycle_occurred</span><span class="hljs-params">(<span class="hljs-type">int</span> winner, <span class="hljs-type">int</span> loser)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (locked[loser][winner] == <span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (locked[loser][i] &amp;&amp; cycle_occurred(winner, i))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="print-winner"><a href="#print-winner" class="headerlink" title="print_winner"></a>print_winner</h2><p>在完成 <code>lock_pairs</code> 經過步驟後，會完成下面這張表格。要找出最後贏家的辦法，就是確認一個候選人「沒有輸給任何人」，也就是候選人的 loser column 全部為 false，如下表<font color=green><strong>綠字</strong></font>表示：  </p><div style="max-width: fit-content"><table><thead><tr><th>candidate[index]</th><th>a [0]</th><th>b [1]</th><th>c [2]</th><th>d [3]</th></tr></thead><tbody><tr><td>a [0]</td><td>false</td><td>true</td><td>true</td><td><font color=green><strong>false</strong></font></td></tr><tr><td>b [1]</td><td>false</td><td>false</td><td>true</td><td><font color=green><strong>false</strong></font></td></tr><tr><td>c [2]</td><td>false</td><td>false</td><td>false</td><td><font color=green><strong>false</strong></font></td></tr><tr><td>d [3]</td><td>true</td><td>true</td><td>true</td><td><font color=green><strong>false</strong></font></td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Print the winner of the election</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_winner</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> false_count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            <span class="hljs-comment">// Check if candidates[j] has arrow to cadidates[i]</span><br>            <span class="hljs-keyword">if</span> (locked[j][i] == <span class="hljs-literal">false</span>)<br>            &#123;<br>                false_count++;<br><br>                <span class="hljs-comment">// if no arrow to candidates[i], find winner</span><br>                <span class="hljs-keyword">if</span> (false_count == candidate_count)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, candidates[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而為什麼不用「贏過除了自己的任何人呢」(也就是 candidate[i] row 除了自己全部為 true)？<br>因為我們在一開始就將表格預設為 false ，而<strong>平手</strong>情況也是 false 。向下圖這種情況，會有兩個贏家，而 <code>a &gt; d</code> 或 <code>d &gt; a</code> 都會是 false。</p><div style="max-width: 150px"><table><thead><tr><th align="center">a</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">||</td><td align="center">↘</td><td align="center"></td></tr><tr><td align="center">d</td><td align="center">→</td><td align="center">b</td></tr><tr><td align="center"></td><td align="center">↘</td><td align="center">↓</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">c</td></tr></tbody></table></div><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>完成版的 code 在<a href="https://gist.github.com/ritachien/513c3f9ba938d559b4e4c106a8cb91cf">這裡</a>。  </p><p>這個題目是目前課程作業中最難的一個，光題目的理解就花了很多時間也閱讀很了多資料(遞迴之類的…)，但挑戰不同排序法還是很有趣。在寫這篇題解的過程中也嘗試了不同寫法，發現導致沒有 100% pass 的例外狀況(平手)。整體來說，這是個很考驗邏輯思考的作業!  </p><blockquote><p>相關文章: <a href="https://ritachien.github.io/tags/CS50x-2022/">CS50x(2022)</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CS50 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS50x </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS50x(2022)】ProblemSet3 - Tideman 題解(Bubble sort)</title>
      <link href="/posts/ab8ef72d/"/>
      <url>/posts/ab8ef72d/</url>
      
        <content type="html"><![CDATA[<p>這是目前在 CS50x 課程中遇到的最難的題目了，如果不把思考邏輯好好整理一遍，下次再回顧應該還是要花很多時間理解一遍。  </p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這一篇是使用 bubble sort 方式解題，如果想使用其他排序法，可直接使用以下連結，除了排序法之外的內文都是一樣的。  </p><blockquote><p><a href="../d7ed27d2">Tideman 題解(Selection sort)</a>。</p></blockquote><h2 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h2><p>題目出自 Harvard CS50x 課程第三週作業練習，可先看看<a href="https://cs50.harvard.edu/x/2022/psets/3/tideman/">題目說明</a>再往下看。  </p><p>在一般的選舉活動中，通常是採取<strong>相對多數決</strong>或是<strong>絕對多數決</strong>，也就是候選人只要得到一定數目選票即可獲得勝利。然而 <a href="https://en.wikipedia.org/wiki/Ranked_pairs"><strong>Tideman method</strong></a> 是採用完全不同的邏輯。Tideman method 或稱 Ranked pairs 是指在每一張選票上寫上對所有候選人的意向排序，把所有選票上的候選人兩兩互相比較得出一個符合多數人的排序結果，而排名第一的人就是最後的獲勝者。  </p><p>目前這樣簡單的介紹可能還有點抽象，接下來或做個詳細的說明。  </p><h2 id="程式結構及邏輯"><a href="#程式結構及邏輯" class="headerlink" title="程式結構及邏輯"></a>程式結構及邏輯</h2><p>先來看看題目提供的邏輯架構：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 定義候選人數目為 9 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 9</span><br><br><span class="hljs-comment">// 一個 9x9 的表格，每一格紀錄選票排序上，候選人[i] &gt; 候選人[j]的選票有幾張。</span><br><span class="hljs-type">int</span> preferences[MAX][MAX];<br><br><span class="hljs-comment">// 一個 9x9 的表格，每一格紀錄 boolean 值，說明候選人[i]和候選人[j]之間的箭頭關係是否被鎖定。</span><br><span class="hljs-type">bool</span> locked[MAX][MAX];<br><br><span class="hljs-comment">// 定義新的資料型別 &quot;pair&quot;，這個型別會記錄 winner 和 loser 在 array 裡的 index(integer)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">int</span> winner;<br>  <span class="hljs-type">int</span> loser;<br>&#125;<br><span class="hljs-built_in">pair</span>;<br><br><span class="hljs-comment">// Array of candidates</span><br><span class="hljs-built_in">string</span> candidates[MAX];             <span class="hljs-comment">// 一個紀錄所有候選人的 array</span><br><span class="hljs-built_in">pair</span> pairs[MAX * (MAX - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];    <span class="hljs-comment">// 一個紀錄所有 pair 的 array</span><br><br><span class="hljs-type">int</span> pair_count;<br><span class="hljs-type">int</span> candidate_count;<br><br><span class="hljs-comment">// Function prototypes</span><br><span class="hljs-comment">// 作業需要完成的 6 個 function</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">vote</span><span class="hljs-params">(<span class="hljs-type">int</span> rank, <span class="hljs-built_in">string</span> name, <span class="hljs-type">int</span> ranks[])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">record_preferences</span><span class="hljs-params">(<span class="hljs-type">int</span> ranks[])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">add_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sort_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_winner</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-built_in">string</span> argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 確認 terminal 提供的參數是否正確</span><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: tideman [candidate ...]\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 把 terminal 提供的候選人名字寫進 candidates 列表裡</span><br>    candidate_count = argc - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (candidate_count &gt; MAX)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Maximum number of candidates is %i\n&quot;</span>, MAX);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        candidates[i] = argv[i + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 locked 表格，讓每一格都是 false </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            locked[i][j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    pair_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> voter_count = get_int(<span class="hljs-string">&quot;Number of voters: &quot;</span>);<br><br>    <span class="hljs-comment">// 取得每一張選票內容</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; voter_count; i++)<br>    &#123;<br>        <span class="hljs-comment">// 定義選票排序 array: ranks[i] 是投票者排序第 i 名的候選人 index</span><br>        <span class="hljs-type">int</span> ranks[candidate_count];<br><br>        <span class="hljs-comment">// 取得每一個排序的候選人 index</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            <span class="hljs-built_in">string</span> name = get_string(<span class="hljs-string">&quot;Rank %i: &quot;</span>, j + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (!vote(j, name, ranks))<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid vote.\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 將選票結果更新到 preferences 表格</span><br>        record_preferences(ranks);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    add_pairs();<br>    sort_pairs();<br>    lock_pairs();<br>    print_winner();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>題目要求完成 6 個 function 來執行投票&#x2F;開票作業，接下來會針對每個 function 做詳細說明。  </p><h2 id="vote"><a href="#vote" class="headerlink" title="vote"></a>vote</h2><p>投票者每在選票上填入一個名字就會執行一次，將填入的名字放進紀錄選票的陣列 <code>ranks[]</code> 中。這個函式共引入了 3 個參數：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">vote</span><span class="hljs-params">(<span class="hljs-type">int</span> rank, <span class="hljs-built_in">string</span> name, <span class="hljs-type">int</span> ranks[])</span><br><span class="hljs-type">int</span> rank        <span class="hljs-comment">// 目前填入的名字在選票排序的第幾位</span><br><span class="hljs-built_in">string</span> name     <span class="hljs-comment">// 填入的名稱</span><br><span class="hljs-type">int</span> ranks[]     <span class="hljs-comment">// 記錄這張選票所有排序的 array</span><br></code></pre></td></tr></table></figure><p>首先，為了排除廢票狀況，要先檢查填入的名字是否存在候選人清單中，如果存在則填入 ranks[] 清單並回傳 <code>true</code>；反之則回傳 <code>false</code>。這邊用到一個 library： <a href="https://manual.cs50.io/3/strcmp">strcmp()</a> 來比對字串是否相同，所以要記得在檔案最上方加入 <code>#include &lt;string.h&gt;</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Update ranks given a new vote</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">vote</span><span class="hljs-params">(<span class="hljs-type">int</span> rank, <span class="hljs-built_in">string</span> name, <span class="hljs-type">int</span> ranks[])</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-comment">// Check if vote to person in candidates list</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(name, candidates[i]) == <span class="hljs-number">0</span>)<br>        &#123;<br>            ranks[rank] = i;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="record-preferences"><a href="#record-preferences" class="headerlink" title="record_preferences"></a>record_preferences</h2><p>每填完一張選票，就將這張選票每兩位候選人間的意願關係填入 <code>preferences</code> 表格中。這邊就要先解釋<a href="#%E7%A8%8B%E5%BC%8F%E7%B5%90%E6%A7%8B%E5%8F%8A%E9%82%8F%E8%BC%AF">原始題目line8</a> 的變數 <code>int preferences[MAX][MAX]</code> 了。<code>int</code> 代表這個陣列填入的資料型別是<strong>整數</strong>，後面的 <code>[MAX]</code> 則是代表表格的<strong>列數</strong>和<strong>欄數</strong>，而 MAX 的值在 line5 設定為 9。</p><h3 id="preferences-row-col-二維表格"><a href="#preferences-row-col-二維表格" class="headerlink" title="preferences[row][col] 二維表格"></a>preferences[row][col] 二維表格</h3><p><code>preferences[row][col]</code> 是一個二維陣列，假設 <code>[row]</code> 和 <code>[col]</code> 都是 3 ，表格畫起來如下圖：  </p><div style="max-width: fit-content"><table><thead><tr><th>candidates[index]</th><th align="center">Alice [0]</th><th align="center">Bob [1]</th><th align="center">Charlie [2]</th></tr></thead><tbody><tr><td>Alice [0]</td><td align="center">0</td><td align="center">Alice &gt; Bob 的選票張數</td><td align="center">Alice &gt; Charlie 的選票張數</td></tr><tr><td>Bob [1]</td><td align="center">Bob &gt; Alice 的選票張數</td><td align="center">0</td><td align="center">Bob &gt; Charlie 的選票張數</td></tr><tr><td>Charlie [2]</td><td align="center">Charlie &gt; Alice 的選票張數</td><td align="center">Charlie &gt; Bob 的選票張數</td><td align="center">0</td></tr></tbody></table></div><h3 id="選票意向解讀"><a href="#選票意向解讀" class="headerlink" title="選票意向解讀"></a>選票意向解讀</h3><table><thead><tr><th>選票</th><th>說明(比對上圖)</th></tr></thead><tbody><tr><td>1. Alice<br>2. Charlie<br>3. Bob</td><td>1. Alice 贏過 Bob 和 Charlie，所以 preferences[0][1] 和 preferences[0][2] 各加 1<br>2. Charlie 贏過 Bob，所以 preferences[2][1] 加 1。<br>3. Bob 沒贏過任何人，不對表格做任何改變。</td></tr></tbody></table><hr><p>來看看函式的 prototype：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">record_preferences</span><span class="hljs-params">(<span class="hljs-type">int</span> ranks[])</span><br><span class="hljs-type">void</span>         <span class="hljs-comment">// 沒有回傳值</span><br><span class="hljs-type">int</span> ranks[]  <span class="hljs-comment">// 使用 candidates[] 的 index 來紀錄選票中候選人排序的陣列</span><br></code></pre></td></tr></table></figure><p>如同上面舉的例子，當完成一張選票 <code>ranks[]</code> 時，依序迭代每個順位的候選人，將他們的比較結果填入 <code> preferences</code> 表格中。<code>i</code> 代表選票的第 i 順位，<code>j</code> 則代表 i 以外的其他候選人。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Update preferences given one voter&#x27;s ranks</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">record_preferences</span><span class="hljs-params">(<span class="hljs-type">int</span> ranks[])</span><br>&#123;<br>    <span class="hljs-comment">// Person of each rank on ballot</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            <span class="hljs-comment">// Plus number of voters who prefer i over j</span><br>            preferences[ranks[i]][ranks[j]] += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="add-pairs"><a href="#add-pairs" class="headerlink" title="add_pairs"></a>add_pairs</h2><p>在投完所有票及更新 <code>preferences</code> 表格後，從表格中挑出所有獲勝的組合。假設投完票後的意向表格如下：  </p><div style="max-width: fit-content"><table><thead><tr><th>candidates[index]</th><th align="center">Alice [0]</th><th align="center">Bob [1]</th><th align="center">Charlie [2]</th></tr></thead><tbody><tr><td>Alice [0]</td><td align="center">0</td><td align="center">3</td><td align="center">1</td></tr><tr><td>Bob [1]</td><td align="center">1</td><td align="center">0</td><td align="center">2</td></tr><tr><td>Charlie [2]</td><td align="center">3</td><td align="center">2</td><td align="center">0</td></tr></tbody></table></div><p>交叉比對確認兩候選人間的勝敗後，將候選人 <code>index</code> 記錄進 line23 <code>pairs</code> 陣列裡。前面有定義過 (line14-19)， <code>pair</code> 這個型別的陣列裡面會記錄 winner 跟 loser 的 index(要注意先後順序)。<a href="#%E7%A8%8B%E5%BC%8F%E7%B5%90%E6%A7%8B%E5%8F%8A%E9%82%8F%E8%BC%AF"><em>原始題目(行號)</em></a>  </p><p>依照上表範例：  </p><ul><li>Alice 對 Bob 的票數 preferences[0][1] &gt; preferences[1][0]，所以將 <code>&#123;0, 1&#125;</code> 放入 <code>pairs</code> 陣列。  </li><li>Alice 對 Charlie 的票數 preferences[0][2] &lt; preferences[2][0]，所以將 <code>&#123;2, 0&#125;</code> 放入 <code>pairs</code> 陣列。  </li><li>Bob 對 Charlie 的票數 preferences[1][2] &#x3D;&#x3D; preferences[2][1]，沒有勝者，所以不加入 <code>pairs</code>。</li></ul><hr><p>綜上所述， <code>add_pairs</code> 函式只要迭代整個表格找出勝者加入 <code>pairs</code> 即可。特別注意的是，因為我們只要找出勝者，所以不對 <code>if (preferences[i][j] == preferences[j][i])</code> 的情況做任何處理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Record pairs of candidates where one is preferred over the other</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">add_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            <span class="hljs-comment">// If one way arrow (i over j)</span><br>            <span class="hljs-keyword">if</span> (preferences[i][j] &gt; preferences[j][i])<br>            &#123;<br>                pairs[pair_count].winner = i;<br>                pairs[pair_count].loser = j;<br>                pair_count++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sort-pairs-Selection-sort"><a href="#sort-pairs-Selection-sort" class="headerlink" title="sort_pairs (Selection sort)"></a>sort_pairs (Selection sort)</h2><p>Selection sort 的原理是在遍歷剩餘需排序的資料，找到最大(或最小)的一項，然後和需排序資料中的第一個位置交換，最後達到生蜜或降冪的排列。</p><hr><p>題目要求將 <code>pairs</code> 陣列由大到小排列。比大小需要<strong>數值</strong>，但 <code>pairs</code> 陣列紀錄的只是勝者和敗者，我們可以拿獲勝的<strong>力度</strong>來為每對候選人作排序。  </p><p>獲勝的<strong>力度</strong>指的是「<strong>覺得A候選人勝過B候選人的票數</strong>」。舉前面 <a href="#add_pairs">add_pairs範例表格</a>來說， Alice 勝過 Bob 的力度是 3。</p><p>接著，就如同 selection sort 說明一樣，找出 <code>pairs</code> 陣列中最大的 <code>pair strength</code> (preferences[winner][loser])，並和剩餘資料的第一項交換位置，最後完成降冪排列。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sort_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// Selection sort</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pair_count; i++)<br>    &#123;<br>        <span class="hljs-comment">// Initialize compare bases to pairs[i]</span><br>        <span class="hljs-type">int</span> top_strength = preferences[pairs[i].winner][pairs[i].loser];<br>        <span class="hljs-type">int</span> top_index = i;<br><br>        <span class="hljs-comment">// Iterate the rest pairs to find top_strength one</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; pair_count; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (preferences[pairs[j].winner][pairs[j].loser] &gt; top_strength)<br>            &#123;<br>                <span class="hljs-comment">// Update compare bases</span><br>                top_strength = preferences[pairs[j].winner][pairs[j].loser];<br>                top_index = j;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Swap pairs[i] if find another one with higher strength</span><br>        <span class="hljs-keyword">if</span> (top_index != i)<br>        &#123;<br>            <span class="hljs-built_in">pair</span> temp = pairs[i];<br>            pairs[i] = pairs[top_index];<br>            pairs[top_index] = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lock-pairs"><a href="#lock-pairs" class="headerlink" title="lock_pairs"></a>lock_pairs</h2><p>這個步驟的目的是為了在所有的 pairs 之間做取捨。如果直接採用所有的 pair，選舉結果可能會出現:<br>A &gt; B 、 B &gt; C 、 C &gt; A 這種找不到最終勝利者的情形。而 lock_pairs 是將 pair_strength 由大到小分別做檢查，如果沒有變成死循環的 pair 就採用(lock)，變成死循環的 pair 就棄用。<br><br></p><blockquote><p>備註：此部分說明參考【<a href="https://gist.github.com/nicknapoli82/6c5a1706489e70342e9a0a635ae738c9">nicknapoli82&#x2F;cs50_Tideman_cycle-explanation.md</a>】  </p></blockquote><p>舉例來說，現在有的候選人和 sorted pairs 資料如下:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Candidates[<span class="hljs-number">4</span>] = [a, b, c, d]<br>Sorted Pairs = [&#123;d, a&#125;, &#123;a, b&#125;, &#123;b, c&#125;, &#123;c, a&#125;, &#123;d, b&#125;, &#123;d, c&#125;]<br></code></pre></td></tr></table></figure><p>之後將 sorted pairs 依序拿出來做檢查，如果不是死循環則生成排序鏈。<br><code>sorted pairs[0]</code> : d &gt; a ，lock ，排序鏈 <code>d &gt; a</code> 。<br><code>sorted pairs[1]</code> : a &gt; b ，lock ，排序鏈 <code>d &gt; a &gt; b</code> 。<br><code>sorted pairs[2]</code> : b &gt; c ，lock ，排序鏈 <code>d &gt; a &gt; b &gt; c</code> 。<br><code>sorted pairs[3]</code> : c &gt; a ，形成死循環，棄用此 pair，排序鏈維持 <code>d &gt; a &gt; b &gt; c</code> 。<br><code>sorted pairs[4]</code> : d &gt; b ，lock ，排序鏈維持 <code>d &gt; a &gt; b &gt; c</code> 。<br><code>sorted pairs[5]</code> : d &gt; c ，lock ，排序鏈維持 <code>d &gt; a &gt; b &gt; c</code> 。  </p><p>此時，詳細排序鏈應該長這樣：  </p><div style="max-width: 150px"><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">a</th></tr></thead><tbody><tr><td align="center"></td><td align="center">↗</td><td align="center">↓</td></tr><tr><td align="center">d</td><td align="center">→</td><td align="center">b</td></tr><tr><td align="center"></td><td align="center">↘</td><td align="center">↓</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">c</td></tr></tbody></table></div><p>最後寫出的 locked[4][4] 表格如下，有單向箭頭的為 true：  </p><div style="max-width: fit-content"><table><thead><tr><th>candidate[index]</th><th>a [0]</th><th>b [1]</th><th>c [2]</th><th>d [3]</th></tr></thead><tbody><tr><td>a [0]</td><td>false</td><td>true</td><td>true</td><td>false</td></tr><tr><td>b [1]</td><td>false</td><td>false</td><td>true</td><td>false</td></tr><tr><td>c [2]</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>d [3]</td><td>true</td><td>true</td><td>true</td><td>false</td></tr></tbody></table></div><hr><p>依照上面的說明，<code>lock_pairs</code> function 的邏輯為：檢查是否有死循環，沒有則為 true。(前面已將整張表格預設為 false，所以如果 <code>locked[winner][loser] = false</code> ，不做任何處理。)  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Lock pairs into the candidate graph in order, without creating cycles</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_pairs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pair_count; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> winner = pairs[i].winner;<br>        <span class="hljs-type">int</span> loser = pairs[i].loser;<br><br>        <span class="hljs-keyword">if</span> (!cycle_occurred(winner, loser))<br>        &#123;<br>            locked[winner][loser] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>接下來則是規畫檢查死循環的步驟，新建一個 function <code>cycle_occurred</code>。  </p><p>因為我們是依照 pair_strength 的順序來鎖定的，所以檢查的方式就是把 winner 和 loser 反過來查表，看看會不會和目前已經鎖定的 pairs 形成死循環，如果 <code>locked[loser][winner] == true</code> 就表示造成死循環。  </p><p>另外，前面有提到排序鏈長這樣 <code>d &gt; a &gt; b &gt; c</code> ，但其實它包含了 <code>d &gt; a</code> 、 <code>d &gt; b</code>、 <code>d &gt; c</code> 這三個路線，如下圖:  </p><div style="max-width: 150px"><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">a</th></tr></thead><tbody><tr><td align="center"></td><td align="center">↗</td><td align="center">↓</td></tr><tr><td align="center">d</td><td align="center">→</td><td align="center">b</td></tr><tr><td align="center"></td><td align="center">↘</td><td align="center">↓</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">c</td></tr></tbody></table></div><p>如果我要確定 <code>d &gt; c</code> 會不會造成死循環，同時也必須要對其他路線做確認，所以使用 for loop 來迭代每個候選人。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Check if cycle occurred</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">cycle_occurred</span><span class="hljs-params">(<span class="hljs-type">int</span> winner, <span class="hljs-type">int</span> loser)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (locked[loser][winner] == <span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (locked[loser][i] &amp;&amp; cycle_occurred(winner, i))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="print-winner"><a href="#print-winner" class="headerlink" title="print_winner"></a>print_winner</h2><p>在完成 <code>lock_pairs</code> 經過步驟後，會完成下面這張表格。要找出最後贏家的辦法，就是確認一個候選人「沒有輸給任何人」，也就是候選人的 loser column 全部為 false，如下表<font color=green><strong>綠字</strong></font>表示：  </p><div style="max-width: fit-content"><table><thead><tr><th>candidate[index]</th><th>a [0]</th><th>b [1]</th><th>c [2]</th><th>d [3]</th></tr></thead><tbody><tr><td>a [0]</td><td>false</td><td>true</td><td>true</td><td><font color=green><strong>false</strong></font></td></tr><tr><td>b [1]</td><td>false</td><td>false</td><td>true</td><td><font color=green><strong>false</strong></font></td></tr><tr><td>c [2]</td><td>false</td><td>false</td><td>false</td><td><font color=green><strong>false</strong></font></td></tr><tr><td>d [3]</td><td>true</td><td>true</td><td>true</td><td><font color=green><strong>false</strong></font></td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Print the winner of the election</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_winner</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate_count; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> false_count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; candidate_count; j++)<br>        &#123;<br>            <span class="hljs-comment">// Check if candidates[j] has arrow to cadidates[i]</span><br>            <span class="hljs-keyword">if</span> (locked[j][i] == <span class="hljs-literal">false</span>)<br>            &#123;<br>                false_count++;<br><br>                <span class="hljs-comment">// if no arrow to candidates[i], find winner</span><br>                <span class="hljs-keyword">if</span> (false_count == candidate_count)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, candidates[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而為什麼不用「贏過除了自己的任何人呢」(也就是 candidate[i] row 除了自己全部為 true)？<br>因為我們在一開始就將表格預設為 false ，而<strong>平手</strong>情況也是 false 。向下圖這種情況，會有兩個贏家，而 <code>a &gt; d</code> 或 <code>d &gt; a</code> 都會是 false。</p><div style="max-width: 150px"><table><thead><tr><th align="center">a</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">||</td><td align="center">↘</td><td align="center"></td></tr><tr><td align="center">d</td><td align="center">→</td><td align="center">b</td></tr><tr><td align="center"></td><td align="center">↘</td><td align="center">↓</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">c</td></tr></tbody></table></div><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>完成版的 code 在<a href="https://gist.github.com/ritachien/e7de2ceccc4b99b665cfe3bbe5336877">這裡</a>。  </p><blockquote></blockquote><p>這個題目是目前課程作業中最難的一個，光題目的理解就花了很多時間也閱讀很了多資料(遞迴之類的…)，但挑戰不同排序法還是很有趣。在寫這篇題解的過程中也嘗試了不同寫法，發現導致沒有 100% pass 的例外狀況(平手)。整體來說，這是個很考驗邏輯思考的作業!  </p><blockquote><p>相關文章: <a href="https://ritachien.github.io/tags/CS50x-2022/">CS50x(2022)</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CS50 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS50x </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS50x(2022)】 Week2 - Array</title>
      <link href="/posts/aabaf537/"/>
      <url>/posts/aabaf537/</url>
      
        <content type="html"><![CDATA[<p>這週提供了遇到 bug 時的解決方式，也深入講解了 main function 的使用。  </p><span id="more"></span><h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><ul><li>Compiling  </li><li>Debugging  </li><li>Memory  </li><li>Arrays  </li><li>Characters  </li><li>Strings  </li><li>Command-line arguments  </li><li>Applications</li></ul><h2 id="Debugging-methods"><a href="#Debugging-methods" class="headerlink" title="Debugging methods"></a>Debugging methods</h2><p>寫程式常常遇到一個讓人困擾的問題，就是運作起來跟想像中的不一樣。大家常說的 debug 或者說除錯，其實就是找出程式運作不如預期的原因，並且解決它的過程。用肉眼直接找出原因是很沒有效率的，畢竟就是覺得邏輯沒問題才會這樣寫並且很有自信地讓程式碼運行 😅  </p><p>講師介紹了 3 種課程中遇到 bug 可以使用的方法，除了 debug50 這個課程提供的工具外，其他兩種方法也是我在學習過程中很常使用的 debug 方式。  </p><h3 id="用-printf-呈現程式運作過程"><a href="#用-printf-呈現程式運作過程" class="headerlink" title="用 printf() 呈現程式運作過程"></a>用 <code>printf()</code> 呈現程式運作過程</h3><p><code>printf()</code> 是一個在 terminal 印出<code>()</code> 中內容的指令。在程式碼適當位置中加入，可以觀察程式碼運作細節，方便藉由觀察印出的「值」跟預想中的相不相符來確認發生錯誤的地方。  </p><p>例如：如果要在 terminal 印出3個 <code>#</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 程式碼內容</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;#\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 實際輸出結果</span><br>#<br>#<br>#<br>#<br></code></pre></td></tr></table></figure><p>這個時候就可以在迴圈內加一行 <code>printf()</code> 來檢查輸出的次數為什麼和預期的不一樣。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 程式碼內容</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;loop %i\n&quot;</span>, i);  <span class="hljs-comment">// 新增這一行檢查用的 printf()</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;#\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 實際輸出結果</span><br>loop <span class="hljs-number">0</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">loop 1</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">loop 2</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">loop 3</span><br>#<br></code></pre></td></tr></table></figure><p>這樣就可以看出 for loop 的迴圈檢查條件設置錯誤，只要將 <code>i &lt;= 3</code> 更正為 <code>i &lt; 3</code> 即可。  </p><p>這種方式也是我目前最常使用的 debug 方式。當運行結果和預期中不同時，藉由這種方式可以把一大段的程式碼分區塊進行測試，針對特定段落進行檢查，可以更精確地找到發生問題的原因並進行改正。  </p><h3 id="debug50-課程工具"><a href="#debug50-課程工具" class="headerlink" title="debug50(課程工具)"></a>debug50(課程工具)</h3><p>CS50 課程開發了線上的 codespace ，裡面已經進行了相關的環境設定、也提供了一些工具，讓註冊這門課的學生可以專注在學習課程內容上。 debug50 就是其中一個好用的工具，可以把程式運作的流程一步一步的呈現，在複雜一點的程式結構 debug 上會比 <code>printf()</code> 更方便一點。  </p><h3 id="Rubber-duck"><a href="#Rubber-duck" class="headerlink" title="Rubber duck"></a>Rubber duck</h3><p><a href="https://zh.wikipedia.org/zh-tw/%E5%B0%8F%E9%BB%84%E9%B8%AD%E8%B0%83%E8%AF%95%E6%B3%95">Rubber duck debugging</a> 是用書寫或是口說的方式，將整個流程一步一步的說出來。藉由這個「輸出」的過程來釐清每個步驟，進而找出發生錯誤的原因。  </p><p>Rubber duck 對我來說不僅僅用在 debug 上，通常在正式開始寫程式前，我就會先用 pseudocode 的方式規劃整個流程，除錯過程中比對原來的 pseodocode 來進行檢查。另外就是，「寫部落格」對我來說也是 Rubber duck 的應用，要進行「輸出」首先要先在腦中進行整理，之後才能用比較有條理的方式進行表達。  </p><h2 id="Characters"><a href="#Characters" class="headerlink" title="Characters"></a>Characters</h2><p>每一個 Character 在記憶體中是以 ASCII value 的形式紀錄的，這也讓 <code>char</code> 這個 data type 有很特別的應用方式。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> c1 = <span class="hljs-string">&#x27;H&#x27;</span>;<br>    <span class="hljs-type">char</span> c2 = <span class="hljs-string">&#x27;I&#x27;</span>;<br>    <span class="hljs-type">char</span> c3 = <span class="hljs-string">&#x27;!&#x27;</span>;<br>  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%c%c\n&quot;</span>, c1, c2, c3);<br>    <span class="hljs-comment">// output: HI!</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i %i %i\n&quot;</span>, c1, c2, c3);<br>    <span class="hljs-comment">// output: 72 73 33</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 week1 的 C 語言介紹課程供提到，使用 <code>printf()</code> 引用變數時，必須清楚定義變數的 data type 。在前面課程中覺得「沒必要」、「多此一舉」的動作，在這裡就體現出了這麼做的原因。  由於是以 ASCII value 來紀錄，因此 data type 的定義也就關係到了記憶體中 value 的解讀方式，進而能呈現出不同的結果。  </p><p>在大小寫的轉換中，也可以用很特別的寫法：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> word = <span class="hljs-string">&#x27;h&#x27;</span>;<br><br><span class="hljs-keyword">if</span> (word &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; word &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, word - <span class="hljs-number">32</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, word);<br>&#125;<br><span class="hljs-comment">// output: H</span><br></code></pre></td></tr></table></figure><p>看起來很奇怪，「文字」怎麼能進行「比大小」和「四則運算」？其實就是 ASCII value 在不同型別間的轉換而已。  </p><h2 id="Array-amp-String"><a href="#Array-amp-String" class="headerlink" title="Array &amp; String"></a>Array &amp; String</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>Array 是一種 data type ，它可以讓很多相同型別的變數值共用一個變數名稱，並且 array 裡面的值是有「順序性」的，這種方式可以使用較少的變數紀錄相同數量的值。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 用不同變數紀錄個別的值</span><br><span class="hljs-type">int</span> score1 = <span class="hljs-number">72</span>;<br><span class="hljs-type">int</span> score2 = <span class="hljs-number">73</span>;<br><span class="hljs-type">int</span> score3 = <span class="hljs-number">33</span>;<br><br><span class="hljs-comment">// 用 array 紀錄所有變數值</span><br><span class="hljs-type">int</span> score[] = &#123;<span class="hljs-number">72</span>, <span class="hljs-number">73</span>, <span class="hljs-number">33</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 不是 C 語言原生的 data type ，它是由 CS50 library 定義的，所以如果想使用 String ，就要在文件開頭引用 <code>&lt;CS50.h&gt;</code> 。  </p><p><em><strong>Strings are actually just arrays of characters</strong></em> —— CS50x<br>這也是為什麼可以用 array 方式來取 string 裡第 i 個字的原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;HI!&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %c %c\n&quot;</span>, s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>], s[<span class="hljs-number">2</span>]);<br><span class="hljs-comment">//  output: H I !</span><br></code></pre></td></tr></table></figure><p>每個 string 結尾會被加上 <code>null character</code>, or <code>NUL</code>, or <code>\0</code> ，用來表示字串的結束。這也是為什麼可以用下列方式來計算字串的長度。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;HI!&quot;</span>;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>&#123;<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Command-line-arguments-amp-Exit-status"><a href="#Command-line-arguments-amp-Exit-status" class="headerlink" title="Command-line arguments &amp; Exit status"></a>Command-line arguments &amp; Exit status</h2><p>這關係到 C 的主程式結構。在之前的課程介紹中，講者只說明主程式要寫在 <code>int main(void)&#123;&#125;</code> 裡面，卻沒有特別說明原因。其實，可以把主程式看成一個 function 。在 week1 有介紹過 function ，其結構是：<br><code>return_type function_name(Command-line arguments)&#123;&#125;</code> ，也就是我們最一開始看到的：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 主程式碼執行內容</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Command-line-arguments"><a href="#Command-line-arguments" class="headerlink" title="Command-line arguments"></a>Command-line arguments</h3><p>通常， main function 不需要引入任何參數就可以直接執行，所以我們直接使用 <code>void</code> 來表示。但既然是 funtion ，當然也有「引入參數」的使用方法，那就是直接在 Command-line 執行 <code>./file_name</code> 的時候直接放入參數。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-built_in">string</span> argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 主程式碼執行內容</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>argc</code> 代表的是「<strong>包含執行指令</strong>」的 arguments 的 length；而 <code>argv</code> 則是執行指令後設置的參數(其型別為 array of string)。  </p><p>也就是說，如果我在 terminal 執行以下指令：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./file ABC 123<br><span class="hljs-comment"># argv[] = &#123;./file, ABC, 123&#125;</span><br><span class="hljs-comment"># argc = 3</span><br></code></pre></td></tr></table></figure><p>此時，我就可以在我的 main function 中使用我在 terminal 輸入的參數。  </p><h3 id="exit-status"><a href="#exit-status" class="headerlink" title="exit status"></a>exit status</h3><p>嗯嗯？主程式有 return value ？？ 看看 <code>int main(void)&#123;&#125;</code> ……看起來 return value type 是 interger ，但是我們並沒有設定 return value 啊？  </p><p>其實， main function 預設會回傳 <code>0</code> 表示沒有任何錯誤發生；而我們可以設置不等於 <code>0</code> 的 return value 來表示錯誤情況發生。可以針對不同的錯誤狀況設置不同的 return value ，這也是我們在執行一些微軟或 Mac 程式，發生錯誤時看到的 error message number。  </p><p>來看看例子。假如我寫了一個 main function 需要使用者提供一個參數(name)，如果參數無誤會在 terminal 印出 <code>Hello, name</code>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-built_in">string</span> argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>)  <span class="hljs-comment">// 除執行指令外給了一個參數($./hello David)</span><br>    &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, %s\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">1</span>) <span class="hljs-comment">// 只輸入執行指令($./hello)</span><br>    &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;missing command-line argument\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 提供大於一個參數($./hello David Brian)</span><br>    &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;too many command-line argument\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>相較於前兩週，我花了較多的時間反覆觀看 lecture 影片，不但因為資訊量變大更需要時間吸收，也因為接觸更多沒碰過的「基礎」(像是資料在 memory 中的儲存方式及應用方法)。除了提升對 C 的理解外，也解決了一些我在學習 JavaScript 時的疑惑！  </p><blockquote><p>相關文章: <a href="https://ritachien.github.io/tags/CS50x-2022/">CS50x(2022)</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CS50 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS50x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS50x(2022)】 Week1 - C</title>
      <link href="/posts/100ec410/"/>
      <url>/posts/100ec410/</url>
      
        <content type="html"><![CDATA[<p>第一次接觸 C，發現不同程式語言的寫作邏輯其實還是差不多的，差別在於較古老的語言在「便利性」上比較沒有那麼人性化。  </p><span id="more"></span><h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><ul><li>C  </li><li>IDEs, compilers, interfaces  </li><li>Functions, arguments, return values, variables  </li><li>main, header files, commands  </li><li>Types, format codes, operators  </li><li>Variables, syntactic sugar  </li><li>Calculations  </li><li>Conditionals, Boolean expressions  </li><li>Loops, functions  </li><li>Mario  </li><li>Imprecision, overflow</li></ul><h2 id="用-C-學習程式寫作基礎"><a href="#用-C-學習程式寫作基礎" class="headerlink" title="用 C 學習程式寫作基礎"></a>用 C 學習程式寫作基礎</h2><p>本週開始接觸到新的語言 C。<br>上週用圖像化的 Scratch 來講解程式運作原理，這週承襲上週範例使用同樣的運作流程，只是改用 C 把它寫出來。  </p><p>C 是一個相對古老的語言，所以他在寫作方式上並不像較新的語言那樣簡潔。比如:</p><ol><li>請使用者輸入名字</li><li>在螢幕上印出 <code>Hello, 名字</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  用 JavaScript 寫</span><br>name = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Enter your name: &quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>)<br></code></pre></td></tr></table></figure><p>JavaScript 只用一個變數儲存使用者的輸入值，然後輸出時套用即可。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 用 C 寫</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">string</span> name = get_string(<span class="hljs-string">&quot;Enter your name: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, %s\n&quot;</span>, name);<br>&#125;<br></code></pre></td></tr></table></figure><p>用 C 寫就比較辛苦了，因為 C 必須要把每件事都寫得很清楚:  </p><ul><li>因為需要在螢幕上輸出內容，所以需要 <code>#include &lt;stdio.h&gt;</code>。  </li><li>要用到向使用者拿輸入內容的函式 <code>get_string</code>，所以需要 <code>#include &lt;cs50.h&gt;</code>。(這還是 CS50 的員工寫出來的 library ，不然可能更麻煩 😅)  </li><li>主程式內容需用 <code>int main(void)&#123;&#125;</code> 包覆。  </li><li>每個變數要在宣告時就定義好它的 data type。  </li><li>用 <code>%</code> 引用變數值，並要清楚定義這個值的 data type。</li></ul><p>因為先學了 JavaScript 才接觸到 C，所以寫作的過程相當不習慣、覺得很麻煩。但是在練習中不斷的除錯、除錯、再除錯，漸漸地發現這樣嚴謹的寫法練習很重要！因為在寫作過程中，必須每時每刻都很清楚自己正在用什麼、需要用什麼，一旦漏掉某個部分，可能就會炸出一堆錯誤訊息。  </p><h2 id="作業練習-Problem-Set-1"><a href="#作業練習-Problem-Set-1" class="headerlink" title="作業練習 (Problem Set 1)"></a>作業練習 (Problem Set 1)</h2><p>CS50x 課程提供了一個完整的線上 codespace，依照教學做完初次設定，之後就可以打開即寫了，成果測試和作業提交也相當方便。  </p><p>第一次接觸 C 語言就一口氣來了5個作業練習(其實應該算3個，其中2題是難易二選一就好，但我龜毛，想達成100%成就！)  </p><ul><li><strong>Hello.c</strong><br>就是上面提到的範例。練習輸入、輸出、 header files、comments  </li><li><strong>Mario-less.c</strong><br>do while 迴圈、nesting for loop  </li><li><strong>Mario-more.c</strong><br>do while.c 迴圈、nesting for loop，比上一題再複雜一點。</li><li><strong>Cash.c</strong><br>do while 迴圈、function。C 的 function 很特別，要在最開頭決定 return type(或 void)，引入的參數 type 也要定好。</li><li><strong>Credit.c</strong><br>do while 迴圈、if&#x2F;else、while loop，是上一題的進階。</li></ul><p>寫了差不多整整一天，雖然不是用最有效率的做法答題，但主要就是想用這週課堂學到的方式解題。練習量大的成果就是能「體會」上課內容到底在說什麼東西，但寫完之後覺得還需要重新把課程補充資料看過一遍做個複習。</p><h2 id="提升-Coding-品質"><a href="#提升-Coding-品質" class="headerlink" title="提升 Coding 品質"></a>提升 Coding 品質</h2><p>除了 C 的教學外，講師也有一再探討怎麼樣才是好的 code design。Coding 分三個階段:  </p><ul><li><strong>correctness：</strong> 要能正確的解決問題。  </li><li><strong>design：</strong> 包含變數的設計、減少重複的程式碼、提高程式碼再使用率、維護便利性…等。  </li><li><strong>style：</strong> 整體規格要有一致性、並提高閱讀便利性，盡可能整齊、簡潔明瞭。</li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>上了兩週的進度了，覺得課程的講解方式還算容易吸收，練習量也多。作業是需要在懂得前提下認真思考才能寫出來，對訓練思考邏輯很有幫助！  </p><blockquote><p>相關文章: <a href="https://ritachien.github.io/tags/CS50x-2022/">CS50x(2022)</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CS50 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS50x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS50W】Lecture0：HTML &amp; CSS</title>
      <link href="/posts/be2c6d84/"/>
      <url>/posts/be2c6d84/</url>
      
        <content type="html"><![CDATA[<p>課程名稱：CS50(Web Programming with Python and JavaScript)</p><span id="more"></span><h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><ul><li>HTML：HTML 結構、Common HTML Tags …簡介。  </li><li>CSS：Common CSS Properties、Specificity、CSS Selectors。  </li><li>Responsive Design：viewport、Media Queries、Flexbox、Grids。  </li><li>Bootstrap  </li><li>Sass：variables and nesting</li></ul><h2 id="問題討論：-style-method-的選擇"><a href="#問題討論：-style-method-的選擇" class="headerlink" title="問題討論： style method 的選擇"></a>問題討論： style method 的選擇</h2><p><strong>Method1 - Use inline style：</strong>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: green&quot;</span>&gt;</span>CSS from inline style<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Method2 - Use style tag：</strong>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: green;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>CSS from style tag<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Method3 - Use link to CSS file：</strong>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>CSS from link to CSS file<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p>上面三種方式的結果都一樣，各有優缺點。  </p><ul><li><strong>inline style</strong> 在順位上是三者中最高的，不會被其他的 CSS 設定覆蓋或影響。缺點是每個 HTML 元素要分別設置，在效率上或實用性上較不方便。  </li><li><strong>style tag</strong> 把 CSS 設定從各個 HTML 標籤中分離出來，在配合 CSS 選擇器的情況下，可以一次對多個 HTML 元素進行樣式設定，效率較高。畢竟學習寫程式的過程中，很常看到的一句話就是：「盡可能減少重複的程式碼」。另外一點就是，使用這種方式會把文件的「內容」和「樣式」區分開來管理，除了文件內容的結構會比較清晰易懂，也較容易達到「關注點分離」的效用。  </li><li>相對於 style tag 雖然把樣式跟內容分開，但兩者還是在同一個 HTML 文件裡； <strong>link to CSS file</strong> 的方式就直接將樣式設定放進單獨的 CSS 檔案做管理，「關注點分離」也更明確。另外就是，隨著我們做的 web app 規模變大，為了網頁畫面的一致性，我們可能會在多個網頁套用相同的 CSS 樣式。直接將樣式設定獨立成一個檔案並用 link 的方式引用，可以讓多個 HTML 文件引用同一個 CSS 樣式檔案。</li></ul><h2 id="小結：關注點分離"><a href="#小結：關注點分離" class="headerlink" title="小結：關注點分離"></a>小結：關注點分離</h2><p>關注點分離是在寫程式時要特別注意的地方，其目的就是讓程式碼的每個部分「分工明確」。這麼做的好處是，當程式碼執行結果發現任何不符合預期的地方，我們可以很容易地找出出問題的段落並進行修正，並且「只」需要修正該部分就好，程式碼的其他地方都不會受到影響。這在維護上會較方便、測試部分功能時也只需要針對特定一小段落即可，整體流程更有效率也不容易出錯。  </p>]]></content>
      
      
      <categories>
          
          <category> CS50 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> CS50W </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS50x(2022)】 Week0 - Scratch</title>
      <link href="/posts/b357a5fe/"/>
      <url>/posts/b357a5fe/</url>
      
        <content type="html"><![CDATA[<p>開始挑戰 CS50x(Introduction to Computer Science)了! </p><blockquote><p>What ultimately matters in this course is not so much where you end up relative to your classmates but where you end up relative to yourself when you began.<br>—— CS50x</p></blockquote><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次接觸到 Harvard 有名的 CS50 課程是在 Youtube 上看到這部影片:  </p><div class="youtube-video">  <div class="video-container"><iframe src="https://www.youtube.com/embed/XWe4iohhmIw" frameborder="0" loading="lazy" allowfullscreen></iframe></div></div><p>台上四位同學拿到一模一樣的道具、聽到一模一樣的指令，但是卻做出不一樣的動作。講師利用這種情境來告訴聽眾：我們給予的指令要「精準」，不然容易出現意料之外的結果。這種情境式的教學方式讓我覺得很有趣，運用一些簡單的例子來協助理解 Computer Science。  </p><h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><ul><li>What is computer science?  </li><li>Representing numbers  </li><li>Text  </li><li>Images, video, sounds  </li><li>Algorithms  </li><li>Pseudocode  </li><li>Scratch basics  </li><li>Abstraction  </li><li>Conditionals and more</li></ul><h3 id="二進位-Binary"><a href="#二進位-Binary" class="headerlink" title="二進位(Binary)"></a>二進位(Binary)</h3><p><strong>電腦只看得懂 <code>0</code> 跟 <code>1</code></strong> ，而二進位制是一種用 0 和 1 代表不同數字的進位方式。二進位中每個 bit 可以表示 1 和 0，而當我們有更多的 bits 時我們可以代表更大的數字，例如二進位的 11 是十進位的 3，111 是十進位的 7。  </p><h3 id="ASCII-x2F-Unicode"><a href="#ASCII-x2F-Unicode" class="headerlink" title="ASCII&#x2F;Unicode"></a>ASCII&#x2F;Unicode</h3><p>既然二進位表達的是「數字」，那其他的文字、符號呢？<br>ASCII 和 Unicode 都是字符對照表，兩者的差別就不贅述了。都是用數字來表示字母，例如：大寫的 A 是用十進位的 65 表示，也是二進位的 01000001。  </p><h3 id="RBG、圖片、影片"><a href="#RBG、圖片、影片" class="headerlink" title="RBG、圖片、影片"></a>RBG、圖片、影片</h3><p>RGB 是把顏色用不同「值」的紅(Red)、綠(Green)、藍(Blue)組合而成。而很多不同的顏色可以組成圖片、很多圖片可以連成影片。  </p><h3 id="二分搜尋法及程式邏輯-電話簿情境題"><a href="#二分搜尋法及程式邏輯-電話簿情境題" class="headerlink" title="二分搜尋法及程式邏輯(電話簿情境題)"></a>二分搜尋法及程式邏輯(電話簿情境題)</h3><p><strong>問題：要怎麼從厚厚的電話簿中找到指定人物的電話呢？</strong>  </p><ol><li>一頁一頁翻 ➜ 可以正確找到，但是好沒效率…  </li><li>兩頁兩頁跳著翻 ➜ 查詢效率是兩倍，但是萬一在單數頁怎麼辦？  </li><li>二分搜尋法 ➜ 從中間翻閱，依照姓名排序捨棄一半資料(不斷重複)</li></ol><p>完善搜尋方式的過程，並把過程用虛擬碼(pseudocode)寫出來幫助思考整個流程運作，最後用虛擬碼解釋函式、條件判斷、變數、迴圈…等是什麼?  </p><p><img src="/../Blog-image/posts/2022-04-29_pseudocode.webp" alt="pseudocode"><br>(圖片來自 CS50 課程內容  )</p><h3 id="Scratch"><a href="#Scratch" class="headerlink" title="Scratch"></a>Scratch</h3><p>用拼圖方式一步步組裝，做出一個可以運行的程式。  </p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>寫程式其實就是一個解題的過程，首先要確保可以得出正確的答案，再來才是優化解題的過程。  </p><p>在電話簿情境題中，如果僅僅是為了提升效率而兩頁兩頁做排查，也許會因為搜尋對象在單數頁而錯過。那即使可以在較短時間排查更多的資料也沒用，因為這種排查邏輯並不完善。  </p><p>從開始學習程式到現在已經大約半年了，由於 CS50x 是全英文課程，如果沒有一點點的程式基礎，聽起來真的會比較辛苦。半年前第一次聽的我和現在的重新撿回課程的我比起來，終於能比較順暢的聽懂了!接下來就是好好地堅持下去，認真的走完這個課程。  </p><blockquote><p>相關文章: <a href="https://ritachien.github.io/tags/CS50x-2022/">CS50x(2022)</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CS50 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS50x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alpha Camp 學期 2-3 結業心得</title>
      <link href="/posts/924950b4/"/>
      <url>/posts/924950b4/</url>
      
        <content type="html"><![CDATA[<p>隨著時間的推移，在學習上總是會碰到各種不同的狀況，而這些狀況也提供我不同的學習感受。這篇著重於紀錄自己遇到、找出並排除問題的過程。  </p><blockquote><p>要解決問題，必須先正確的找出問題發生原因。  </p></blockquote><span id="more"></span><h2 id="緣起：為短網址產生器加上重複檢查機制"><a href="#緣起：為短網址產生器加上重複檢查機制" class="headerlink" title="緣起：為短網址產生器加上重複檢查機制"></a>緣起：為短網址產生器加上重複檢查機制</h2><p>一如上學期結束時對自己許的願，這學期在寫作業的同時會盡可能地做些優化挑戰，然後不可避免的進入無窮卡關迴圈……  </p><p>近期卡了最久的就是短網址產生器了!! 作業的要求其實很簡單，只要可以產生英文字母或數字的隨機亂碼來當短網址即可。但是! 我突然想到:「萬一真的產生了相同的亂碼怎麼辦?」。依照我當下的執行邏輯，產生亂碼之後就馬上把它和原始網址加入互相對照的 index ，在沒有檢查的情況下，兩組原始網址導向同一個短網址也不是不可能發生。  </p><p>於是，我決定了優化方向：「在亂數產生器 return 結果之前加上檢查機制」，只要發現相同亂碼就重新執行一次亂碼產生流程。然後……在這個優化過程被卡了整整 2 天 🤣  </p><h2 id="嘗試失敗1：同步與非同步"><a href="#嘗試失敗1：同步與非同步" class="headerlink" title="嘗試失敗1：同步與非同步"></a>嘗試失敗1：同步與非同步</h2><blockquote><p>先來備註一下：這次用來存放 UrlIndex 資料的是 MongoDB。  </p></blockquote><p>原本的寫法如下(只放有問題部分):  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 產生亂碼短網址 &lt;file:root/utils/shortGenerator.js&gt;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generator</span> (length) &#123;<br>  <span class="hljs-comment">// 1. generate random code</span><br>  <span class="hljs-comment">// 2. Check if random url already exist</span><br>  <span class="hljs-comment">// =&gt; if exist, run &quot;generator (length)&quot;</span><br>  <span class="hljs-comment">// =&gt; if not yet exist, return result</span><br>  <span class="hljs-title class_">UrlIndex</span>.<span class="hljs-title function_">findOne</span>(&#123; <span class="hljs-attr">shortenUrl</span>: result &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> data ? <span class="hljs-title function_">generator</span>(length) : result<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 把短網址存入對照 index &lt;file:root/app.js&gt;</span><br><span class="hljs-title class_">UrlIndex</span>.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">shortenUrl</span>: <span class="hljs-title function_">generator</span>(<span class="hljs-number">5</span>),<br>  <span class="hljs-attr">originalUrl</span>: req.<span class="hljs-property">body</span>.<span class="hljs-property">url</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>在我的預想中， <code>generator()</code> 負責產生獨一無二的短網址，而 <code>UrlIndex.create()</code> 把取得的短網址拿去建立 index 。但是，看似沒問題的邏輯跳錯誤了! 好在目前遇到的大部分錯誤訊息都能正確敘述出問題的原因，它告訴我 shortenUrl 的值 <code>undefined</code> 。於是我去查查賦值 <code>undefined</code> 的原因，發現在我寫的流程裡最有可能的原因是：「若變數沒有提供初始值，則預設為 <code>undefined</code> 」。但不對啊~我不是有告訴 <code>UrlIndex.create()</code> shortenUrl 的值從 <code>generator()</code> 取得嗎? 為什麼會 <code>undefined</code> 呢?  </p><p>前幾天因緣際會接觸到「非同步」相關知識的我想起了前輩對非同步的評語：  </p><blockquote><p>實戰常常遇到問題，一研究發現，怎麼又是你！  </p></blockquote><p>檢查了一下目前進度，確實啊~ <code>UrlIndex.create()</code> 和 <code>UrlIndex.findOne()</code> 都是非同步語法，如果沒有處理好，根本無法控制完成的先後順序。於是，再度開始了 google 旅程，發現目前對於非同步執行順序最常使用兩種方式:  </p><ul><li>async&#x2F;await  </li><li>Promise.then()</li></ul><p>因為對 <code>async/await</code> 值的傳遞方式還不太熟悉，因此決定先用 <code>Promise.then()</code> 的方式。 <code>.then</code> 的前面必須是個 Promise 物件，但我目前 return 的是亂碼「值」。幸好查到的資料告訴我， mongoose 5.0 開始就內建 Promise 語法，所以我可以把整個 <code>UrlIndex.findOne()</code> 包成 Promise 物件。最後，我把整個檢驗是否重複的過程直接 return ，順利解決了執行順序問題。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 產生亂碼短網址</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generator</span> (length) &#123;<br>  <span class="hljs-comment">// (前略)</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">UrlIndex</span>.<span class="hljs-title function_">findOne</span>(&#123; <span class="hljs-attr">shortenUrl</span>: result &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> data ? <span class="hljs-title function_">generator</span>(length) : result<br>    &#125;)<br>&#125;<br><br><span class="hljs-title class_">ShortGenerator</span>(randomLength)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> urlData ? urlData : <span class="hljs-title class_">UrlIndex</span>.<span class="hljs-title function_">create</span>(&#123;<br>      <span class="hljs-attr">shortenUrl</span>: url,<br>      <span class="hljs-attr">originalUrl</span>: req.<span class="hljs-property">body</span>.<span class="hljs-property">url</span><br>    &#125;)<br>  &#125;)<br></code></pre></td></tr></table></figure><h2 id="嘗試失敗2：mongoose-語法-return-值"><a href="#嘗試失敗2：mongoose-語法-return-值" class="headerlink" title="嘗試失敗2：mongoose 語法 return 值"></a>嘗試失敗2：mongoose 語法 return 值</h2><p>接著，我想把產生的短網址結果呈現給使用者:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-title class_">UrlIndex</span>.<span class="hljs-title function_">findOne</span>(&#123; <span class="hljs-attr">originalUrl</span>: req.<span class="hljs-property">body</span>.<span class="hljs-property">url</span> &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">urlData</span> =&gt;</span> &#123;<br>      <span class="hljs-title class_">ShortGenerator</span>(randomLength)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> urlData ? urlData : <span class="hljs-title class_">UrlIndex</span>.<span class="hljs-title function_">create</span>(&#123;<br>            <span class="hljs-attr">shortenUrl</span>: url,<br>            <span class="hljs-attr">originalUrl</span>: req.<span class="hljs-property">body</span>.<span class="hljs-property">url</span><br>          &#125;)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">urlData</span> =&gt;</span> res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; urlBasic, urlData &#125;))  <span class="hljs-comment">// 執行到這行出問題!!</span><br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br>&#125;)<br></code></pre></td></tr></table></figure><p>這時候又跳錯誤了! 根據錯誤訊息查詢，發現是 handlebars 因為安全性問題，只接受乾淨的物件資料，通常可以用 <code>.lean()</code> 解決。把 <code>urlData</code> 印出來，看看到底取到什麼值? 嗯?? <code>_id</code> 裡面那個 new 是什麼? 看起來確定是回傳值的問題。<br><img src="/../Blog-image/posts/2022-04-24_returnValueOfMongoose.webp" alt="error_returnValueOfMongoose">  </p><p>於是我加上了 <code>.lean()</code> ，但它又報錯了!  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">urlData</span> =&gt;</span> &#123;<br>  urlData = urlData.<span class="hljs-title function_">lean</span>()<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; urlBasic, urlData &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/../Blog-image/posts/2022-04-24_mongoose.lean.webp" alt="error_mongoose.lean">  </p><p>測試後發現：如果是已建立 index 的網址就沒問題；反之，如果是新建的就會報錯。那就表示兩者拿到的資料不一樣。仔細查閱了 mongoose 官方文件， <code>UrlIndex.findOne()</code> 回傳 Query、 <code>UrlIndex.create()</code> 回傳 Promise 物件……好吧! 接下來的問題就是如何取 <code>UrlIndex.create()</code> 的「值」?  </p><p>在各種變換關鍵字後，終於在  stack overflow 找到救世主，可以用 <code>toObject()</code> 進行資料轉換。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">urlData</span> =&gt;</span> &#123;<br>  urlData = urlData.<span class="hljs-title function_">toObject</span>()<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; urlBasic, urlData &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><br>大功告成! 一切終於都如我預期的運作了!!  <p>成品程式碼: <a href="https://github.com/ritachien/URL_Shortener">在這裡</a>。  </p><h2 id="心得分享"><a href="#心得分享" class="headerlink" title="心得分享"></a>心得分享</h2><p>寫出來真的很有成就感啊!! 除了這個作業優化外，其實前面的作業也有經過類似的優化煎熬過程。總結起來解決問題的方法分幾個部分:  </p><ul><li>預防 – 仔細閱讀使用工具的官方文件、了解它的使用方法，正確的使用工具可以排除很多可能發生的問題。  </li><li>找出問題 – 知道問題發生原因才是解決的最快方法。就像前面分享的問題二，看起來是 handlebars 接受的資料類型問題，實際上是 mongoose 回傳值的原因。  </li><li>查找資料 – 在找出正確問題的前提下，盡可能下對關鍵字可以找到更接近需求的內容。</li></ul><p>不過沒有一次找到目標資料也沒關係，多多閱讀的過程中也能吸收各種知識，也許會在未來的某一天成為解決其他問題的關鍵!  </p>]]></content>
      
      
      <categories>
          
          <category> 課程心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Alpha Camp </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alpha Camp 學期 2-2 結業心得</title>
      <link href="/posts/f46b1c2/"/>
      <url>/posts/f46b1c2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在寫 code 之前先分拆邏輯與流程、用函式封裝程式碼、用心命名變數，這些基本動作原來是這麼地重要。  </p></blockquote><span id="more"></span><h3 id="OBJECTIVE"><a href="#OBJECTIVE" class="headerlink" title="OBJECTIVE"></a>OBJECTIVE</h3><p>經過學期2–2的學習，除了一邊複習之前學過的東西外，也對於程式流程的優化有更進一步的了解。尤其是使用 MVC 架構，讓整個程式不管是邏輯、流程或者是管理維護上都有了很大的提升。因為越學越有興趣的關係，和之前的幾個學期相比，現在的我對於主動優化作業有了很大的熱情。另外就是對於學期開頭的介紹有了更深刻的體會與認同!在寫 code 之前先分拆邏輯與流程、用函式封裝程式碼、用心命名變數，這些基本動作原來是這麼地重要。  </p><h3 id="REFLECTIVE"><a href="#REFLECTIVE" class="headerlink" title="REFLECTIVE"></a>REFLECTIVE</h3><p>大量的實作學習讓我從「跟著助教做」轉為「思考另一種做法的利弊是什麼」。因為多了各種思考過程，我開始了大量的資料閱讀和撰寫嘗試。在嘗試的過程中發現不同的寫法各有利弊，結果的選擇很大程度上取決於使用者體驗(目前就是我自己啦😆)  </p><p>就是因為想加的功能越變越多，導致我需要不斷往前修改之前考慮的不夠完善的地方，這個時候就想到:如果在最一開始，我對於那些撰寫基礎能更重視和用心，後面這些時間也許都可以節省下來。  </p><h3 id="INTERPRETIVE"><a href="#INTERPRETIVE" class="headerlink" title="INTERPRETIVE"></a>INTERPRETIVE</h3><p>這個學期下來也讓我對於「複習」這件事有了態度上的轉變。從原本的「之前不夠熟悉、必須找時間再多多複習」變成「主動在作業中融入以前學過的東西」。每個學期、甚至每個教案的著重點本來就不一樣，「複習」這件事就要找到適合自己的方法，不能依賴虛無飄渺的「找個時間來複習」。  </p><p>觀摩同學作業時，發現在一個作業中同時融入了很多以前學過的東西( media queries 、 flex、position…等)，可以看出他在開始編寫程式碼前，已經對設計成品有具體的想法，可能也針對不同螢幕大小畫出了多張 wireframe ，考慮了很多面向的東西。 他的練習實踐方式讓我發現我可以在完成當下目標同時複習以前學過的東西，學習的輸入可以從各自為政變成融會貫通 。  </p><h3 id="DECISIONAL"><a href="#DECISIONAL" class="headerlink" title="DECISIONAL"></a>DECISIONAL</h3><p>接下來進行課程時，希望自己能保持主動優化的動力。也許不是每一次嘗試都能得到好的結果，但在嘗試的過程中需要查資料、方法的選擇、功能的取捨，利用這個過程慢慢積累自己的知識庫，期望未來能不愧對付出的時間和努力!  </p>]]></content>
      
      
      <categories>
          
          <category> 課程心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AlphaCamp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>data-* HTML 自定義屬性及 dataset</title>
      <link href="/posts/b8b00b13/"/>
      <url>/posts/b8b00b13/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="/posts/470f6710/">JS30 Day1</a> 第一次看到 data-* 屬性，學習 DOM 之後發現真是太好用了阿!</p><span id="more"></span><blockquote><p>筆記內容為學習過程中的紀錄，內容可能未臻完善，如有錯漏，歡迎留言，謝謝!</p></blockquote><h2 id="data-基本介紹"><a href="#data-基本介紹" class="headerlink" title="data-* 基本介紹"></a>data-* 基本介紹</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Global_attributes/data-*">[MDN 說明]</a>  </p><p>HTML 標籤除了預設的屬性之外，其實還有個很好用的自定義屬性 <code>data-*</code> ，這個東西在開始進行 DOM 操作後，更可以明顯感受到它的方便性。通常我們在眾多 HTML 標籤中要針對特定幾個元素做操作時，會使用 id 或 class 來指定，但實際使用下來不夠彈性。例如:  </p><p>現在有 52 張撲克牌，我和朋友玩了撿紅點。計分時黑牌不計分、紅牌數值相加。我可以直接用 class name “card” 來套用同樣的卡背樣式。但如果我想把所有吃到”紅色牌分數”相加時，現有的屬性沒辦法滿足我的需求。  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 用 &lt;div&gt; 做出 52 張牌 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>...(略)<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>J<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>Q<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>K<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>於是，我就可以用 <code>data-*</code> 來加上我需要的屬性內容。 用 <code>data-suit</code> 來表示花色、 <code>data-value</code> 來表示數字。這樣，我就可以一眼看出這張牌的顏色和數字了!  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 加上花色及數值屬性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-suit</span>=<span class="hljs-string">&quot;club&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-suit</span>=<span class="hljs-string">&quot;diamond&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-suit</span>=<span class="hljs-string">&quot;heart&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>...(略)<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-suit</span>=<span class="hljs-string">&quot;heart&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span>J<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-suit</span>=<span class="hljs-string">&quot;spade&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span>Q<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-suit</span>=<span class="hljs-string">&quot;spade&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;13&quot;</span>&gt;</span>K<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 <code>data-*</code> 可以新增一個”自定義屬性”，並給這個屬性一個”值”，有了這個設定之後，就可以更有針對性及彈性的對特定元素進行操作。  </p><h3 id="命名規則"><a href="#命名規則" class="headerlink" title="命名規則"></a>命名規則</h3><p><strong>(很重要! 和後面提到的 dataset 應用有關!)</strong>  </p><ul><li>同 class 命名慣例，用 <code>-</code> 串接字詞。  </li><li>名字絕對不能以 <code>xml</code> 起頭。  </li><li>名字只能包含小寫字母、數字、dash（-）、點（.）、冒號（:）和下底線（_）。</li></ul><h3 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h3><p> <code>data-*</code> 所儲存的屬性值型別都是<strong>字串</strong>，如果要進行四則運算要記得先轉換型別!</p><h2 id="CSS-應用"><a href="#CSS-應用" class="headerlink" title="CSS 應用"></a>CSS 應用</h2><h3 id="CSS-選擇器"><a href="#CSS-選擇器" class="headerlink" title="CSS 選擇器"></a>CSS 選擇器</h3><p>我們常以 class 及 id 來定義 CSS 樣式。其實 CSS 選擇器中有一個<strong>屬性選擇器</strong>，可以依屬性值來選擇特定元素。接續上面的撲克牌為例，把花色為愛心&#x2F;方塊的牌顯示為紅色:  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 選擇屬性為特定值的元素 */</span><br><span class="hljs-selector-attr">[data-suit=<span class="hljs-string">&quot;heart&quot;</span>]</span>,<br><span class="hljs-selector-attr">[data-suit=<span class="hljs-string">&quot;diamond&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS-content-及-attr"><a href="#CSS-content-及-attr" class="headerlink" title="CSS content 及 attr()"></a>CSS content 及 attr()</h3><p><code>content</code> 可以用 CSS 直接生成靜態文字； <code>attr()</code> 則是可以讀取”屬性值”。<br>如果有3個設好 <code>data-value</code> 的撲克牌，我要讓它在 <code>&lt;div&gt;&lt;/div&gt;</code> 中間加入屬性的值:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 原本未加 CSS 狀態 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>設置 CSS content:  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-built_in">attr</span>(data-value)<br>&#125;<br></code></pre></td></tr></table></figure><p>CSS 渲染過後的 HTML 會呈現:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">data-value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="DOM-與-JavaScript-應用"><a href="#DOM-與-JavaScript-應用" class="headerlink" title="DOM 與 JavaScript 應用"></a>DOM 與 JavaScript 應用</h2><h3 id="DOM-querySelector"><a href="#DOM-querySelector" class="headerlink" title="DOM querySelector"></a>DOM querySelector</h3><ul><li><p>在使用 querySelector 時，可以直接指定<strong>屬性值</strong>。以”選擇所有梅花牌”為例:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 選取所有含 data-suit=&quot;club&quot; 的節點</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectors</span>(<span class="hljs-string">&#x27;[data-suit=&quot;club&quot;]&#x27;</span>)<br><span class="hljs-comment">// 選取所有含 data-suit=&quot;club&quot; 的 &lt;div&gt; 節點</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectors</span>(<span class="hljs-string">&#x27;div[data-suit=&quot;club&quot;]&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>也可以更彈性的運用，使用 template 代入屬性值。以 <a href="https://github.com/ritachien/JavaScript30/blob/master/01%20-%20JavaScript%20Drum%20Kit/index.html">[JS30 Day1 JavaScript Drum Kit]</a> 為例:<br>在 HTML 部分設置了4個按鍵元素(A、S、D、F)，並為每個按鍵標上編號。  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;65&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;83&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span>S<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;68&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;70&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span>F<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>設置監聽事件，自動讀取事件紀錄的 <code>keyCode</code> 並將數值代入 template 中。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, playAudio)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">playAudio</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">const</span> key = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`.key[data-key=&quot;<span class="hljs-subst">$&#123;event.keyCode&#125;</span>&quot;]`</span>)<br>  <span class="hljs-comment">// 其他程式碼(略)</span><br>&#125;<br><br><span class="hljs-comment">// 例如: 按下&quot;A&quot;鍵，事件紀錄的 keyCode:65 ，這裡就會直接把65代入。上面的程式碼會變成:</span><br><span class="hljs-keyword">const</span> key = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.key[data-key=&quot;65&quot;]&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="HTMLElement-dataset"><a href="#HTMLElement-dataset" class="headerlink" title="HTMLElement.dataset"></a>HTMLElement.dataset</h3><p><a href="https://developer.mozilla.org/zh-TW/docs/orphaned/Web/API/HTMLOrForeignElement/dataset">[MDN 說明]</a>  </p><h4 id="命名轉換"><a href="#命名轉換" class="headerlink" title="命名轉換"></a>命名轉換</h4><p><strong>dash-style to camelCase</strong>  </p><ol><li>刪去前綴字 <code>data-</code> 。  </li><li>每個 <code>-</code> 後的第一個字母轉為大寫，刪去中間 <code>-</code> 後連接字串。<br>例如: <code>data-abc-def-ghi</code> 會被轉換為 <code>abcDefGhi</code>。</li></ol><h4 id="實際運用"><a href="#實際運用" class="headerlink" title="實際運用"></a>實際運用</h4><blockquote><p>範例取自 MDN 文件<br>有個 HTML 元素如下:</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;1234567890&quot;</span> <span class="hljs-attr">data-user</span>=<span class="hljs-string">&quot;johndoe&quot;</span>&gt;</span><br>  John Doe<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果我要取它的 <code>data-*</code> 屬性值，取值方式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 選取要取值的對象</span><br><span class="hljs-keyword">const</span> user = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#user&#x27;</span>)<br><span class="hljs-comment">// 開始取值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">dataset</span>.<span class="hljs-property">id</span>)  <span class="hljs-comment">// 回傳 &#x27;1234567890&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">dataset</span>.<span class="hljs-property">user</span>)  <span class="hljs-comment">// 回傳 &#x27;johndoe&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30 挑戰】 Day2 - JS and CSS Clock</title>
      <link href="/posts/74544bca/"/>
      <url>/posts/74544bca/</url>
      
        <content type="html"><![CDATA[<p>這個專案練習了 CSS 轉場效果( <code>transition</code> &amp; <code>transform</code> )，並利用 JavaScript function 來帶動 <code>transform</code> 的變化。</p><span id="more"></span><blockquote><p><a href="https://javascript30.com/">JavaScript30</a> 是一個由 <strong>Wes Bos</strong> 提出的免費教學計畫。藉由每天完成一個小專案，練習基礎 JavaScript 。整個計畫為期30天。除了會提供教學影片外，也會先做好前期準備(例如: HTML&#x2F;CSS 等相關建置)，練習時只需專注於撰寫 JavaScript 部分的程式碼即可。</p></blockquote><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li>取得當地時間當下的時&#x2F;分&#x2F;秒資訊。  </li><li>利用取得的時間資訊，套入 CSS 設定來讓時鐘的指針移動。</li></ol><h2 id="練習內容"><a href="#練習內容" class="headerlink" title="練習內容"></a>練習內容</h2><ul><li><strong>JavaScript</strong><br>DOM querySelector 、 function 、Date() 、setInterval()</li><li><strong>CSS</strong><br>transform 、 transform-origin 、transition</li></ul><h2 id="開始前的準備"><a href="#開始前的準備" class="headerlink" title="開始前的準備"></a>開始前的準備</h2><blockquote><p>這部分已由教學計畫提供。</p></blockquote><p><strong>做好 HTML&#x2F;CSS 設定:</strong><br>做出時鐘長相並為指針做好相關設置。<br>為了練習 <code>transform-origin</code> ，指針預設往9點鐘方向。但我為了方便，已自行調整成12點鐘方向。</p><h2 id="練習開始"><a href="#練習開始" class="headerlink" title="練習開始"></a>練習開始</h2><p><strong>1. 調整指針起點至12點鐘方向</strong>  </p><ul><li>原本教學是用 <code>transform: rotate(90deg)</code> 處理，但為了方便，我直接調整 CSS。  </li><li><code>transform-origin</code> 跟著調整成 bottom。  </li><li><code>transition</code> 讓所有對象都執行變化，每次用0.05秒完成變化。</li><li>各別設定指針外觀，以便觀察後續變化。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.hand</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform-origin</span>: bottom;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.05s</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.hour-hand</span> &#123;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">15%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">35%</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.min-hand</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-class">.second-hand</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">background</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><br><p><strong>2. 用 setInterval() 設定 function 執行週期。</strong>  </p><ul><li>以每1000毫秒執行一次 setTime() function(秒針跳動頻率)。<br>註: 1秒 &#x3D; 1000毫秒<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setInterval</span>(setTime, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><br></li></ul><p><strong>3. 取得時間資訊</strong></p><ul><li>分別找出 3 支指針。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hourHand = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.hour-hand&#x27;</span>)<br><span class="hljs-keyword">const</span> minuteHand = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.min-hand&#x27;</span>)  <br><span class="hljs-keyword">const</span> secondHand = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.second-hand&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>建立一個 setTime() function ，並把要執行的動作放入函式。  </li><li>取得當下時間，並分別取出時&#x2F;分&#x2F;秒。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setTime</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br><br>  <span class="hljs-keyword">const</span> hours = now.<span class="hljs-title function_">getHours</span>()<br>  <span class="hljs-keyword">const</span> mins = now.<span class="hljs-title function_">getMinutes</span>()<br>  <span class="hljs-keyword">const</span> seconds = now.<span class="hljs-title function_">getSeconds</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li><li>依照時間比例算出旋轉角度，並帶入 CSS 的 <code>rotate()</code> 設置。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setTime</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 取得時間</span><br>  <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>  <span class="hljs-keyword">const</span> seconds = now.<span class="hljs-title function_">getSeconds</span>();<br>  <span class="hljs-keyword">const</span> mins = now.<span class="hljs-title function_">getMinutes</span>();<br>  <span class="hljs-keyword">const</span> hour = now.<span class="hljs-title function_">getHours</span>();<br>  <span class="hljs-comment">// 計算角度</span><br>  <span class="hljs-keyword">const</span> secondsDegree = (seconds / <span class="hljs-number">60</span>) * <span class="hljs-number">360</span>;<br>  <span class="hljs-keyword">const</span> minsDegree = ((mins / <span class="hljs-number">60</span>) * <span class="hljs-number">360</span>) + ((seconds / <span class="hljs-number">60</span> / <span class="hljs-number">60</span>) * <span class="hljs-number">360</span>);<br>  <span class="hljs-keyword">const</span> hourDegree = ((hour / <span class="hljs-number">12</span>) * <span class="hljs-number">360</span>) + ((mins / <span class="hljs-number">12</span> / <span class="hljs-number">60</span>) * <span class="hljs-number">360</span>);<br>  <span class="hljs-comment">// 角度代入 CSS</span><br>  secondHand.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;secondsDegree&#125;</span>deg)`</span>;<br>  minuteHand.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;minsDegree&#125;</span>deg)`</span>;<br>  hourHand.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;hourDegree&#125;</span>deg)`</span>;<br>&#125;<br></code></pre></td></tr></table></figure>到這裡就是一個會動的正確時鐘了。  <br></li></ul><p><strong>4. 旋轉優化</strong></p><ul><li>觀察秒針活動軌跡發現，當它要從 59 秒跳回 0 秒時會逆時針旋轉。因為對電腦來說 59 –&gt; 0 是”後退”不是”前進”。最簡單的方法就是，當指針要回到 0 秒時，花費 0 秒直接變化，肉眼就看不出回退過程了。  </li><li>設置一個檢查：如果任一指針角度為0，<code>transition</code> 改為 ‘all 0s’。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 設置一個分辨角度的 function</span><br><span class="hljs-keyword">if</span> (secondsDegree === <span class="hljs-number">0</span><br>  || minsDegree === <span class="hljs-number">0</span><br>  || hourDegree === <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.hand&#x27;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">&#x27;all 0s&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.hand&#x27;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">&#x27;all 5ms&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>因為 JavaScript 有<strong>由上而下</strong>的執行順序，所以要把這段插到 “角度代入 CSS” 之前。</li></ul><br><br><p>到這裡就全部完成了!<br>學習到方便的時間取得辦法後，我就要把部落格 footer 從網路上照抄的程式碼改掉了。學到的東西能確實應用真的會很有動力!</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS30 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML &amp;lt;audio&amp;gt; 標籤</title>
      <link href="/posts/70fc7e3d/"/>
      <url>/posts/70fc7e3d/</url>
      
        <content type="html"><![CDATA[<p>為了增加網頁的互動性，有時候會想讓網頁發出聲音，這時候只要在 HTML 文件中加上 <code>&lt;audio&gt;</code> 標籤即可。  </p><span id="more"></span><blockquote><p>筆記內容為學習過程中的紀錄，內容可能未臻完善，內文可能也會隨著學習過程作增減或修改。<br>如有錯漏，歡迎留言，謝謝!</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>self-closing: <strong>非自閉合標籤</strong>，必須有開始標籤和結束標籤。  </li><li>display: inline (雖然在 <a href="https://htmlreference.io/">htmlreference.io</a> 說預設是 block ，但我實際測試是跟換行有關，如下所示)  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 這是換行效果--block</span><br>&lt;span&gt;前面&lt;/span&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/music.mp3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>後面<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure><span>前面</span><br><audio controls src="/example/music.mp3"></audio><br><span>後面</span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 這是沒換行效果(或是換行但用&lt;div&gt;包住)--inline</span><br>&lt;span&gt;前面&lt;<span class="hljs-regexp">/span&gt;&lt;audio controls src=&quot;/</span>example/music.<span class="hljs-property">mp3</span><span class="hljs-string">&quot;&gt;&lt;/audio&gt;&lt;span&gt;後面&lt;/span&gt;</span><br></code></pre></td></tr></table></figure><div><span>前面</span><audio controls src="/example/music.mp3"></audio><span>後面</span></div></li></ul><br><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>用來幫網頁加入音訊。可使用 <code>src</code> 屬性或在 &lt;audio&gt; 中加入 &lt;source&gt; 標籤來設定音訊來源。</li><li>&lt;audio&gt;&lt;&#x2F;audio&gt; 中除了 &lt;source&gt; 以外的內容在資源載入失敗或不支援時顯示。</li></ul><h2 id="屬性"><a href="#屬性" class="headerlink" title="屬性"></a>屬性</h2><ul><li>直接在 &lt;audio&gt; 中加入屬性。</li></ul><table><thead><tr><th>Name</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>src</td><td>URL</td><td>音訊的來源位址</td></tr><tr><td>autoplay</td><td>(No value required)</td><td>是否自動撥放，若不使用預設是 false</td></tr><tr><td>loop</td><td>(No value required)</td><td>是否循環撥放，若不使用預設是 false</td></tr><tr><td>controls</td><td>(No value required)</td><td>是否顯示由瀏覽器提供的音訊控制面板，包含撥放進度、暫停、撥放紐等，若不使用預設是 false</td></tr><tr><td>currentTime</td><td>數值(number)</td><td>以秒為單位的當前撥放位置</td></tr><tr><td>muted</td><td>(No value required)</td><td>預設靜音，若不使用預設是 false</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 範例:</span><br><span class="hljs-comment">// 使用 controls 會自動產生控制面板(如下所示)</span><br>&lt;audio controls muted src=<span class="hljs-string">&quot;/example/music.mp3&quot;</span>&gt;&lt;/audio&gt;<br></code></pre></td></tr></table></figure><p><audio controls muted src="/example/music.mp3"></audio></p><br><ul><li>使用 &lt;source&gt; 標籤</li></ul><table><thead><tr><th>Name</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>src</td><td>URL</td><td>音訊的來源位址</td></tr><tr><td>type</td><td></td><td>音訊的 MIME type</td></tr></tbody></table><p>&lt;source&gt; 是自閉合標籤，不須使用 <code>&lt;/source&gt;</code> 。<br>可利用 &lt;source&gt; 標籤加入多個音訊來源，瀏覽器會使用第一個有支援的格式來載入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;audio controls&gt;<br>  這段文字在資源載入失敗或不支援時顯示。<br>  &lt;source src=<span class="hljs-string">&quot;example.ogg&quot;</span> type=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30 挑戰】 Day1 - JavaScript Drum Kit</title>
      <link href="/posts/470f6710/"/>
      <url>/posts/470f6710/</url>
      
        <content type="html"><![CDATA[<p>這個專案對 JavaScript 只要有 function 跟 DOM 基礎就沒問題。另外需要有一點 HTML&#x2F;CSS 的概念才有辦法順利使用 <code>querySelector</code> 。</p><span id="more"></span><blockquote><p><a href="https://javascript30.com/">JavaScript30</a> 是一個由 <strong>Wes Bos</strong> 提出的免費教學計畫。藉由每天完成一個小專案，練習基礎 JavaScript 。整個計畫為期30天。除了會提供教學影片外，也會先做好前期準備(例如: HTML&#x2F;CSS 等相關建置)，練習時只需專注於撰寫 JavaScript 部分的程式碼即可。</p></blockquote><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li>當按下鍵盤按鍵時，撥放特定音效。  </li><li>當按下鍵盤按鍵時，讓畫面上的按鍵圖示呈現變化，並在變化結束後恢復原狀。</li></ol><h2 id="練習內容"><a href="#練習內容" class="headerlink" title="練習內容"></a>練習內容</h2><ul><li>DOM querySelector  </li><li>.addEventLinstener()  </li><li>function  </li><li>.forEach()</li></ul><h2 id="開始前的準備"><a href="#開始前的準備" class="headerlink" title="開始前的準備"></a>開始前的準備</h2><blockquote><p>雖然這部分已由教學計畫提供，但有些東西對我來說還是新知識，所以還是做個筆記，萬一以後自己想做類似功能也不用再另外找資料。</p></blockquote><p><strong>1. 幫網頁加上音效:</strong><br>僅需要在 HTML 檔案中加入 <strong>&lt;audio&gt;標籤</strong>，並做好相關屬性設定。  </p><p><strong>2. 設定好鍵盤按鍵:</strong><br>因為我們要在按下鍵盤按鍵時，讓網頁做出指定回應，所以要先建立相關標籤屬性，讓電腦辨識不同的按鍵，以便為按鍵設定不同回應。可以看到教學計畫提供的 HTML 檔案已經為聲音跟按鍵都設好 <code>data-key</code> 這個屬性(attribute)並給予一個數值。鍵盤上的每個按鍵在按下時會有一個對應的 <code>keycode</code> ，只要知道 <code>keycode</code> 就可以對指定按鍵進行動作設定。  </p><p>如果不知道 <code>keycode</code> 可以到 <a href="keycode.info">keycode.info</a> 查詢。或是隨便開啟一個網頁，打開開發人員工具，在 console 區寫下下列程式碼後，回到網頁內容範圍(滑鼠點一下)在按下鍵盤按鍵，console 就會印出 <code>keycode</code> 了。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">keyCode</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>3. 做好 CSS 設定:</strong><br>專案目標是讓螢幕上的按鍵圖示在按下時產生變化，並在變化結束後恢復原狀。所以要設定好兩種 CSS 樣式:  </p><ul><li>原本的按鍵樣式: 在 <code>&#123;&#125;</code> 裡加上 <code>transition: all .07s;</code> ，決定 <code>要改變的屬性(property)</code> 、 <code>變化要花費的時間</code> 。  </li><li>變化後的按鍵樣式: 在 <code>&#123;&#125;</code> 裡加上 <code>transform: scale(縮放倍數);</code></li></ul><h2 id="練習開始"><a href="#練習開始" class="headerlink" title="練習開始"></a>練習開始</h2><p><strong>1. 定好 Event Linstener 的範圍和要執行的動作。</strong>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, playAudio)<br><span class="hljs-comment">// window 為 document 再往上一層的物件，指監聽整個瀏覽器分頁。</span><br><span class="hljs-comment">// &#x27;keydown&#x27; 指鍵盤按鍵被按下時。</span><br><span class="hljs-comment">// playAudio 指執行名稱叫 playAudio 的fuction。</span><br></code></pre></td></tr></table></figure><p><strong>2. 設定 playAudio() 要做的事。(撥放音效及畫面改變)</strong>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">playAudio</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-comment">// e 指 .addEventListener() 在 &#x27;keydown&#x27; 發生時自動產生的 event 物件。</span><br>  <span class="hljs-keyword">const</span> audio = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`audio[data-key=&quot;<span class="hljs-subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>)<br>  <span class="hljs-comment">// 把 audio 變數指向 keyCode 相符的 &lt;audio&gt; 標籤。</span><br>  <span class="hljs-keyword">const</span> key = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`.key[data-key=&quot;<span class="hljs-subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>)<br>  <span class="hljs-comment">// 把 key 變數指向 keyCode 相符的 &lt;div&gt; 標籤。</span><br>  <span class="hljs-keyword">if</span> (!audio) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">// 如果找不到相符標籤，則中斷 function。</span><br>  audio.<span class="hljs-property">currentTime</span> = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 如果找到相符標籤，按下按鍵時，音樂撥放進度回到第 0 秒。如果沒設定，在音訊完整前，按鍵不會重新撥放。</span><br>  <span class="hljs-comment">// 因為 function 要求按鍵時撥放音訊，還沒放完 = 已經/正在放</span><br>  audio.<span class="hljs-title function_">play</span>()<br>  <span class="hljs-comment">// 撥放 keyCode 指向的 &lt;audio&gt; 標籤。</span><br>  key.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;playing&#x27;</span>)<br>  <span class="hljs-comment">// 指定的 &lt;div&gt; 標籤 class 屬性加上 &#x27;playing&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 先來看看目前為止發生了什麼事?</strong><br>指定的 &lt;div&gt; 標籤 class 屬性加上 ‘playing’ 後，當 CSS ‘.key’ 中的 <code>transition</code> 完成。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> keys = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.key&quot;</span>)<br><span class="hljs-comment">// 找出所有 class 含 &quot;.key&quot; 的 &lt;div&gt; 標籤，總共9個。</span><br>keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> key.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;transitionend&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>&#125;))<br><span class="hljs-comment">// 檢查找出的所有 &lt;div&gt; 標籤，在 &#x27;transitionend&#x27; 時，輸出 Event 內容。</span><br></code></pre></td></tr></table></figure><p><img src="/../../Blog-image/posts/2022-01-29_TransitionEvent.webp" alt="TransitionEvent-image"><br>可以看到，在我們按了一下按鍵”A”後，總共出現了6個 <code>transitionend</code> ，只有 <code>propertyName</code> 不同。那是因為我們的 CSS 設定。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.key</span> &#123;<br>  <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">07s</span> ease;<br>  <span class="hljs-comment">/* 所有 property 都要執行 transition */</span><br>&#125;<br><br><span class="hljs-selector-class">.playing</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);<br>  <span class="hljs-comment">/* propertyName: &#x27;transform&#x27; */</span><br>  <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#ffc600</span>;<br>  <span class="hljs-comment">/* border 分上下左右，所以有4個 &#x27;transitionend&#x27; */</span><br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1rem</span> <span class="hljs-number">#ffc600</span>;<br>  <span class="hljs-comment">/* propertyName: &#x27;box-shadow&#x27; */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. 畫面在變化結束後恢復原狀。</strong>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> keys = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.key&quot;</span>)<br><span class="hljs-comment">// 共找出9個 class 含 &quot;.key&quot; 的 &lt;div&gt; 標籤。</span><br>keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> key.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;transitionend&#x27;</span>, removeTransition))<br><span class="hljs-comment">// &#x27;transitionend&#x27; 時，執行名為 removeTransition 的function。</span><br></code></pre></td></tr></table></figure><p>這時，我總共找出9個 class 含 “.key” 的 &lt;div&gt; 標籤，但是想要刪除 class ‘.playing’ 的只有我們按的那一個。所以我們找出 這個 &lt;div&gt; 標籤所有 CSS 樣式裡最具代表性的 <code>transform</code> (不用寫一長串 property ，最具代表性的就好)，來繼續執行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeTransition</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-comment">// 查找 TransitionEvent 裡動作(type)為 &#x27;transitionend&#x27; 的項目。</span><br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">propertyName</span> !== <span class="hljs-string">&#x27;transform&#x27;</span>) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">// 如果 TransitionEvent 的 propertyName 不等於 &#x27;transform&#x27; ，則停止 function。</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;playing&#x27;</span>)<br>  <span class="hljs-comment">// 如果符合，則將 class 裡的 &#x27;.playing&#x27; 刪除。</span><br>&#125;<br></code></pre></td></tr></table></figure><br><br>到這裡就全部完成了! ]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS30 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alpha Camp 學期 2-1 結業心得</title>
      <link href="/posts/73279419/"/>
      <url>/posts/73279419/</url>
      
        <content type="html"><![CDATA[<p><em><strong>學習的過程充滿挑戰，成功闖過之後就想做更多的挑戰!</strong></em><br>這大概就是我在這階段完課後，最明顯的感受。  </p><span id="more"></span><p>有轉職意願後，我報名了學期一課程，想確認是否真的對程式語言有興趣。在將近一個月的課程接觸下，燃起了久違的學習熱情，隨後決定繼續向學期二邁進，將學期一碰到的 HTML&#x2F;CSS&#x2F;JavaScript 更精進。  </p><p>相較於學期一類似「興趣班」的節奏，學期 2-1 第一週開始接觸了陣列、物件及函式，不管是單週課程量或難度對我來說都有明顯變高的感覺，作業也變得更加「靈活」。學習過程需要花更多的時間理解、作業要花更多的時間思考，本來以為難度提高會帶來挫折感，進而降低學習熱情，結果相反，我最直觀的感受是「我能做到的事變多了」。課程作業藉著把摸彩活動分成小步驟完成，最後組合再一起，這種「把大任務變小」的方式，我覺得有效降低了學習期間的挫折感。  </p><p>再後來的 DOM 和事件驅動，就更多的提高我對 JavaScript 的學習興趣，藉由 DOM 就可以用 JavaScript 來操作寫好的 HTML，學到了讓使用者跟網頁互動的方法，。每一個章節作業做完的同時，開始會主動思考「可以加上什麼功能?」，有的成功、有的失敗，不知不覺坐在電腦前的時間越來越長😄  </p><p>說到這裡可能有人發現了…… CSS 呢?<br>是的，我對 CSS 一直還沒燃起足夠的熱情，花著同樣的時間進行學習，但 CSS 就是很難記住，寫起來很不順手。這種期況一直持續到學到 DOM 和事件驅動才有改善。在加上新功能後，我新加的東西在網頁上動起來<del>覺得自己有點厲害</del>但長得醜醜的，這時候才開始想各種辦法改善它，積極地回去複習排版…等語法。  </p><p>因為 JavaScript 想新加功能，所以積極複習、查資料、使用還沒學到的東西。因為覺得畫面醜醜的，所以重新面對興致不高的 CSS 。難怪人家都說，想進步最快的辦法就是去做各種 side project 。原本的期末作業「RGB 色碼轉 HEX」，看是要輸入 RGB 色碼或用 slider 調色只要二選一，最後輸出 HEX 結果即可。為了想讓三者同步，查了 <code>addEventListener</code> 的各種 event ，寫了整整一天，寫出來的當下很有成就感! <a href="https://ritachien.github.io/Convert-Between-RGB-HEX/">(動手試試看)</a>  </p><p><img src="https://github.com/ritachien/Convert-Between-RGB-HEX/blob/main/demo.gif?raw=true"></p><p>學習過程記錄大致就這樣了。<br>學期 2-1 找到了提高我學習動力的方法—-<strong>實作、實作、再實作</strong>。準備在春節期間開始挑戰 JS30，然後開始學期 2-2 的預讀。最後的最後，許個新年新希望: 我不要再當米蟲了阿~~~~~~ 今年一定要轉職成功阿~~~~~</p>]]></content>
      
      
      <categories>
          
          <category> 課程心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AlphaCamp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>簡易 RPG 戰鬥：攻擊與補血</title>
      <link href="/posts/23e46325/"/>
      <url>/posts/23e46325/</url>
      
        <content type="html"><![CDATA[<p><strong>題目來源:</strong> Alpha Camp 學期 2-1<br>題目的主要目的是 Javascript function 的練習。設計 function 的運作方式，利用 <code>if</code> + <code>return</code> 來控制需要提早跳出函式的情況，及使用 <code>this</code> 取到物件自身。  </p><span id="more"></span><p>題目原本僅要求專注在 <strong>攻擊(attack)</strong> 和 <strong>治療(cure)</strong> function 的撰寫，其餘流程已由原題目提供。但基於再次練習的目的，且題目其餘部分也是由學過的 while 迴圈組成，所以這次練習會從頭把整個流程寫出來。  </p><h2 id="解題工具"><a href="#解題工具" class="headerlink" title="解題工具"></a>解題工具</h2><ol><li>function 函式  </li><li>while 迴圈  </li><li>if statement</li></ol><h2 id="題目要求"><a href="#題目要求" class="headerlink" title="題目要求"></a>題目要求</h2><ol><li>預設戰士 <code>hp</code> 為 100、 <code>mp</code> 為 30；魔法師 <code>hp</code> 為 30、 <code>mp</code> 為 100。</li><li>由魔法師先攻，若有任一方死掉，則遊戲結束，不能再有補血或攻擊動作；反之，若兩個角色都活著，則遊戲可一直正常執行，直到一方死掉。  </li><li>攻擊者會呼叫 <code>attack()</code> 攻擊敵方，產生 1~100 點之間隨機點數的傷害。  </li><li>若被攻擊方沒有死，則會呼叫 <code>cure()</code> 為自己補血，補血規格為：每次補血固定為 15 點 <code>hp</code> 、每補充 1 點 <code>hp</code> 需要 2 點 <code>mp</code>。補血結束後攻守交換。  </li><li><code>cure()</code> 會傳入一個參數為 <code>hp</code> ，指的是想要補充的 <code>hp</code> 。  </li><li>補血可以補超過原有的 <code>hp</code>，沒有 <code>hp</code> 最大值上限，只要有 <code>mp</code> 都可以補血。  <blockquote><p>原題目是由戰士先攻，但為了方便觀察輸出結果，改由魔法師先攻。</p></blockquote></li></ol><h2 id="解題過程"><a href="#解題過程" class="headerlink" title="解題過程"></a>解題過程</h2><h3 id="拆解流程"><a href="#拆解流程" class="headerlink" title="拆解流程"></a>拆解流程</h3><ol><li>創建角色(含 <code>name</code> 、 <code>hp</code> 、 <code>mp</code> 、<code>attack()</code> 及 <code>cure()</code> )  </li><li>戰鬥流程  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span> 戰士及魔法師都活著<br>  則魔法師先攻、戰士師補血(補血是否執行由函式決定)<br>  <span class="hljs-keyword">if</span> 戰士還活著<br>    則戰士攻擊、魔法師補血(補血是否執行由函式決定)<br>任一方死掉，則遊戲結束。<br></code></pre></td></tr></table></figure></li></ol><h3 id="解題開始"><a href="#解題開始" class="headerlink" title="解題開始"></a>解題開始</h3><h4 id="function-設計"><a href="#function-設計" class="headerlink" title="function 設計"></a>function 設計</h4><ol><li><p>攻擊動作 attack()  </p><ul><li>產生攻擊點數、輸出攻擊資訊  </li><li>結果1(打死): 輸出”對手死亡”  </li><li>結果2(沒打死): 輸出”對手活著”，且對手啟動cure()  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">attack</span> (enemy) &#123;<br>  hpLose = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>) + <span class="hljs-number">1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> hit <span class="hljs-subst">$&#123;enemy.name&#125;</span>, <span class="hljs-subst">$&#123;enemy.name&#125;</span> lose <span class="hljs-subst">$&#123;hpLose&#125;</span> HP.`</span>)<br>  enemy.<span class="hljs-property">hp</span> -= hpLose<br>  <br>  <span class="hljs-keyword">if</span> (enemy.<span class="hljs-property">hp</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;enemy.name&#125;</span> is dead.\n`</span>)<br>    <span class="hljs-keyword">return</span> enemy.<span class="hljs-property">hp</span> = <span class="hljs-number">0</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;enemy.name&#125;</span> is still alive. (HP = <span class="hljs-subst">$&#123;enemy.hp&#125;</span>)`</span>)<br>    enemy.<span class="hljs-title function_">cure</span>(<span class="hljs-number">15</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>治療動作 cure()  </p><ul><li>結果1(mp夠): 啟動治療並輸出治療結果  </li><li>結果2(mp不夠): 不治療繼續  </li><li>攻守互換  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cure</span> (hp) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">mp</span> &gt;= (hp * <span class="hljs-number">2</span>)) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hp</span> += hp<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mp</span> -= hp * <span class="hljs-number">2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> recovered. (HP = <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.hp&#125;</span>；MP = <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.mp&#125;</span>)`</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`MP isn&#x27;t enough! <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> cannot use cure.`</span>)<br>  &#125;  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\n-------------- Change Side ---------------`</span>)    <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>角色建立 player()  </p><ul><li>需含名稱、HP、MP、攻擊動作、治療動作  </li><li>練習不同的 function 使用方式(把 function 放進 function 裡)  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">player</span> (name, hp, mp) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: name,<br>    <span class="hljs-attr">hp</span>: hp,<br>    <span class="hljs-attr">mp</span>: mp,<br>    <span class="hljs-attr">cure</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">hp</span>) &#123;......&#125;,<br>    <span class="hljs-attr">attack</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">enemy</span>) &#123;......&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="解題流程"><a href="#解題流程" class="headerlink" title="解題流程"></a>解題流程</h4><ol><li>創建並輸出角色資料  </li><li>戰鬥開始(迴圈內容)  <ul><li>如果兩人都活著，則戰鬥開始，魔術師先攻，回合結束  </li><li>如果上回合戰士還活著，則攻守交換  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// create players</span><br><span class="hljs-keyword">const</span> warrior = <span class="hljs-title function_">player</span>(<span class="hljs-string">&#x27;Warrior&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>)<br><span class="hljs-keyword">const</span> magician = <span class="hljs-title function_">player</span>(<span class="hljs-string">&#x27;Magician&#x27;</span>, <span class="hljs-number">30</span> ,<span class="hljs-number">100</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(warrior)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(magician)<br><br><span class="hljs-comment">// start fight</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;-------------- Start Fight ---------------&#x27;</span>)<br><span class="hljs-keyword">while</span> (warrior.<span class="hljs-property">hp</span> &gt; <span class="hljs-number">0</span> &amp;&amp; magician.<span class="hljs-property">hp</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  magician.<span class="hljs-title function_">attack</span>(warrior)<br>  <span class="hljs-keyword">if</span> (warrior.<span class="hljs-property">hp</span> &gt; <span class="hljs-number">0</span>) &#123;    <br>    warrior.<span class="hljs-title function_">attack</span>(magician)<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;--------------- Game Over ----------------&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在重寫的過程中又發現了一些自己不熟的地方……寫物件的時候，居然把 key 跟 value 中間的 <code>:</code> 寫成 <code>=</code> 了!  </p><p>這題練習對我其實滿有效的，包含 <code>this</code> 跟 <code>return</code> 的使用時機，還有在函式裡呼叫函式的寫法(這部分讓我把 while 迴圈大改，在被攻擊的對象還活著的時候直接呼叫治療函式)。以自己覺得順暢的方式改完後，發現還是可以順利跑出相同結果，表示 function 目前的課程應該有一定程度的熟悉了!</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AlphaCamp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星座計算機</title>
      <link href="/posts/2fe737b2/"/>
      <url>/posts/2fe737b2/</url>
      
        <content type="html"><![CDATA[<p><strong>題目來源:</strong> Alpha Camp 學期 2-1 工作坊<br>在學習 function 的過程中，對於如何設計和應用只有模糊的概念。星座計算機是個規模較小的應用題，可以在不長的流程中清楚看出 fuction 的運作時機和傳回值的流向。透過 function 的使用，可以讓主程式碼盡可能地保持較乾淨的狀態。  </p><span id="more"></span><h2 id="解題工具"><a href="#解題工具" class="headerlink" title="解題工具"></a>解題工具</h2><ol><li>if statement  </li><li>function  </li><li>for 迭代</li><li>String.prototype.split(): 用特定字符將字串切割，並回傳切割後陣列。</li><li>Number(): 將 () 中參數型別轉換為數字。</li></ol><h2 id="題目要求"><a href="#題目要求" class="headerlink" title="題目要求"></a>題目要求</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul><li>給定一個日期(格式為 4&#x2F;1)，算出此日期對應星座。  </li><li>用 function 來創建資料。  </li><li>用 function 來簡化。  </li><li>(自己新增) 判斷輸入日期是否有誤(ex. 4&#x2F;35)。</li></ul><h3 id="課後挑戰–例外處理"><a href="#課後挑戰–例外處理" class="headerlink" title="課後挑戰–例外處理"></a>課後挑戰–例外處理</h3><p>摩羯座(12&#x2F;21 - 1&#x2F;19) 因為跨年度，和其他星座不同。試著分別用以下三種方式解決例外狀況。  </p><ol><li>專用判斷式 (大於1221 或 小於 119)  </li><li>排除法 (如果都沒找到，就是魔羯)  </li><li>改物件 (12&#x2F;21-12&#x2F;31 、 1&#x2F;1-1&#x2F;19)</li></ol><h2 id="解題過程"><a href="#解題過程" class="headerlink" title="解題過程"></a>解題過程</h2><p>原本看到題目的直覺反應是:  </p><ol><li>把使用者輸入的生日拆解成 “月” 和 “日” 兩個變數。  </li><li>把星座區間分成前後兩半(前月中到月底 + 後月初到月中)。  </li><li>用雙層 for 迴圈迭代 “月” 和 “日” ，將星座前、後兩半分別檢查一次，找出生日符合的區間。</li></ol><p>整體流程感覺很繁瑣……這時，助教提出一個建議: <strong>將所有日期(月+日)整個數值化，讓星座區間的前後半合併為一個數值的區間</strong> (如天秤 9&#x2F;23-10&#x2F;22 轉換為 923-1022的數字區間)。這樣就方便很多了，也解決了跨月份造成的雙層迴圈問題。  </p><h3 id="拆解流程"><a href="#拆解流程" class="headerlink" title="拆解流程"></a>拆解流程</h3><blockquote><ul><li>先思考整體大方向，寫出流程 1 ~ 5 大項。  </li><li>防呆措施: 加入 “判斷日期是否存在?” 功能。(加入流程3-1)  </li><li>如果比較 “月” 再比較 “日” ，判斷流程較繁複，所以轉換日期方便比較。 (加入流程3-2)  </li><li>依照題意用 function 簡化，預計分別為 1 、 3-1 、 3-2 設計 function 。</li></ul></blockquote><ol><li>建立星座資料  </li><li>使用者輸入生日  </li><li>拆解日期<br>3-1. 判斷日期是否存在?<br>3-2. 轉換日期以簡化判斷星座過程  </li><li>判斷星座  </li><li>輸出星座</li></ol><h3 id="解題開始"><a href="#解題開始" class="headerlink" title="解題開始"></a>解題開始</h3><blockquote><p>在進行解題時，寫出上述運作流程後，我會先進行一次反向思考。  </p><ol><li>星座判斷流程需要用到數值化後的日期 ➜ 從 function 日期數值化取得。  </li><li>判斷日期是否存在 及 function 日期數值化需要用「月」、「日」來轉換 ➜ 建立星座資料、使用者輸入資料都要將「月」、「日」拆開。</li><li>依照以上所需來設計變數代入 function 及其他解題流程裡。</li></ol></blockquote><h4 id="function-設計"><a href="#function-設計" class="headerlink" title="function 設計"></a>function 設計</h4><p>經過前面的流程拆解，可以開始設計 function 了。<br><strong>1. 日期數值化(將 9&#x2F;23 轉換為 923)</strong><br>   回傳值為: 將傳入的參數 m(月) 乘 100 再加 d(日)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// convert dateValue = month * 100 + date</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dateValue</span>(<span class="hljs-params">m, d</span>) &#123;<br>  <span class="hljs-keyword">return</span> m * <span class="hljs-number">100</span> + d<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 建立星座資料</strong><br>   日期數值化需要分別用到月和日，因此在設計 function 時，需要的參數有: 星座名、起始月、起始日、結束月、結束日。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// create Object for zodiac</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createZodiac</span>(<span class="hljs-params">name, startMonth, startDay, endMonth, endDay</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: name,<br>    <span class="hljs-attr">startDate</span>: <span class="hljs-title function_">dateValue</span>(startMonth, startDay),<br>    <span class="hljs-attr">endDate</span>: <span class="hljs-title function_">dateValue</span>(endMonth, endDay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 判斷日期是否存在?</strong><br>   判斷標準為: 2月最多29天，2月外小月最多30天，大月最多31天。<br>   功能: 日期存在則回傳日期，日期不存在則印出日期不存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dateExist</span>(<span class="hljs-params">m, d</span>) &#123;<br>  <span class="hljs-comment">// set date exist range</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Feb</span> = (d &lt;= <span class="hljs-number">29</span>)<br>  <span class="hljs-keyword">const</span> bigMonth = ((m &lt;= <span class="hljs-number">7</span>) &amp;&amp; (m % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) || (m &gt; <span class="hljs-number">7</span>) &amp;&amp; (m % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)) &amp;&amp; (d &lt;= <span class="hljs-number">31</span>)<br>  <span class="hljs-keyword">const</span> smallMonth = (m !== <span class="hljs-number">2</span>) &amp;&amp; ((m &lt;= <span class="hljs-number">7</span>) &amp;&amp; (m % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) || (m &gt; <span class="hljs-number">7</span>) &amp;&amp; (m % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>)) &amp;&amp; (d &lt;= <span class="hljs-number">30</span>)<br>  <span class="hljs-comment">// start</span><br>  <span class="hljs-keyword">if</span> ((d &gt;= <span class="hljs-number">1</span>) &amp;&amp; (<span class="hljs-title class_">Feb</span> || bigMonth || smallMonth)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dateValue</span>(m, d)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;生日不存在&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三種方式共同流程"><a href="#三種方式共同流程" class="headerlink" title="三種方式共同流程"></a>三種方式共同流程</h4><p><strong>1. 建立星座資料</strong><br>方式一、方式二都是將摩羯座當例外處理，因此這邊先不建立摩羯座資料。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// place to store info from function &#x27;createZodiac&#x27;</span><br><span class="hljs-keyword">const</span> zodiac = []<br><span class="hljs-comment">// use &#x27;createZodiac&#x27; push into zodiac</span><br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;牡羊&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>, <span class="hljs-number">4</span>, <span class="hljs-number">19</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;金牛&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;雙子&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">21</span>, <span class="hljs-number">6</span>, <span class="hljs-number">20</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;巨蟹&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>, <span class="hljs-number">22</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;獅子&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">23</span>, <span class="hljs-number">8</span>, <span class="hljs-number">22</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;處女&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>, <span class="hljs-number">9</span>, <span class="hljs-number">22</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;天秤&#x27;</span>, <span class="hljs-number">9</span>, <span class="hljs-number">23</span>, <span class="hljs-number">10</span>, <span class="hljs-number">22</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;天蠍&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">23</span>, <span class="hljs-number">11</span>, <span class="hljs-number">21</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;射手&#x27;</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">12</span>, <span class="hljs-number">21</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;水瓶&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">18</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;雙魚&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">19</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>))<br></code></pre></td></tr></table></figure><p><strong>2. 使用者輸入生日</strong>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// user input</span><br><span class="hljs-keyword">const</span> birthday = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;請輸入生日(格式:4/1): &#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>3. 拆解日期</strong>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> birthdayArray = birthday.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br><span class="hljs-keyword">const</span> birthdayMonth = <span class="hljs-title class_">Number</span>(birthdayArray[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">const</span> birthdayDay = <span class="hljs-title class_">Number</span>(birthdayArray[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">const</span> birthdayValue = <span class="hljs-title function_">dateExist</span>(birthdayMonth, birthdayDay)<br></code></pre></td></tr></table></figure><p>以上部分完成後，就可以依照三種方式分別進行判斷星座 &amp; 輸出結果了(<a href="#%E6%96%B9%E5%BC%8F%E4%B8%80">方式一</a>、<a href="#%E6%96%B9%E5%BC%8F%E4%BA%8C">方式二</a>、<a href="#%E6%96%B9%E5%BC%8F%E4%B8%89">方式三</a>)。</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p><strong>說明: 幫摩羯座設專用判斷式 (大於1221 或 小於 119)</strong><br>先用專用判斷式把摩羯座篩選出來，其他的則丟進迴圈裡迭代，找出符合的結果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> ((birthdayValue &lt;= <span class="hljs-number">119</span>) || (birthdayValue &gt;= <span class="hljs-number">1221</span>)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你是魔羯座&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; zodiac.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> startValue = zodiac[i].<span class="hljs-property">startDate</span><br>    <span class="hljs-keyword">const</span> endValue = zodiac[i].<span class="hljs-property">endDate</span><br>    <span class="hljs-keyword">if</span> ((birthdayValue &gt;= startValue) &amp;&amp;(birthdayValue &lt;= endValue)) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你是<span class="hljs-subst">$&#123;zodiac[i].name&#125;</span>座`</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#%E4%B8%89%E7%A8%AE%E6%96%B9%E5%BC%8F%E5%85%B1%E5%90%8C%E6%B5%81%E7%A8%8B">(回到共同流程)</a>  </p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p><strong>說明: 排除法 (如果都沒找到，就是魔羯)</strong><br>這個方法讓我卡最久……我的邏輯是: 如果迴圈有找到符合的結果，則印出結果； 如果沒有，則印出 ‘你是摩羯座’。<br>這種方法忽略了生日不存在的狀況，導致如果生日不存在，會同時印出 ‘生日不存在’ 及 ‘你是摩羯座’。<br>最後才想到加個 “如果 birthdayValue 有值” 的前提，成功跑出我要的結果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> answer = []<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; zodiac.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> ((birthdayValue &gt;= zodiac[i].<span class="hljs-property">startDate</span>) &amp;&amp; (birthdayValue &lt;= zodiac[i].<span class="hljs-property">endDate</span>)) &#123;  <br>    answer.<span class="hljs-title function_">push</span>(zodiac[i].<span class="hljs-property">name</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (birthdayValue) &#123;  <span class="hljs-comment">// 如果 birthdayValue 有值</span><br>  <span class="hljs-keyword">if</span> (answer.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你是<span class="hljs-subst">$&#123;answer[<span class="hljs-number">0</span>]&#125;</span>座`</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你是摩羯座&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#%E4%B8%89%E7%A8%AE%E6%96%B9%E5%BC%8F%E5%85%B1%E5%90%8C%E6%B5%81%E7%A8%8B">(回到共同流程)</a>  </p><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p><strong>方式說明:改物件 (12&#x2F;21-12&#x2F;31 、 1&#x2F;1-1&#x2F;19)</strong><br>須把摩羯座範圍拆開，並另外放進 zodiac 裡。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 把摩羯座拆開放進 zodiac 裡</span><br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;魔羯&#x27;</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>))<br>zodiac.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createZodiac</span>(<span class="hljs-string">&#x27;魔羯&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">19</span>))<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; zodiac.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> startValue = zodiac[i].<span class="hljs-property">startDate</span><br>  <span class="hljs-keyword">const</span> endValue = zodiac[i].<span class="hljs-property">endDate</span><br><br>  <span class="hljs-keyword">if</span> (birthdayValue &gt;= startValue &amp;&amp; birthdayValue &lt;= endValue) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你是<span class="hljs-subst">$&#123;zodiac[i].name&#125;</span>座`</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#%E4%B8%89%E7%A8%AE%E6%96%B9%E5%BC%8F%E5%85%B1%E5%90%8C%E6%B5%81%E7%A8%8B">(回到共同流程)</a></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>能成功用三種方法解出來實在很有成就感! 每次看到輸出結果跑出紅字就很頭大，還好他會提醒你到底是哪裡出錯，所以做後還是成功 debug 了!  </p><p>隨著作業規模變大，開始有感覺到難度。但是比起挫折感，更多的反而是 “我在確實進步” 的興奮!! 讓我在寫部落格的路上越來越有動力!</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AlphaCamp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 插件更新</title>
      <link href="/posts/d81b71f/"/>
      <url>/posts/d81b71f/</url>
      
        <content type="html"><![CDATA[<p>會寫這篇文章主要是因為收到了 hexo-server 插件的更新通知。隨著部落格功能的擴充，我安裝的 Hexo 插件越來越多，每個插件都會做各自的版本更新(還不同時間點)。一個一個分別更新好麻煩，然後懶人如我找到了個 npm 包可以直接幫我確認最新版本，再全部一起更新，多棒啊~~  </p><span id="more"></span><blockquote><p>本篇撰寫時 Hexo 版本如下，不同版本可能會有功能或設定方式上的差異!<br>Hexo 版本: hexo: 6.0.0<br>Hexo-server 版本: <strong>^2.0.0</strong> 升級到 <strong>^3.0.0</strong>  </p></blockquote><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>package.json 檔案， 定義專案所需要的各種模組，以及專案的配置資訊。<code>npm install</code> 命令根據這個配置檔案，自動下載所需的模組。打開 Hexo 專案根目錄的 package.json 檔案，就可以看到自己已經做了那些配置。  </p><p>關於 package.json 的詳細介紹，可參考 <a href="https://iter01.com/467432.html">草履蟲的思考 發表在 IT 人的文章</a>。裡面對 npm 及 package.json 有比較詳細的介紹，這裡就不贅述。</p><h2 id="用-npm-check-updates-更新插件"><a href="#用-npm-check-updates-更新插件" class="headerlink" title="用 npm-check-updates 更新插件"></a>用 npm-check-updates 更新插件</h2><p>在網路教學看到推薦用 <code>npm-check</code> 和 <code>npm-upgrade</code> 更新，但我實際安裝後都會報錯誤。後來我找到另外 npm 包，也是我這次更新 hexo-server 用的方式。  </p><blockquote><p><a href="https://github.com/raineorshine/npm-check-updates">npm-check-updates 官網</a><br><strong>npm-check-updates</strong> upgrades your package.json dependencies to the latest versions, ignoring specified versions.<br>看看這描述，多方便阿~</p></blockquote><p><strong>1. 使用方法非常簡單，只要先安裝 npm-check-updates</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g npm-check-updates    <span class="hljs-comment"># 安裝 npm-check-updates</span><br></code></pre></td></tr></table></figure><p><strong>2. 執行版本檢查&#x2F;更新指令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ncu           <span class="hljs-comment"># 檢查是否需要更新(npm-check-updates 第一個字母縮寫，很好記!)</span><br>ncu -u        <span class="hljs-comment"># 更新 package.json 資訊(upgrade縮寫)</span><br>npm install   <span class="hljs-comment"># 安裝新版本</span><br></code></pre></td></tr></table></figure><p>他會輸出一個版本檢查的畫面，並在最後一行指示下一步怎麼做。以我自己的畫面為例:  </p><ul><li>執行 <code>ncu</code> 會提供現有版本和最新版本的比較，並在最後一行用藍字提醒下一步要 更新 package.json。  </li><li>執行 <code>ncu -u</code> 更新 package.json 資訊，並在最後一行用藍字提醒下一步要安裝新版本。  </li><li>執行 <code>npm install</code> 後 再用 <code>ncu</code> 檢查一次，發現全部都是最新版本了。</li></ul><p><img src="/../../Blog-image/posts/2022-01-06_001.webp" alt="npm-check-updates20220106-001"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo NexT 主題更新</title>
      <link href="/posts/dbd33422/"/>
      <url>/posts/dbd33422/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇撰寫時 Hexo 及 NexT 版本如下，不同版本可能會有功能或設定方式上的差異!<br>Hexo 版本: hexo: 6.0.0<br>Next 版本: hexo-theme-next-<strong>8.8.2</strong> 升級到 <strong>8.9.0</strong></p></blockquote><span id="more"></span><p>NexT 官方團隊在收集一定數量 Bugfix &#x2F; Feature Request 的情況下，原則上會每月更新一次，可以先參考官方公布的版本更新內容再決定要不要更新。  </p><p>不過，更新通常是為了優化(<code>custom_file_path</code> 真的讓主題更新方便很多)、排除障礙或提高安全性，理論上可以有更好的使用體驗，所以如果有更新提醒我應該還是會盡快處理。  </p><p>另外，隨著技術的進步，舊有的方式可能會被淘汰(像是以前的 <code>.swig</code> 已被 <code>.njk</code> 替代)，為了避免跨大版本更新造成需要大幅度調整的麻煩，建議更新頻率不要太低。  </p><h2 id="近年-NexT-主題大改革"><a href="#近年-NexT-主題大改革" class="headerlink" title="近年 NexT 主題大改革"></a>近年 NexT 主題大改革</h2><p>如果查詢網路上較久以前的教學文章，會發現很多東西都跟新版本搭不起來了。以我自己建置部落格的過程和踩過的坑，感覺最大的變化如下:  </p><p><strong>1. Custom Files 用法(v7.3.0 啟用)</strong><br>以前要把 NexT 主題改得更有個人風格(ex.改背景、在文章底部加文字、增減頁腳文字…等)，都需要改動 <code>layout</code> 資料夾裡相對應的檔案原始碼。一旦進行版本更新，原本作好的設定被直接覆蓋，造成很多困擾。  </p><p>自啟用 Custom Files 用法後，所有的程式碼修改一律放在 <code>root\source\_data</code> 資料夾裡，只要到 <code>root\_config.next.yml</code> 設定讀取路徑就可以直接套用。因為設定檔不是放在主題資料夾內，就算版本更新也不造成影響。   </p><p><strong>2. Nunjucks 引擎(v7.4.2 啟用)</strong><br>網路上較久以前的教學文章，都會說要修改 <code>.swig</code> 檔，但我找半天都找不到，後來看官方文件才發現，因為 swig 缺乏维護，NexT 自 v7.4.2 開始，改用 Nunjucks 代替 swig 作为模版引擎，檔案類型變成 <code>.njk</code> ，網路上的教學文章已不適用。</p><h2 id="npm-安裝-官方推薦"><a href="#npm-安裝-官方推薦" class="headerlink" title="npm 安裝(官方推薦)"></a>npm 安裝(官方推薦)</h2><p><strong>主題資料夾位置: <code>root\node_modules\hexo-theme-next</code></strong><br>打開 <code>root\node_modules</code> 資料夾會發現，之前用 npm 安裝的各種插件都在這裡面。原則上這個資料夾的東西都不會手動修改，只用 npm 指令處理，後續用 npm 更新或解除安裝基本都是改動這裡。  </p><p>NexT 主題更新只要進到 Blog 的根目錄擇一執行以下指令即可。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-theme-next           <span class="hljs-comment"># 默認最新版本</span><br>npm install hexo-theme-next@latest    <span class="hljs-comment"># 安裝最新版本</span><br>npm install hexo-theme-next@8.9.0     <span class="hljs-comment"># 安裝指定版本</span><br></code></pre></td></tr></table></figure><p>更新完成後，參考更新說明。如果有想用的新功能，直接在 <code>root\_config.next.yml</code> 修改設定即可。</p><blockquote><p>如果沒有這個檔案，請參考<a href="/posts/ebe0f18a/">Hexo NexT 主題變更 &amp; 設定 </a> 章節 4.1 說明。</p></blockquote><h2 id="git-安裝-太久沒更新推薦"><a href="#git-安裝-太久沒更新推薦" class="headerlink" title="git 安裝(太久沒更新推薦)"></a>git 安裝(太久沒更新推薦)</h2><p><strong>主題資料夾位置: <code>root\themes\主題名稱資料夾</code></strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 根目錄<br>git <span class="hljs-built_in">clone</span> https://github.com/next-theme/hexo-theme-next.git themes/next<br></code></pre></td></tr></table></figure><p>我剛開始使用 NexT 主題時是使用這種方式(<del>因為搞不懂 npm 指令到底在背後執行什麼</del>)。看了各種網路教學作個人化設定，改動了不少 NexT 主題原始碼，然後因為跟 git 不熟，不小心整個覆蓋掉，整個重來得很崩潰(跑題了)。後來使用 npm 安裝各種插件習慣，且啟用 <code>custom_file_path</code> 後，覺得 npm 方式比較方便。  </p><p><strong>git 安裝推薦使用對象:</strong><br><strong>1. 有改動 NexT 主題原始碼，不想直接覆蓋的人。</strong><br>使用 <code>git pull</code> 等方式更新合併，主題必須加入版本控制。鑒於目前我跟 Git 還是很不熟，這裡就不多作說明。<br><strong>2. 太久沒更新，直接覆蓋可能會出現很多問題，需要大量調整的人。</strong><br>使用這種方法的人，可以在資料夾後加版本編號作新舊版區隔，等調整完成後，在 <code>root\_config.yml</code> 設定要套用哪個版本就可以了。  </p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驗證三角形</title>
      <link href="/posts/dca3ad45/"/>
      <url>/posts/dca3ad45/</url>
      
        <content type="html"><![CDATA[<p><strong>題目來源:</strong> Alpha Camp 學期一作業<br>學期一終於結束了，完成了課程決定挑戰選修的期末考來驗收學習成效， JavaScript 題目一如既往地燒腦有挑戰性，從前老愛跟數讀死槓的我超開心呀!! 寫出來爆有成就感啊!!</p><span id="more"></span><h2 id="解題工具"><a href="#解題工具" class="headerlink" title="解題工具"></a>解題工具</h2><ol><li>if statement  </li><li>prompt() 可以接受使用者的輸入，但回傳值為字串。  </li><li>Number() 可以將輸入的參數轉換為數值。如果參數沒辦法被轉換成數字，則它會回傳 NaN 。</li></ol><h2 id="基本題"><a href="#基本題" class="headerlink" title="基本題"></a>基本題</h2><h3 id="題目要求"><a href="#題目要求" class="headerlink" title="題目要求"></a>題目要求</h3><ol><li>請使用者分別輸入三角形的3個邊長  </li><li>幫助使用者確認「給定的三個邊長組成的三角形，是等邊、等腰還是不等邊三角形」</li></ol><h3 id="解題過程"><a href="#解題過程" class="headerlink" title="解題過程"></a>解題過程</h3><p><strong>大致流程為:</strong>  </p><ol><li>請使用者分別輸入三角形的3個邊長。  </li><li>判斷三角形是否成立?  </li><li>如果三角形成立，則判斷三角形種類。  </li><li>輸出結果。</li></ol><p><strong>流程虛擬碼</strong><br>依照上述流程，可以將虛擬碼依照思考邏輯寫出來，方便後續編寫程式碼。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sas">使用者輸入三角形邊長<br><span class="hljs-keyword">IF</span> 三角形成立(兩邊和需大於第三邊 <span class="hljs-variable">&amp;&amp;</span> 兩邊差需小於第三邊)<br>  <span class="hljs-keyword">IF</span> 三邊等長<br>    輸出:此為正三角形<br>  <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">IF</span> 其中兩邊等長<br>    輸出:此為等腰三角形<br>  <span class="hljs-keyword">ELSE</span> <br>    輸出:此為不等邊三角形<br><span class="hljs-keyword">ELSE</span> 輸出:三角形不成立<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 請使用者輸入三角形邊長</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Number</span>(<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;請輸入第一條三角形邊長 (a)&#x27;</span>))<br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">Number</span>(<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;請輸入第二條三角形邊長 (b)&#x27;</span>))<br><span class="hljs-keyword">let</span> c = <span class="hljs-title class_">Number</span>(<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;請輸入第三條三角形邊長 (c)&#x27;</span>))<br></code></pre></td></tr></table></figure><p><strong>接著要判斷三角形是否成立及三角形種類。</strong><br>因為直接把條件全部寫進 if&#x2F;else 判斷式會發現，整個判斷流程的程式碼非常冗長、不易閱讀，所以我先把判斷條件寫成 boolean 。後面整個 if&#x2F;else 判斷式只要 boolean 為 True 即可。(為了變數名稱還特別跑去查英文 😅)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 三角形成立規則</span><br><span class="hljs-keyword">let</span> isTriangle = (a + b &gt; c) &amp;&amp; (b + c &gt; a) &amp;&amp; (a + c &gt; b)  <span class="hljs-comment">// 兩邊和需大於第三邊</span><br>              &amp;&amp; (a - b &lt; c) &amp;&amp; (b - c &lt; a) &amp;&amp; (a - c &lt; b)  <span class="hljs-comment">// 兩邊差需小於第三邊</span><br><br><span class="hljs-comment">// 三角形種類條件</span><br><span class="hljs-keyword">let</span> isEquilateralTriangle = (a === b) &amp;&amp; (b === c)             <span class="hljs-comment">// 正三角形</span><br><span class="hljs-keyword">let</span> isIsoscelesTriangle = (a === b) || (b === c) || (a === c)  <span class="hljs-comment">// 等腰三角形</span><br></code></pre></td></tr></table></figure><p><strong>判斷開始</strong><br>接下來只要將判斷式依照虛擬碼寫出來即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判斷開始</span><br><span class="hljs-keyword">if</span> (isTriangle) &#123;<br>  <span class="hljs-keyword">if</span> (isEquilateralTriangle) &#123;  <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`三邊長為(<span class="hljs-subst">$&#123;a&#125;</span>, <span class="hljs-subst">$&#123;b&#125;</span>, <span class="hljs-subst">$&#123;c&#125;</span>)，此為&quot;正三角形&quot;`</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isIsoscelesTriangle) &#123;  <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`三邊長為(<span class="hljs-subst">$&#123;a&#125;</span>, <span class="hljs-subst">$&#123;b&#125;</span>, <span class="hljs-subst">$&#123;c&#125;</span>)，此為&quot;等腰三角形&quot;`</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`三邊長為(<span class="hljs-subst">$&#123;a&#125;</span>, <span class="hljs-subst">$&#123;b&#125;</span>, <span class="hljs-subst">$&#123;c&#125;</span>)，此為&quot;不等邊三角形&quot;`</span>)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`三邊長為(<span class="hljs-subst">$&#123;a&#125;</span>, <span class="hljs-subst">$&#123;b&#125;</span>, <span class="hljs-subst">$&#123;c&#125;</span>)，三角形不成立!!`</span>)<br>&#125;<br></code></pre></td></tr></table></figure><br/><br/><h2 id="進階題"><a href="#進階題" class="headerlink" title="進階題"></a>進階題</h2><h3 id="題目要求-1"><a href="#題目要求-1" class="headerlink" title="題目要求"></a>題目要求</h3><ol><li>在三邊之和小於等於 20 的情況下，找出所有的等腰三角形（不含正三角形）組合。  </li><li>輸出結果及等腰三角形數量</li></ol><h3 id="解題過程-1"><a href="#解題過程-1" class="headerlink" title="解題過程"></a>解題過程</h3><p><strong>大致流程為:</strong>  </p><ol><li>迴圈產出三角形邊長(其中兩邊等長)  </li><li>判斷三角形成立  </li><li>排除三邊之和大於20或正三角形  </li><li>輸出結果</li></ol><p><strong>先寫出虛擬碼</strong>  </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gcode">宣告找到等腰三角形起始組數為<span class="hljs-number">0</span><br><br>for 迴圈產出等腰邊長<span class="hljs-comment">(1 &lt;= a &lt;= 9)</span><br>  for 迴圈產出第<span class="hljs-number">3</span>邊長<span class="hljs-comment">(1 &lt;= c &lt;= 9)</span><br>    宣告條件變數<span class="hljs-comment">(三角形成立 &amp;&amp; 三邊之和大於20，並排除正三角形)</span><br>    <span class="hljs-keyword">if</span> 條件成立<br>      輸出等腰三角形邊長<br>      找到等腰三角形組數 <span class="hljs-number">+1</span><br>    else 跳過<br>  跳出迴圈<br>跳出迴圈<br>輸出找到等腰三角形的總組數<br></code></pre></td></tr></table></figure><p><strong>接著設定條件: 三角形成立、三邊之和大於20，並排除正三角形。</strong>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> isTriangle = (a + a &gt; c) &amp;&amp; (a + c &gt; a) &amp;&amp; (a + c &gt; a)  <span class="hljs-comment">// 兩邊和小於第三邊</span><br>              &amp;&amp; (a - a &lt; c) &amp;&amp; (a - c &lt; a) &amp;&amp; (a - c &lt; a)  <span class="hljs-comment">// 兩邊差大於第三邊</span><br><span class="hljs-keyword">let</span> isIsoscelesTriangle = (a + a + c &lt;= <span class="hljs-number">20</span>) &amp;&amp; (a !== c)    <span class="hljs-comment">// 三邊之和大於20，並排除正三角形</span><br></code></pre></td></tr></table></figure><p><strong>寫出 for 迴圈及判斷式</strong>  </p><ol><li>因為等腰三角形 (a &#x3D;&#x3D;&#x3D; b) ，所以不另外設變數 b ，直接以 a 取代。  </li><li>讓 a 、 c 從小往大迭代，避免重複情況發生。  </li><li>迭代產出三邊長 (a, a, c) 後進入條件判斷。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 找到等腰三角形起始組數為0</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>  <br><br><span class="hljs-comment">// 迴圈開始</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>; a &lt;= <span class="hljs-number">9</span> ; a++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">1</span>; c &lt;= <span class="hljs-number">9</span> ; c++) &#123;<br>    <span class="hljs-comment">// 設置條件</span><br>    <span class="hljs-keyword">let</span> isTriangle = (a + a &gt; c) &amp;&amp; (a + c &gt; a) &amp;&amp; (a + c &gt; a)  <span class="hljs-comment">// 兩邊和小於第三邊</span><br>                  &amp;&amp; (a - a &lt; c) &amp;&amp; (a - c &lt; a) &amp;&amp; (a - c &lt; a)  <span class="hljs-comment">// 兩邊差大於第三邊</span><br>    <span class="hljs-keyword">let</span> isIsoscelesTriangle = (a + a + c &lt;= <span class="hljs-number">20</span>) &amp;&amp; (a !== c)    <span class="hljs-comment">// 三邊之和大於20，並排除正三角形</span><br><br>    <span class="hljs-comment">// 判斷開始</span><br>    <span class="hljs-keyword">if</span> (isTriangl &amp;&amp; isIsoscelesTriangle) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`發現等腰三角形，三邊長分別為 (<span class="hljs-subst">$&#123;a&#125;</span>, <span class="hljs-subst">$&#123;a&#125;</span>, <span class="hljs-subst">$&#123;c&#125;</span>) `</span>)<br>      count++<br>    &#125;    <br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`共找到<span class="hljs-subst">$&#123;count&#125;</span>組等腰三角形!`</span>)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AlphaCamp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo NexT 文末感謝閱讀提示</title>
      <link href="/posts/670011ce/"/>
      <url>/posts/670011ce/</url>
      
        <content type="html"><![CDATA[<p>又犯了”看到別人的部落格有，我也想試試看的”毛病 😅 找了很多網路教學，發現基本都會修改到 NexT 的原始檔案，這對後面的版本更新很不利，所以決定自己改改看!  </p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在看了網路教學把部落格增加了很多功能後，有一次不小心覆蓋了原始檔案，然後就部落格”主題初始化”了。因為之前都是照著別人的教學直接去修改主題檔案的原始碼，根本記不得是改了哪個路徑的哪個檔案，也不記得改了那一大堆原始碼裡的哪一段。所以我連想重做一次都很難，要重新找一次教學，想哭……  </p><p>仔細看了 NexT 團隊提供的說明，他們有提出: 為了避免發生我這種狀況，建議大家在做功能修改時，盡可能不要改動原始檔案，而是利用 <code>custom_file_path</code> 新建設定檔案套用，會讓 NexT 主題在版本更新時可以更無痛升級。  </p><p>研究一下網路教學的程式碼結構，發現就是把基本的 HTML 、 CSS 套進 Nunjucks 的模板裡而已。成功試出來後，趕快把修改步驟記錄下來，讓自己以後魔改時參考。</p><h2 id="Custom-Files-用法"><a href="#Custom-Files-用法" class="headerlink" title="Custom Files 用法"></a>Custom Files 用法</h2><blockquote><p>本篇設定的 Hexo 及 NexT 版本如下，不同版本可能會有功能或設定方式上的差異!<br>Hexo 版本: hexo: 6.0.0<br>Next 版本: hexo-theme-next-8.8.2  </p></blockquote><p>在不改變 NexT 原始檔的情況下，只要在 <code>root\source\_data</code> 中新建並編輯相關檔案，即可直接覆蓋 NexT 原始設定。使用 Custom Files 的好處:</p><ol><li>後續如果 NexT 有版本升級可直接完全覆蓋，已做好的個人化設定不受影響。</li><li>可以直接在 Custom Files 管理所有的個人化修改。</li></ol><h2 id="修改步驟"><a href="#修改步驟" class="headerlink" title="修改步驟"></a>修改步驟</h2><blockquote><p>本文的 NexT 主題 config 一律採用 <code>root\_config.next.yml</code> 方式設定，請參考<a href="https://ritachien.github.io/posts/ebe0f18a/#config-next-yml-%E8%A8%AD%E5%AE%9A" title=" config.next.yml 設定 " target="_blank" > config.next.yml 設定 </a>說明。</p></blockquote><h3 id="新建-Custom-File"><a href="#新建-Custom-File" class="headerlink" title="新建 Custom File"></a>新建 Custom File</h3><ol><li>修改 <code>root\_config.next.yml</code> 設定，把 <code>postBodyEnd</code> 取消註解。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">custom_file_path:</span><br>  <span class="hljs-attr">postBodyEnd:</span> <span class="hljs-string">source/_data/post-body-end.njk</span><br></code></pre></td></tr></table></figure></li><li>在 <code>root\source\_data</code> 新增 <code>post-body-end.njk</code> 檔案。post-body-end 指的就是每篇文章最後的位置。</li></ol><h3 id="簡單版-直接寫入要顯示的文字"><a href="#簡單版-直接寫入要顯示的文字" class="headerlink" title="簡單版(直接寫入要顯示的文字)"></a>簡單版(直接寫入要顯示的文字)</h3><ol><li>將文字、樣式、模板寫進 <code>post-body-end.njk</code> 檔案。  <figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- 在文章底部添加感謝閱讀 --&gt;</span>        # 說明修改目的，方便後續維護</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> not is_index and theme.end_info.enable %&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align:center;color: #ccc;font-size:14px;letter-spacing: 5px&quot;</span>&gt;</span></span><br><span class="language-xml">      ----------------  本文結束  <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-paw&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>  感謝您的閱讀  -----------------</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li>新增 <code>root\_config.next.yml</code> 設定，開啟 <code>end_info</code> 功能。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">end_info:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="進階版-要顯示文字在-root-config-next-yml-中修改"><a href="#進階版-要顯示文字在-root-config-next-yml-中修改" class="headerlink" title="進階版(要顯示文字在 root\_config.next.yml 中修改)"></a>進階版(要顯示文字在 <code>root\_config.next.yml</code> 中修改)</h3><ol><li>將文字、樣式、模板寫進 <code>post-body-end.njk</code> 檔案。  <figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 在文章底部添加感謝閱讀 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  &#123;% if not is_index and theme.end_info.enable %&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align:center; color:#ccc; font-size:14px; letter-spacing:5px&quot;</span>&gt;</span></span><br><span class="language-xml">      </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">theme.end_info.start_info</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">theme.end_info.icon</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">theme.end_info.end_info</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  &#123;% endif %&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li>新增 <code>root\_config.next.yml</code> 設定，開啟 <code>end_info</code> 功能。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">end_info:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>                                 <span class="hljs-comment"># 開啟功能</span><br>  <span class="hljs-attr">start_info:</span> <span class="hljs-string">&#x27;----------------  本文結束&#x27;</span>      <span class="hljs-comment"># 起始文字</span><br>  <span class="hljs-attr">icon:</span> <span class="hljs-string">fa</span> <span class="hljs-string">fa-paw</span>                              <span class="hljs-comment"># icon 編碼</span><br>  <span class="hljs-attr">end_info:</span> <span class="hljs-string">&#x27;感謝您的閱讀  -----------------&#x27;</span>   <span class="hljs-comment"># 結束文字</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="修改程式碼說明"><a href="#修改程式碼說明" class="headerlink" title="修改程式碼說明"></a>修改程式碼說明</h2><p>這次的進階版是自己琢磨出來的，將撰寫規則筆記下來，方便後續修改並維護。  </p><h3 id="Nunjucks-模板啟用"><a href="#Nunjucks-模板啟用" class="headerlink" title="Nunjucks 模板啟用"></a>Nunjucks 模板啟用</h3><p>不同條件使用 <code>and</code> 連接即可。</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> not is_index and theme.end_info.enable %&#125;</span><span class="language-xml"></span><br><span class="language-xml">  # 中間填入符合條件後要執行的東西</span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><ol><li><p><code>if not is_index</code><br>觀察 Hexo 結構可以發現，除了 <code>_posts</code> 是由各個不同標題的 <code>.md</code> 檔組成，其他如: 標籤、分類、404、歸檔…等資料夾都只有 <code>index.md</code>。所以如果只要在非 index 頁面啟用，可加上此條件。</p></li><li><p><code>theme.end_info.enable</code><br>上面這段的意思是: 如果 theme 的 config 檔中， end_info 設定裡的 enable 值為 True 時啟用。<br>其中， theme 在 <code>root\config.yml</code> 中已設定為 next ，所以他會直接到 <code>root\_config.next.yml</code> 尋找 end_info 的設定值。</p></li></ol><h3 id="從-theme-config-中抓取資料"><a href="#從-theme-config-中抓取資料" class="headerlink" title="從 theme config 中抓取資料"></a>從 theme config 中抓取資料</h3><p>從 theme config 裡 end_info 設定中抓取不同項目的值。參考進階版第二步驟的設定項目。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">theme.end_info.start_info</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">theme.end_info.icon</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">theme.end_info.end_info</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="CSS-樣式設定"><a href="#CSS-樣式設定" class="headerlink" title="CSS 樣式設定"></a>CSS 樣式設定</h3><p>在 style&#x3D;”” 中填入 CSS 樣式，可自行搜尋可填入的值或其他樣式。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;text-align:center; color:#ccc; font-size:14px; letter-spacing:5px&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><ol><li>對齊方式(text-align)  </li><li>字體顏色(color)  </li><li>字體大小(font-size)  </li><li>字元間距(letter-spacing)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
            <tag> CSS </tag>
            
            <tag> Nunjucks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Hexo-abbrlink 產生永久連結</title>
      <link href="/posts/d8dab675/"/>
      <url>/posts/d8dab675/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因為是在建置部落格的同時整理並撰寫 Hexo 筆記，內容的更動導致常常需要修改多篇文章的檔名，permalink 自動產生網址的設定也連帶造成了我一些困擾，所以想用 Hexo-abbrlink 來一勞永逸。  </p><span id="more"></span><p>我原本 permalink 的設定是直接從檔名產生網址。網路上的教學建議檔案用日期 + 英文標題命名，所以修改的同時也讓同一篇文章的網址不斷改動。  </p><blockquote><p>備註: 建議檔案用日期 + 英文標題命名原因  </p><ol><li>日期方便作檔案排序。  </li><li>中文網址在台灣及大陸外的地區必須以編碼方式來呈現， URL 被轉碼後會變得很長(長得像亂碼)，這對 SEO 來說也較為不利。</li></ol></blockquote><h2 id="使用-Hexo-abbrlink-的好處"><a href="#使用-Hexo-abbrlink-的好處" class="headerlink" title="使用 Hexo-abbrlink 的好處"></a>使用 Hexo-abbrlink 的好處</h2><p><strong>1. 網址固定，不再因修改檔名或日期變動</strong><br>Hexo-abbrlink 會依照文章標題產生永久連結，並保存在 Front-matter (檔案最上方以 — 分隔的區域)，之後即使更改檔名也不會再變動。<br><img src="/../../Blog-image/posts/2021-12-27_001.webp" alt="abbrlink存入Front-matter20211227-001"></p><blockquote><p>舊文章(已經部署)會在下一次 <code>hexo g</code> 時產生 abbrlink 。<br>新文章(還沒部署)會在 <code>hexo s</code> 時就產生 abbrlink 。  </p></blockquote><p><strong>2. 檔名可依自己方便取了</strong><br><del>再也不用想英文標題了!!</del>  </p><p><strong>3. 降低因網址變動產生的404問題</strong><br>據說404錯誤會影響網站在SEO上的排名，讓其他人較不容易搜尋到自己的頁面。  </p><h2 id="安裝-hexo-abbrlink"><a href="#安裝-hexo-abbrlink" class="headerlink" title="安裝 hexo-abbrlink"></a>安裝 hexo-abbrlink</h2><blockquote><p>本篇設定的 Hexo 及 NexT 版本如下，不同版本可能會有功能或設定方式上的差異!<br>Hexo 版本: hexo: 6.0.0<br>Next 版本: hexo-theme-next-8.8.2  </p></blockquote><p><strong>1. 安裝套件</strong>  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-abbrlink <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p><strong>2. 修改 <code>root\_config.yml</code> 文件</strong>  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">permalink:</span> <span class="hljs-string">posts/:abbrlink/</span><br><span class="hljs-attr">abbrlink:</span><br>  <span class="hljs-attr">alg:</span> <span class="hljs-string">crc32</span>  <span class="hljs-comment"># support crc16(default) and crc32</span><br>  <span class="hljs-attr">rep:</span> <span class="hljs-string">hex</span>    <span class="hljs-comment"># support dec(default) and hex</span><br></code></pre></td></tr></table></figure><ul><li>也可以自己修改 permalink 參數(把 post 刪掉或增減其他參數)</li><li><code>alg</code> 是雜湊編碼產生方式， <code>rep</code> 是雜湊編碼表示方式(預設十進位)，兩種參數的搭配結果如下:<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">crc16 &amp; hex    https:<span class="hljs-regexp">//</span>XXXX.com<span class="hljs-regexp">/posts/</span><span class="hljs-number">66</span>c8/<br>crc16 &amp; dec    https:<span class="hljs-regexp">//</span>XXXX.com<span class="hljs-regexp">/posts/</span><span class="hljs-number">65535</span>/<br>crc32 &amp; hex    https:<span class="hljs-regexp">//</span>XXXX.com<span class="hljs-regexp">/posts/</span><span class="hljs-number">8</span>ddf18fb/<br>crc32 &amp; dec    https:<span class="hljs-regexp">//</span>XXXX.com<span class="hljs-regexp">/posts/</span><span class="hljs-number">1690090958</span>/<br></code></pre></td></tr></table></figure></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://github.com/rozbo/hexo-abbrlink">rozbo&#x2F;hexo-abbrlink README.md 文件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo NexT 主題變更 &amp; 設定</title>
      <link href="/posts/ebe0f18a/"/>
      <url>/posts/ebe0f18a/</url>
      
        <content type="html"><![CDATA[<p>基本設定都做好了，文章也成功發佈了，接下來該找個美美的主題幫部落格換個新衣服。我最後找了看起來簡約大方的 NexT 主題，持續都有在作版本更新，開源資源也很多，看到各種大神把基本款改成高級訂製款，除了框架根本看不出原樣，覺得超厲害!  </p><span id="more"></span><p>這篇只是把當初的建置過程記錄下來，萬一忘記或發生什麼問題，至少還知道原本是怎麼作出來的。如果有從頭開始的人，參考這篇照著做應該可以略過不少我踩過的坑。  </p><p>項目有點多(原則上是照著 NexT 的 <code>_config.yml</code> 檔順序寫的)，如果只是想找特定功能設定的，可以直接從左側目錄欄或 <code>Ctrl+F</code> 跳到需要的位置就好。如果在這篇裡沒有找到，那就要等我陸續整理出來再更新新文章了(前提是我有用到的功能才有辦法!)  </p><h2 id="NexT-主題選擇"><a href="#NexT-主題選擇" class="headerlink" title="NexT 主題選擇"></a>NexT 主題選擇</h2><p>現在網路上可以找到兩種版本的 NexT 主題，分別是 <a href="https://github.com/next-theme/hexo-theme-next">next-theme</a> 和 <a href="https://github.com/theme-next/hexo-theme-next">theme-next</a> 提供的。爬了討論串後發現，因為 theme-next 團隊的 owner 始终拒绝向其它團隊成員提供足夠的權限，且 owner 本人自 2019 年 10 月起已長期不在線，導致其他團隊成員無法管理倉庫，所以其中一個主要貢獻者只好搬家，並用 next-theme 繼續提供更新版本。</p><ul><li><a href="https://theme-next.js.org/">next-theme 官方網站</a></li></ul><blockquote><p>本篇設定的 Hexo 及 NexT 版本如下，不同版本可能會有功能或設定方式上的差異!<br>Hexo 版本: hexo: 6.0.0<br>Next 版本: hexo-theme-next-8.8.2  </p></blockquote><h2 id="主題安裝"><a href="#主題安裝" class="headerlink" title="主題安裝"></a>主題安裝</h2><h3 id="npm-安裝-推薦"><a href="#npm-安裝-推薦" class="headerlink" title="npm 安裝(推薦)"></a>npm 安裝(推薦)</h3><p><strong>主題資料夾位置: <code>root\node_modules\hexo-theme-next</code></strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 根目錄<br>npm install hexo-theme-next    <span class="hljs-comment"># 默認最新版本</span><br></code></pre></td></tr></table></figure><h3 id="git-安裝"><a href="#git-安裝" class="headerlink" title="git 安裝"></a>git 安裝</h3><p><strong>主題資料夾位置: <code>root\themes\next</code></strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 進入根目錄</span><br><span class="hljs-built_in">cd</span> 根目錄<br><br><span class="hljs-comment"># 從網址複製檔案到 themes 裡的 next 資料夾裡(沒有的話會自動新建)</span><br>git <span class="hljs-built_in">clone</span> https://github.com/next-theme/hexo-theme-next.git themes/next<br></code></pre></td></tr></table></figure><p><img src="/../../Blog-image/posts/2021-12-26_001.webp" alt="複製倉庫網址20211226-001">  </p><h2 id="主題套用"><a href="#主題套用" class="headerlink" title="主題套用"></a>主題套用</h2><p>修改 <code>root\_config.yml</code> 裡的主題設定。  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">next</span>     <span class="hljs-comment"># 預設值為 landscape</span><br></code></pre></td></tr></table></figure><h2 id="個人化調整"><a href="#個人化調整" class="headerlink" title="個人化調整"></a>個人化調整</h2><h3 id="config-next-yml-設定"><a href="#config-next-yml-設定" class="headerlink" title="_config.next.yml 設定"></a>_config.next.yml 設定</h3><p>根據 next-theme 官方說明(<a href="https://github.com/next-theme/hexo-theme-next/issues/4">【必讀】更新說明及常見問題</a>)建議:<br>為了避免更新出現衝突，使用 Hexo 官方支持的 <code>root\_config.next.yml</code> 方式做主題個人化設定。</p><ol><li>確保使用 Hexo 5.0 以上的版本。</li><li>複製 <code>主題資料夾\_config.yml</code> 檔案重新命名並移到根目錄 <code>root\_config.next.yml</code> 。<br/></li></ol><h3 id="樣式選擇"><a href="#樣式選擇" class="headerlink" title="樣式選擇"></a>樣式選擇</h3><p>四選一，把想要的樣式註解取消，可以存檔後用 <code>hexo s</code> 看看差別再決定。我的 Blog 是用 Gemini 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Schemes</span><br><span class="hljs-comment">#scheme: Muse</span><br><span class="hljs-comment">#scheme: Mist</span><br><span class="hljs-comment">#scheme: Pisces</span><br><span class="hljs-attr">scheme:</span> <span class="hljs-string">Gemini</span><br></code></pre></td></tr></table></figure><h3 id="網站圖示變更"><a href="#網站圖示變更" class="headerlink" title="網站圖示變更"></a>網站圖示變更</h3><p>圖片路徑: <code>主題資料夾\source\images</code> ，變更檔名即可。  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">favicon:</span><br>  <span class="hljs-attr">small:</span> <span class="hljs-string">/images/favicon-16x16-next.png</span><br>  <span class="hljs-attr">medium:</span> <span class="hljs-string">/images/favicon-32x32-next.png</span><br>  <span class="hljs-attr">apple_touch_icon:</span> <span class="hljs-string">/images/apple-touch-icon-next.png</span><br>  <span class="hljs-attr">safari_pinned_tab:</span> <span class="hljs-string">/images/logo.svg</span><br>  <span class="hljs-comment">#android_manifest: /manifest.json</span><br></code></pre></td></tr></table></figure><h3 id="版權聲明"><a href="#版權聲明" class="headerlink" title="版權聲明"></a>版權聲明</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Creative Commons 4.0 International License.</span><br><span class="hljs-comment"># See: https://creativecommons.org/about/cclicenses/</span><br><span class="hljs-attr">creative_commons:</span><br>  <span class="hljs-comment"># Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero</span><br>  <span class="hljs-attr">license:</span> <span class="hljs-string">by-nc-sa</span><br>  <span class="hljs-comment"># Available values: big | small</span><br>  <span class="hljs-attr">size:</span> <span class="hljs-string">small</span>          <span class="hljs-comment"># 圖示大小</span><br>  <span class="hljs-attr">sidebar:</span> <span class="hljs-literal">false</span>       <span class="hljs-comment"># 在 sidebar 顯示</span><br>  <span class="hljs-attr">post:</span> <span class="hljs-literal">true</span>           <span class="hljs-comment"># 在文章最下方顯示</span><br></code></pre></td></tr></table></figure><h3 id="menu-選單設定"><a href="#menu-選單設定" class="headerlink" title="menu 選單設定"></a>menu 選單設定</h3><p>把想要的樣式註解取消。<br>NexT 有支援 font awesome ，所以可以找喜歡的 icon 直接做替換。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">menu</span><br>  <span class="hljs-attr">home:</span> <span class="hljs-string">/</span> <span class="hljs-string">||</span> <span class="hljs-string">fa</span> <span class="hljs-string">fa-home</span>                        <span class="hljs-comment"># 首頁</span><br>  <span class="hljs-comment">#about: /about/ || fa fa-user                # 關於</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">/tags/</span> <span class="hljs-string">||</span> <span class="hljs-string">fa</span> <span class="hljs-string">fa-tags</span>                   <span class="hljs-comment"># 標籤</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-string">/categories/</span> <span class="hljs-string">||</span> <span class="hljs-string">fa</span> <span class="hljs-string">fa-th</span>         <span class="hljs-comment"># 分類</span><br>  <span class="hljs-attr">archives:</span> <span class="hljs-string">/archives/</span> <span class="hljs-string">||</span> <span class="hljs-string">fa</span> <span class="hljs-string">fa-archive</span>        <span class="hljs-comment"># 歸檔</span><br>  <span class="hljs-comment">#schedule: /schedule/ || fa fa-calendar      # 時間表</span><br>  <span class="hljs-attr">sitemap:</span> <span class="hljs-string">/sitemap.xml</span> <span class="hljs-string">||</span> <span class="hljs-string">fa</span> <span class="hljs-string">fa-sitemap</span>       <span class="hljs-comment"># 網站地圖(SEO)</span><br>  <span class="hljs-comment">#commonweal: /404/ || fa fa-heartbeat        # 公益404</span><br><br><span class="hljs-attr">menu_settings:</span><br>  <span class="hljs-attr">icons:</span> <span class="hljs-literal">true</span>             <span class="hljs-comment"># 顯示 menu 圖示</span><br>  <span class="hljs-attr">badges:</span> <span class="hljs-literal">false</span>           <span class="hljs-comment"># 顯示項目內數量</span><br></code></pre></td></tr></table></figure><h3 id="側欄設定"><a href="#側欄設定" class="headerlink" title="側欄設定"></a>側欄設定</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sidebar:</span><br>  <span class="hljs-comment"># Sidebar Position.</span><br>  <span class="hljs-attr">position:</span> <span class="hljs-string">left</span>       <span class="hljs-comment"># 設定左邊或右邊顯示</span><br>  <span class="hljs-comment">#position: right</span><br></code></pre></td></tr></table></figure><h3 id="頭像設定"><a href="#頭像設定" class="headerlink" title="頭像設定"></a>頭像設定</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">avatar:</span>                             <span class="hljs-comment"># sidebar 內頭像設定</span><br>  <span class="hljs-attr">url:</span> <span class="hljs-string">/images/avatar.jpg</span>           <span class="hljs-comment"># 預設路徑: `主題資料夾\source\images` (可改貼圖片連結)</span><br>  <span class="hljs-attr">rounded:</span> <span class="hljs-literal">true</span>                     <span class="hljs-comment"># true (圓形)/ false(方形)</span><br>  <span class="hljs-attr">rotated:</span> <span class="hljs-literal">false</span>                    <span class="hljs-comment"># 滑鼠點擊旋轉動畫</span><br></code></pre></td></tr></table></figure><h3 id="社群設定"><a href="#社群設定" class="headerlink" title="社群設定"></a>社群設定</h3><ol><li>把想要顯示的項目註解取消。  </li><li>NexT 有支援 font awesome ，所以可以找喜歡的 icon 直接做替換。  </li><li>連結記得改成自己的連結網址。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">social:</span><br>  <span class="hljs-attr">GitHub:</span> <span class="hljs-string">https://github.com/yourname</span> <span class="hljs-string">||</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-github</span><br>  <span class="hljs-attr">E-Mail:</span> <span class="hljs-string">mailto:yourname@gmail.com</span> <span class="hljs-string">||</span> <span class="hljs-string">fa</span> <span class="hljs-string">fa-envelope</span><br>  <span class="hljs-comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span><br>  <span class="hljs-comment"># 以下省略......</span><br><br><span class="hljs-attr">social_icons:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>              <span class="hljs-comment"># 社群連結圖示</span><br>  <span class="hljs-attr">icons_only:</span> <span class="hljs-literal">true</span>          <span class="hljs-comment"># 只顯示圖示不顯示名稱</span><br>  <span class="hljs-attr">transition:</span> <span class="hljs-literal">false</span>         <span class="hljs-comment"># 滑動到社群鏈結時的有轉場效果</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="側欄目錄設定-閱讀文章時"><a href="#側欄目錄設定-閱讀文章時" class="headerlink" title="側欄目錄設定(閱讀文章時)"></a>側欄目錄設定(閱讀文章時)</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">toc:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>         <span class="hljs-comment"># 在側欄自動生成並顯示文章目錄(依標題層級)</span><br>  <span class="hljs-attr">number:</span> <span class="hljs-literal">true</span>         <span class="hljs-comment"># 幫文章目錄自動編號</span><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">false</span>          <span class="hljs-comment"># 標題超出欄寬整行換行</span><br>  <span class="hljs-attr">expand_all:</span> <span class="hljs-literal">True</span>     <span class="hljs-comment"># 展開所有目錄層級 (false 僅展開當前位置目錄)</span><br>  <span class="hljs-attr">max_depth:</span> <span class="hljs-number">6</span>         <span class="hljs-comment"># 最大目錄層級數</span><br></code></pre></td></tr></table></figure><h3 id="頁腳設定"><a href="#頁腳設定" class="headerlink" title="頁腳設定"></a>頁腳設定</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-attr">since:</span> <span class="hljs-number">2021</span>              <span class="hljs-comment"># 指定網站開始年，若沒指定則顯示當下年度</span><br>  <span class="hljs-attr">icon:</span>                    <span class="hljs-comment"># 年度和版權資訊中間的 icon</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">fa</span> <span class="hljs-string">fa-heart</span>      <span class="hljs-comment"># Font Awesome 的 icon 代號</span><br>    <span class="hljs-attr">animated:</span> <span class="hljs-literal">false</span>        <span class="hljs-comment"># 開啟圖示動畫</span><br>    <span class="hljs-attr">color:</span> <span class="hljs-string">&quot;#ff0000&quot;</span>       <span class="hljs-comment"># 用16進位色碼改變 icon 顏色</span><br>  <span class="hljs-attr">copyright:</span>               <span class="hljs-comment"># 若沒指定則套用 Hexo `_config.yml` 的作者名</span><br>  <span class="hljs-attr">powered:</span> <span class="hljs-literal">False</span>           <span class="hljs-comment"># 顯示 Powered by Hexo &amp; NexT</span><br></code></pre></td></tr></table></figure><h3 id="摘要及-Read-More-功能"><a href="#摘要及-Read-More-功能" class="headerlink" title="摘要及 Read More 功能"></a>摘要及 Read More 功能</h3><p>首頁預設顯示文章全文，如果希望每篇文章像瀏覽卡片一樣僅提供部分摘要，點擊文章標題再打開全文，官方提供兩種方式( <code>&lt;!-- more --&gt;</code> 或 <code>excerpt_description</code>)，這裡僅說明官方推薦的方式:  </p><ul><li>在文章中使用 <code>&lt;!-- more --&gt;</code> 手動進行截斷，首頁預覽只會顯示到 <code>&lt;!-- more --&gt;</code> 前的文字。<br><img src="/../../Blog-image/posts/2021-12-26_002.webp" alt="read more20211226-002">  </li><li>完成以上設定後，首頁只看得到摘要，點擊文章標題進入內文。如果希望新增”閱讀全文”按鈕，則修改 <code>root\_config.next.yml</code> 設定值  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">read_more_btn:</span> <span class="hljs-literal">true</span>             <span class="hljs-comment"># 開啟&quot;閱讀全文&quot;按鈕</span><br></code></pre></td></tr></table></figure><blockquote><p>點擊”文章標題”和點擊”閱讀全文”的差異:<br>文章標題: 從頁首標題開始顯示文章頁面。<br>點擊閱讀全文: 跳至 <code>&lt;!-- more --&gt;</code> 後段落顯示文章頁面。</p></blockquote></li></ul><h3 id="文章的-Front-matter-在首頁的顯示設定"><a href="#文章的-Front-matter-在首頁的顯示設定" class="headerlink" title="文章的 Front-matter 在首頁的顯示設定"></a>文章的 Front-matter 在首頁的顯示設定</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_meta:</span><br>  <span class="hljs-attr">item_text:</span> <span class="hljs-literal">false</span>        <span class="hljs-comment"># 顯示項目文字</span><br>  <span class="hljs-attr">created_at:</span> <span class="hljs-literal">true</span>        <span class="hljs-comment"># 顯示發佈日期</span><br>  <span class="hljs-attr">updated_at:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>          <span class="hljs-comment"># 開啟顯示更新日期功能</span><br>    <span class="hljs-attr">another_day:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># 僅在發佈日和更新日不同時顯示更新日期</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-literal">true</span>        <span class="hljs-comment"># 顯示文章分類</span><br></code></pre></td></tr></table></figure><h3 id="添加文章字數與所需閱讀時間"><a href="#添加文章字數與所需閱讀時間" class="headerlink" title="添加文章字數與所需閱讀時間"></a>添加文章字數與所需閱讀時間</h3><p>試過 <code>hexo-symbols-count-time</code> 和 <code>hexo-wordcount</code> 兩樣插件，但是有幾篇文章不明原因沒辦法計算字數。原本打算放棄這個功能了，幸好在 next-theme 的 Repository 裡找到他們提供的插件 <a href="https://github.com/next-theme/hexo-word-counter">hexo-word-counter</a> ，測試過後確定沒有問題。  </p><p>安裝套件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-word-counter<br>hexo clean<br></code></pre></td></tr></table></figure><p>修改 <code>root\_config.yml</code> 設定值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">symbols_count_time:</span><br>  <span class="hljs-attr">symbols:</span> <span class="hljs-literal">true</span>                 <span class="hljs-comment"># 文章字數統計顯示</span><br>  <span class="hljs-attr">time:</span> <span class="hljs-literal">true</span>                    <span class="hljs-comment"># 文章閱讀時間顯示</span><br>  <span class="hljs-attr">total_symbols:</span> <span class="hljs-literal">true</span>           <span class="hljs-comment"># 網頁底部網站總字數統計顯示</span><br>  <span class="hljs-attr">total_time:</span> <span class="hljs-literal">true</span>              <span class="hljs-comment"># 網頁底部網站總閱讀時間顯示</span><br>  <span class="hljs-attr">exclude_codeblock:</span> <span class="hljs-literal">false</span>      <span class="hljs-comment"># 字數統計是否排除程式碼</span><br>  <span class="hljs-attr">awl:</span> <span class="hljs-number">4</span>                        <span class="hljs-comment"># 平均文字長度，中文為 2, 英文為 5, 預設為 4</span><br>  <span class="hljs-attr">wpm:</span> <span class="hljs-number">275</span>                      <span class="hljs-comment"># 一分鐘閱讀字數</span><br>  <span class="hljs-attr">suffix:</span> <span class="hljs-string">&quot;mins.&quot;</span><br></code></pre></td></tr></table></figure><p>修改 <code>root\_config.next.yml</code> 設定值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">symbols_count_time:</span><br>  <span class="hljs-attr">separated_meta:</span> <span class="hljs-literal">false</span>         <span class="hljs-comment"># true 在發布日期下一行/ false 和發布日期同一行</span><br>  <span class="hljs-attr">item_text_total:</span> <span class="hljs-literal">false</span>        <span class="hljs-comment"># 網頁底部顯示項目文字</span><br></code></pre></td></tr></table></figure><h3 id="文章底部標籤圖示設定"><a href="#文章底部標籤圖示設定" class="headerlink" title="文章底部標籤圖示設定"></a>文章底部標籤圖示設定</h3><p>預設文章底部顯示的標籤前綴會用 <code>#</code> ，若要改用圖示 <i class="fa fa-tags"></i> 取代:  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tag_icon:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="文章底部上一篇-x2F-下一篇連結"><a href="#文章底部上一篇-x2F-下一篇連結" class="headerlink" title="文章底部上一篇&#x2F;下一篇連結"></a>文章底部上一篇&#x2F;下一篇連結</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Available values: left(上一篇在左邊) | right(上一篇在右邊) | false(關閉功能)</span><br><span class="hljs-attr">post_navigation:</span> <span class="hljs-string">left</span><br></code></pre></td></tr></table></figure><h3 id="回到頂部功能"><a href="#回到頂部功能" class="headerlink" title="回到頂部功能"></a>回到頂部功能</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">back2top:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>            <span class="hljs-comment"># 功能開啟</span><br>  <span class="hljs-attr">sidebar:</span> <span class="hljs-literal">true</span>           <span class="hljs-comment"># true 在側欄底部顯示 / false 在頁面右下角顯示</span><br>  <span class="hljs-attr">scrollpercent:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># 顯示閱讀進度百分比</span><br></code></pre></td></tr></table></figure><h3 id="閱讀進度條"><a href="#閱讀進度條" class="headerlink" title="閱讀進度條"></a>閱讀進度條</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">reading_progress:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span>              <span class="hljs-comment"># 開啟功能</span><br>  <span class="hljs-attr">start_at:</span> <span class="hljs-string">left</span>             <span class="hljs-comment"># left 由左往右 / right 由右往左</span><br>  <span class="hljs-attr">position:</span> <span class="hljs-string">top</span>              <span class="hljs-comment"># 進度條在瀏覽器頁面的位置: top / bottom</span><br>  <span class="hljs-attr">reversed:</span> <span class="hljs-literal">false</span>            <span class="hljs-comment"># true 顯示剩餘進度 / false 顯示已閱讀進度</span><br>  <span class="hljs-attr">color:</span> <span class="hljs-string">&quot;#37c6c0&quot;</span>           <span class="hljs-comment"># 進度條顏色</span><br>  <span class="hljs-attr">height:</span> <span class="hljs-string">3px</span>                <span class="hljs-comment"># 進度條粗細</span><br></code></pre></td></tr></table></figure><h3 id="Github-右上角標"><a href="#Github-右上角標" class="headerlink" title="Github 右上角標"></a>Github 右上角標</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">github_banner:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>                                <span class="hljs-comment"># 開啟功能</span><br>  <span class="hljs-attr">permalink:</span> <span class="hljs-string">https://github.com/UserName</span>      <span class="hljs-comment"># Github 網址</span><br>  <span class="hljs-attr">title:</span> <span class="hljs-string">Follow</span> <span class="hljs-string">me</span> <span class="hljs-string">on</span> <span class="hljs-string">GitHub</span>                  <span class="hljs-comment"># 滑鼠顯示文字</span><br></code></pre></td></tr></table></figure><h3 id="站內搜索功能"><a href="#站內搜索功能" class="headerlink" title="站內搜索功能"></a>站內搜索功能</h3><p>安裝套件  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-searchdb<br></code></pre></td></tr></table></figure><p>修改 <code>root\_config.next.yml</code> 設定值  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">local_search:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>新增 <code>root\_config.yml</code> 設定值  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># https://github.com/next-theme/hexo-generator-searchdb</span><br><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.xml</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">all</span>         <span class="hljs-comment"># 搜尋範圍。可選 post (Default) / page / all</span><br>  <span class="hljs-attr">content:</span> <span class="hljs-literal">true</span>      <span class="hljs-comment"># true 全文搜索 / false 在標題及 meta info 裡搜索</span><br>  <span class="hljs-attr">format:</span> <span class="hljs-string">html</span><br></code></pre></td></tr></table></figure><br/><p>NexT 主題的基本設定就到這裡啦~ 可以自定義設定的地方太多了，這一篇筆記寫了三天才結束!! 還有一些功能還沒寫到，像是評論功能、閱讀字數&#x2F;時間、閱讀人數…等，預計要另外再開幾篇才能寫完。<br>雖然初期建置摸索真的花了很多時間，但是看到功能一個一個增加，實在是很有成就感啊!!</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效率地猜中數字</title>
      <link href="/posts/5959db4f/"/>
      <url>/posts/5959db4f/</url>
      
        <content type="html"><![CDATA[<p><strong>題目來源:</strong> Alpha Camp 學期一作業<br>這是第一個讓我覺得”卡卡”的題目，也是一個讓我在寫出來後深刻認知到: “<strong>想不到解決問題的方法，會寫程式也沒用</strong>“的題目。</p><span id="more"></span><p>藉著記錄解題的過程，把當初解決問題的方法和思考方式寫下來，達成再次深入複習的目的。</p><h2 id="解題工具"><a href="#解題工具" class="headerlink" title="解題工具"></a>解題工具</h2><ol><li>Math.random() 會回傳一個偽隨機小數介於0到1之間(包含0，不包含1)  </li><li>Math.floor() 會回傳小於等於所給數字的最大整數(無條件捨去)。  </li><li>while 迴圈  </li><li>if statement</li></ol><h2 id="基本題"><a href="#基本題" class="headerlink" title="基本題"></a>基本題</h2><h3 id="題目要求"><a href="#題目要求" class="headerlink" title="題目要求"></a>題目要求</h3><ol><li>指定介於 1-100 之間的數字，存在 <code>answer</code> 變數裡  </li><li>設定一個 <code>guess</code> 變數，代表挑戰者 (電腦) 猜的數字  </li><li>電腦可重覆「猜數字」，比對 <code>guess</code> 和 <code>answer</code>，判斷太大或太小  </li><li>若兩者相等（猜對）則結束遊戲，且結束時須計算電腦猜了幾次</li></ol><h3 id="解題過程"><a href="#解題過程" class="headerlink" title="解題過程"></a>解題過程</h3><p>使用 Math.random() 和 Math.floor() 指定一個介於 1-100 之間的數字，存在 <code>answer</code> 變數裡。</p><blockquote><p>原本想要直接用 Math.ceil() 無條件進位，但後來發現 Math.random() 有可能產生 “0”。所以如果直接用 Math.ceil() 可能會發生 <code>guess === 0</code> 的問題(不符合猜數範圍)。  </p></blockquote><p>先用 Math.random() * 100 取得一個介於0到100之間(包含0，不包含100)的隨機小數。把這個小數套進 Math.floor() 裡面進行無條件捨去再加1，就能取得一個介於1到100之間(包含1，包含100)的隨機整數了。  </p><blockquote><p>這裡還犯過一個非常不應該的錯誤，我把 Math 寫成 math ，然後就又跳錯誤了……</p></blockquote><br/><p>到目前為止，條件一和條件二都可以達成了。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 指定介於 1-100 之間的數字，存在 `answer` 變數裡</span><br><span class="hljs-keyword">const</span> answer = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>) + <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 設定一個 `guess` 變數，代表挑戰者 (電腦) 猜的數字</span><br><span class="hljs-keyword">let</span> guess = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br/><p>for &#x2F; while 的選擇—-因為這次的比大小是條件判斷，所以選擇 while 迴圈。<br>先把邏輯寫出來:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成並印出答案</span><br>宣告 anwer<br><span class="hljs-comment">// 進入迴圈的條件(重複執行的原因)</span><br><span class="hljs-keyword">while</span> (猜數 不等於 答案) ，則進入迴圈<br><br><span class="hljs-comment">// 每一回合會重複的動作(放進迴圈裡)</span><br>猜一次數字，並且回合數 + <span class="hljs-number">1</span> (接著進入結果判斷)<br><span class="hljs-variable constant_">IF</span> 猜數 &gt; 答案<br>  則 印出回合數、印出猜數、印出莊家回答:太大了<br><span class="hljs-variable constant_">ELSE</span> <span class="hljs-variable constant_">IF</span> 猜數 &lt; 答案<br>  則 印出回合數、印出猜數、印出莊家回答:太小了<br><span class="hljs-variable constant_">ELSE</span> (猜數 = 答案)<br>  則 印出回合數、印出猜數、印出莊家回答:恭喜答對!<br>  結束迴圈<br></code></pre></td></tr></table></figure><br/><p>好像差不多了，條件三和條件四也都可以達成了。但跟著邏輯再想一遍以後又發現了問題:  </p><ol><li>迴圈裡回合數每次 + 1，但不知道是從多少開始加，所以要先宣告回合數 &#x3D; 0  </li><li>一開始只生成答案無法達成進入迴圈條件，為了達成條件，先宣告猜數 &#x3D; 0</li></ol><p>以上問題都解決了，可以組合起來寫出程式碼了!  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ========= 宣告變數 ==========</span><br><span class="hljs-keyword">const</span> answer = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>) + <span class="hljs-number">1</span> <span class="hljs-comment">//正確答案</span><br><span class="hljs-keyword">let</span> guess = <span class="hljs-number">0</span> <span class="hljs-comment">//挑戰者猜的數字</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span> <span class="hljs-comment">//回合數</span><br><br><span class="hljs-comment">// ========= 從這裡開始 ==========</span><br><span class="hljs-comment">// 先印出正確數字</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`正確答案為 <span class="hljs-subst">$&#123;answer&#125;</span>`</span>)<br><br><span class="hljs-comment">// 設計判斷式和迴圈解決問題</span><br><span class="hljs-keyword">while</span> (guess !== answer) &#123;<br>  <br>  guess = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>) + <span class="hljs-number">1</span> <span class="hljs-comment">// 挑戰者猜一個本回合的數字    </span><br>  count += <span class="hljs-number">1</span>                                     <br><br> <span class="hljs-comment">// 條件判斷</span><br>  <span class="hljs-keyword">if</span> (guess &gt; answer) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">$&#123;count&#125;</span> 回合，挑戰者猜 <span class="hljs-subst">$&#123;guess&#125;</span>，莊家回答:太大了，再猜一次`</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (guess &lt; answer) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">$&#123;count&#125;</span> 回合，挑戰者猜 <span class="hljs-subst">$&#123;guess&#125;</span>，莊家回答:太小了，再猜一次`</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">$&#123;count&#125;</span> 回合，挑戰者猜 <span class="hljs-subst">$&#123;guess&#125;</span>，莊家回答:恭喜答對!`</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;===============遊戲結束===============&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><br/><h2 id="進階題"><a href="#進階題" class="headerlink" title="進階題"></a>進階題</h2><h3 id="題目要求-1"><a href="#題目要求-1" class="headerlink" title="題目要求"></a>題目要求</h3><ul><li>讓電腦在 10 次以內猜對</li></ul><h3 id="解題過程-1"><a href="#解題過程-1" class="headerlink" title="解題過程"></a>解題過程</h3><p>花了三個小時都沒想出來，最後決定上網找找靈感，幸運發現一個前輩的解題思路。認真看完一遍，發現就跟以前玩終極密碼一樣，最快的方式就是縮小範圍，砍半再砍半。如果用對半切的方式，已知 2 的 10 次方為 1024，即範圍 1~1024 內的數字用砍半方式一定可以在 10 次內猜到，符合題目要求。  </p><p>知道方法後要做的事只有2件:  </p><ol><li>設定猜數的上限和下限  </li><li>讓猜數取上限和下限的中位數</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 設定猜數的起始上限和下限(放起始宣告位置)</span><br><span class="hljs-keyword">let</span> rangeMax = <span class="hljs-number">100</span> <br><span class="hljs-keyword">let</span> rangeMin = <span class="hljs-number">1</span> <br><br><span class="hljs-comment">// 設定迴圈裡猜數的上限和下限重新賦值的方式(放入迴圈)</span><br><span class="hljs-comment">// 猜過的數字不能包含在範圍內</span><br>rangeMax = guess - <span class="hljs-number">1</span><br>rangeMin = guess + <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 以猜數範圍的中位數再猜一次(放入迴圈)</span><br>guess = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((rangeMin + rangeMax) / <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><br/><p>該作的變數調整都完成了，接下來就是把它們塞進該放的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 宣告並產生答案</span><br><span class="hljs-keyword">const</span> answer = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>) + <span class="hljs-number">1</span>  <br><br><span class="hljs-comment">// ========= start coding ==========</span><br><span class="hljs-keyword">let</span> guess = <span class="hljs-number">0</span>         <span class="hljs-comment">// 宣告挑戰者猜的數字為0</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>         <span class="hljs-comment">// 宣告起始回合數為0</span><br><span class="hljs-keyword">let</span> rangeMax = <span class="hljs-number">100</span>    <span class="hljs-comment">// 宣告猜測最大值為100</span><br><span class="hljs-keyword">let</span> rangeMin = <span class="hljs-number">1</span>      <span class="hljs-comment">// 宣告猜測最小值為1</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`莊家數字是 <span class="hljs-subst">$&#123;answer&#125;</span>`</span>)  <span class="hljs-comment">//印出正確答案</span><br><br><span class="hljs-keyword">while</span> (guess !== answer) &#123;<br>  guess = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((rangeMin + rangeMax) / <span class="hljs-number">2</span>)<br>  count += <span class="hljs-number">1</span><br><br>  <span class="hljs-keyword">if</span> (guess &gt; answer) &#123;  <br>    rangeMax = guess - <span class="hljs-number">1</span>  <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">$&#123;count&#125;</span> 局|電腦猜 <span class="hljs-subst">$&#123;guess&#125;</span> ，太大，再猜一次! 範圍 <span class="hljs-subst">$&#123;rangeMin&#125;</span> ~ <span class="hljs-subst">$&#123;rangeMax&#125;</span> 。`</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (guess &lt; answer) &#123;<br>    rangeMin = guess + <span class="hljs-number">1</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">$&#123;count&#125;</span> 局|電腦猜 <span class="hljs-subst">$&#123;guess&#125;</span> ，太小，再猜一次! 範圍 <span class="hljs-subst">$&#123;rangeMin&#125;</span> ~ <span class="hljs-subst">$&#123;rangeMax&#125;</span> 。`</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">$&#123;count&#125;</span> 局|電腦猜 <span class="hljs-subst">$&#123;guess&#125;</span> ，恭喜答對!`</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>終於成功了!! 這也是文章開頭說的: 如果知道解決問題的方法，只要能正確地把程式碼寫出來就好；如果不知道解決問題的方法，就算程式語言再精深都沒用，因為連怎麼開始都不知道。  </p><p>其他小題目還好，就不特別寫解題筆記了。預計下一篇會寫更卡一點的期末考 😅</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AlphaCamp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 編輯文章</title>
      <link href="/posts/978c1db/"/>
      <url>/posts/978c1db/</url>
      
        <content type="html"><![CDATA[<p>基本設定都完成後就可以來寫部落格了! 在正式開始前，如果能對 Hexo 的資料夾架構及 Front-matter 有點基本的認識，會對後續的操作很有幫助。</p><span id="more"></span><h2 id="Hexo-資料夾架構"><a href="#Hexo-資料夾架構" class="headerlink" title="Hexo 資料夾架構"></a>Hexo 資料夾架構</h2><p>之前在 <code>hexo init</code> 之後，根目錄資料夾會多了一些預設檔案，接下來會對其中比較重要的做簡單說明。  </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">root<br>├── <span class="hljs-string">.deploy_git</span>             <span class="hljs-comment"># 內含已部署到 Github Repository 的所有檔案</span><br>├── public                  <span class="hljs-comment"># hexo g 生成靜態網站檔</span><br>├── scaffolds               <span class="hljs-comment"># 樣板資料夾(hexo new 會從這裡抓樣板，也可以自己新建樣板)</span><br>|   ├── draft.md            <span class="hljs-comment"># 草稿樣板</span><br>|   ├── page.md             <span class="hljs-comment"># 頁面樣板</span><br>|   └── post.md             <span class="hljs-comment"># 文章樣板(預設)</span><br>├── source                  <span class="hljs-comment"># 存放原始檔案的地方</span><br>|   ├── _data               <span class="hljs-comment"># 存放自定義設定原始碼的地方</span><br>|   ├── _drafts             <span class="hljs-comment"># 草稿資料夾</span><br>|   └── _posts              <span class="hljs-comment"># 文章資料夾</span><br>├── themes                  <span class="hljs-comment"># 各種主題資料夾</span><br>|   └── landscape           <span class="hljs-comment"># 預設主題</span><br>|       └── _config.yml     <span class="hljs-comment"># 主題樣式設定檔</span><br>├── <span class="hljs-string">.gitignore</span>              <span class="hljs-comment"># 設定不想被加入版本控制或是上傳到 GitHub 的資料夾或檔案</span><br>└── _config.yml             <span class="hljs-comment"># Hexo 基本設定</span><br></code></pre></td></tr></table></figure><ul><li><code>_drafts</code> 草稿資料夾預設會被 generate 、server 和 deploy 指令略過(<code>_post</code> 以外以”_”開頭的資料夾都是)。如果想在 localhost 先預覽的話，可以在 <code>root\_config.yml</code> 裡把 <code>render_drafts: false(預設)</code> 改為 true。</li></ul><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是檔案最上方以 — 分隔的區域，用於指定個別檔案的變數。可以每篇文章個別設定，也可以預先在樣板中建立套用內容。常用的變數如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">title</span>        <span class="hljs-comment"># 標題(預設為檔案名稱)</span><br><span class="hljs-string">date</span>         <span class="hljs-comment"># 建立日期(預設為檔案建立日期)</span><br><span class="hljs-string">updated</span>      <span class="hljs-comment"># 更新日期(預設為檔案更新日期)</span><br><span class="hljs-string">comments</span>     <span class="hljs-comment"># 留言功能(預設 true :開啟)</span><br><span class="hljs-string">tags</span>         <span class="hljs-comment"># 標籤</span><br><span class="hljs-string">categories</span>   <span class="hljs-comment"># 分類</span><br></code></pre></td></tr></table></figure><ul><li>當因為重新部署或其他原因，導致在沒有修改文章情況下顯示文章更新，可以手動修改 <code>updated</code> 值，讓他跟建立日期相同即可。  </li><li>多個標籤&#x2F;多個分類寫法不同，可參考<a href="https://hexo.io/zh-tw/docs/front-matter#%E5%88%86%E9%A1%9E%E5%92%8C%E6%A8%99%E7%B1%A4">官方說明</a>。</li></ul><h2 id="草稿編輯"><a href="#草稿編輯" class="headerlink" title="草稿編輯"></a>草稿編輯</h2><h3 id="新增草稿"><a href="#新增草稿" class="headerlink" title="新增草稿"></a>新增草稿</h3><p>草稿會建立在 <code>root\source\_drafts</code> 資料夾內。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new draft 文章名稱<br></code></pre></td></tr></table></figure><h3 id="草稿轉文章"><a href="#草稿轉文章" class="headerlink" title="草稿轉文章"></a>草稿轉文章</h3><p>指令會把檔案從 <code>_drafts</code> 移至 <code>_posts</code> 資料夾內，也可以自己手動移動。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo publish draft 文章名稱<br></code></pre></td></tr></table></figure><h2 id="文章編輯"><a href="#文章編輯" class="headerlink" title="文章編輯"></a>文章編輯</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>會建立在 <code>root\source\_posts</code> 資料夾內。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new 文章名稱         <span class="hljs-comment"># 預設抓取 post 樣板</span><br></code></pre></td></tr></table></figure><h3 id="刪除貼文"><a href="#刪除貼文" class="headerlink" title="刪除貼文"></a>刪除貼文</h3><p>直接從 <code>root\source</code> 資料夾刪除本地檔案，清除靜態檔再重新上傳即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><h2 id="頁面編輯"><a href="#頁面編輯" class="headerlink" title="頁面編輯"></a>頁面編輯</h2><p>頁面和文章不同，是指每個主題 menu 項目的頁面。如果有開啟 menu 項目卻沒有預設頁面的情況下，會被導向 404 畫面。常用的幾個頁面如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">about</span>         <span class="hljs-comment"># 關於我(通常會寫網站介紹或作者介紹)</span><br><span class="hljs-string">archives</span>      <span class="hljs-comment"># 歸檔(依發布日期把所有文章排序)</span><br><span class="hljs-string">categories</span>    <span class="hljs-comment"># 分類(會依每篇文章 Front-matter 裡的分類建立分類目錄-有層級)</span><br><span class="hljs-string">tags</span>          <span class="hljs-comment"># 標籤(會依每篇文章 Front-matter 裡的分類建立標籤目錄-無層級)</span><br><span class="hljs-string">link</span>          <span class="hljs-comment"># 對外連結(通常是推薦部落格或網站的連結)</span><br></code></pre></td></tr></table></figure><h3 id="新建頁面"><a href="#新建頁面" class="headerlink" title="新建頁面"></a>新建頁面</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> 頁面名稱<br></code></pre></td></tr></table></figure><ul><li>頁面通常不需要開啟留言功能，所以在新建時要記得將 Front-matter 的 <code>comments</code> 值改為 false。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: categories<br>date: 2021-12-14 18:33:37<br>type: &quot;categories&quot;<br><span class="hljs-section">comments: false</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: tags<br>date: 2021-12-14 18:34:46<br>type: &quot;tags&quot;<br><span class="hljs-section">comments: false</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><ul><li>新建頁面會新建一個 <code>index</code> 檔案，放在”頁面名稱”資料夾裡。</li></ul><h2 id="文章發布"><a href="#文章發布" class="headerlink" title="文章發布"></a>文章發布</h2><p>同之前的部署指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 基本設定</title>
      <link href="/posts/a970120e/"/>
      <url>/posts/a970120e/</url>
      
        <content type="html"><![CDATA[<p>基本上經過上一篇的操作，在 <code>hexo s</code> 後應該已經可以在 <a href="http://localhost:4000/">http://localhost:4000</a> 看到預設的 Hello World 畫面了，但要讓 Blog 正式啟動前，我們還要先做一些個人化設定。  </p><span id="more"></span><blockquote><p>本文撰寫時的版本如下(可用 <code>hexo version</code> 確認)，不同版本的預設配置檔可能會有差異:<br>hexo: 6.0.0<br>hexo-cli: 4.3.0  </p></blockquote><ul><li>基本配置文件位置在 <code>root\_config.yml</code>，<font color=#FF6600>冒號後面都必需保留半型空格一格</font>。  </li><li>僅列出通常會修改或我已經修改的部分，其他請參考<a href="https://hexo.io/zh-tw/docs/configuration">官方網站</a>說明。</li></ul><h2 id="網站設定"><a href="#網站設定" class="headerlink" title="網站設定"></a>網站設定</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo</span>           <span class="hljs-comment"># 網站標題</span><br><span class="hljs-attr">subtitle:</span>             <span class="hljs-comment"># 網站副標題</span><br><span class="hljs-attr">description:</span>          <span class="hljs-comment"># 網站描述</span><br><span class="hljs-attr">keywords:</span>             <span class="hljs-comment"># 網站關鍵字(支援多個關鍵詞，用半型逗號隔開)</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">John</span> <span class="hljs-string">Doe</span>      <span class="hljs-comment"># 作者</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">en</span>          <span class="hljs-comment"># 網站語言 (台灣:zh-tw)</span><br><span class="hljs-attr">timezone:</span>             <span class="hljs-comment"># 時區(可留空以使用您電腦的時區)</span><br></code></pre></td></tr></table></figure><h2 id="網址設定"><a href="#網址設定" class="headerlink" title="網址設定"></a>網址設定</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here.</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://UserName.github.io/</span>           <span class="hljs-comment"># UserName更改為自己的帳戶名</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span>      <span class="hljs-comment"># 文章網址的格式(預設使用 年月日/文章名稱)/</span><br><span class="hljs-attr">permalink_defaults:</span>                       <span class="hljs-comment"># permalink 中各區段的預設值</span><br></code></pre></td></tr></table></figure><ul><li>permalink 會依照設定值，在每次 generate 時重新產生網址，設定參數可參考<a href="https://hexo.io/zh-tw/docs/permalinks">官方文件</a>。我在命名檔名時，習慣使用日期 + 英文檔名(日期方便排序，不含空格的英文檔名較不會產生亂碼網址)，所以 permalink: 僅用 <code>:title</code> 參數 (最後的 <code>/</code> 要記得保留)。</li><li><strong><font color=red>2021&#x2F;12&#x2F;27 更新: <a href="/posts/d8dab675/">使用 Hexo-abbrlink 產生永久連結</a></font></strong></li></ul><h2 id="目錄設定"><a href="#目錄設定" class="headerlink" title="目錄設定"></a>目錄設定</h2><p>原則上都保留不變，除非有自訂路徑的需求。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Directory</span><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span>            <span class="hljs-comment"># 原始檔案資料夾，存放編輯的所有內容</span><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span>            <span class="hljs-comment"># 存放靜態檔案的資料夾(hexo g 後產生)</span><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span>                 <span class="hljs-comment"># 標籤資料夾</span><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span>         <span class="hljs-comment"># 彙整資料夾(deploy後產生)</span><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span>      <span class="hljs-comment"># 分類資料夾</span><br></code></pre></td></tr></table></figure><ul><li><code>tags</code> 和 <code>categories</code> 資料夾預設是不存在的，有需要要另外新增資料夾。</li></ul><h2 id="擴充套件設定"><a href="#擴充套件設定" class="headerlink" title="擴充套件設定"></a>擴充套件設定</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/       # 提供各種套件，可以依自己需求安裝</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/         # 提供各種主題，可以依自己需求安裝</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">landscape</span>                           <span class="hljs-comment"># 填寫主題名稱</span><br></code></pre></td></tr></table></figure><ul><li>本部落格選用 Next 主題(要把 landscape 改為 Next)，後續會另開一篇變更主題說明文。</li></ul><h2 id="部署設定"><a href="#部署設定" class="headerlink" title="部署設定"></a>部署設定</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>Hexo 可同時部署到不同地方，相關設定參考<a href="https://hexo.io/zh-tw/docs/one-command-deployment">官方部署說明</a>。  </li><li>部署到 Github 方式已在用前篇 Hexo + Github Pages 建立部落格 中說明，這邊不另外贅述。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Hexo + Github Pages 建立部落格</title>
      <link href="/posts/4b9ba027/"/>
      <url>/posts/4b9ba027/</url>
      
        <content type="html"><![CDATA[<p>在建置部落格前猶豫了很久，最終還是決定用 Hexo + Github Pages 當作平台。歷時兩天，終於解決各種莫名其妙的問題，讓它變成心目中的樣子!</p><span id="more"></span><h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><h3 id="為什麼選擇-Github-Pages"><a href="#為什麼選擇-Github-Pages" class="headerlink" title="為什麼選擇 Github Pages ?"></a>為什麼選擇 Github Pages ?</h3><p><strong>1. 免費</strong><br>  Github Pages 是 Github 提供的免費靜態網頁空間，提供一組 Github帳號 <code>.github.io</code> 子網域。雖然有容量跟流量上的限制，但以一個剛起步的部落格來說，現階段不會有超出的問題。既然有免費的平台那就用吧!  </p><p><strong>2. 能夠使用 Git 部署並進行版本控制</strong><br>  看了各個學習寫程式分享，得知「如何使用 Git 進行版本控制」是很重要的。雖然現階段身為程式小白的我沒有太多的概念，也完全沒有接觸過，但在查詢 Hexo 資訊時得知，Hexo 可以藉由 Git 部署到 Github 上。希望能在日常使用中學習並熟悉 Git 。  </p><p><strong>3. Github 會記錄每日 commit 次數</strong><br>  Github 的個人首頁會呈現一整年的 commit 紀錄畫面。每天一格，每 commit 一次，當天的格子就會從灰色漸漸往深綠色變化。希望利用自己的收集強迫症，為了盡可能填滿格子，督促自己多多更新部落格。  </p><h3 id="Github-Pages-有什麼限制"><a href="#Github-Pages-有什麼限制" class="headerlink" title="Github Pages 有什麼限制?"></a>Github Pages 有什麼限制?</h3><ol><li>只能存放靜態網頁。</li><li>1GB 空間容量。</li><li>100GB 月流量。</li><li>1 小時內只能提交 10 次更新版本。<blockquote><p>參考資料: <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages#limits-on-use-of-github-pages">Github 說明文件</a></p></blockquote></li></ol><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="為什麼選擇-Hexo"><a href="#為什麼選擇-Hexo" class="headerlink" title="為什麼選擇 Hexo ?"></a>為什麼選擇 Hexo ?</h3><p><strong>1. Hexo 支援強大:</strong><br>  Hexo 是台灣人做的(<a href="https://zespia.tw/blog/2012/10/11/hexo-debut/">起源在這裡</a>)，官方中文支援蠻完整的。另外，可能也是因為中文支援較完整，有很多中文圈的前輩做了很多主題可以套用，當遇到相關問題時，Google 到的解決方案也很多。  </p><p><strong>2. 使用 Node.js(JavaScript) 開發:</strong><br>  在正式開始前，找了幾個熱門靜態檔案產生器比較，最後在 Hexo 跟 Hugo 之間做選擇。雖然 Hugo 比較快，Github上的星星數也比較多，但基於 Hugo 是用 Go 語言寫的，初學的我還是應該先專心一門語言較好，因此捨棄 Hugo 選擇使用 JavaScript 的 Hexo。既然我現在在學JavaScript，現階段可以研究一下它的寫法，之後說不定哪天我可以自己把它改得更符合自己需求。目前在做一些個人化設定時也發現，因為可以看得懂一點點結構，修改時很有幫助。  </p><p><strong>3. 支援 Markdown :</strong><br>Markdown 用來撰寫文章很方便，因為語法簡單，可以更專心在文字內容的編輯上，不用過分關注排版問題。在加上之前跟鳥友一起在HackMD建了個鳥寶寶成長紀錄(<a href="https://hackmd.io/p5O2bt2QQrC1HH46cVfs0A">有興趣可以看看</a>)，對 Markdown 也算比較熟悉了。</p><p><strong>4. 個人化設定自由度高 :</strong><br>主題非常多元，版面也可依自己需求做CSS修改。(剛學到的 <code>padding</code> 、 <code>letter-spacing</code> 、 <code>border-radius</code> 等也都依自己喜歡的樣子用上了!) 另外，也可以找到很多其他插件資源，讓自己的部落格更有個人特色。<br>  <br/></p><h2 id="開始建置部落格"><a href="#開始建置部落格" class="headerlink" title="開始建置部落格"></a>開始建置部落格</h2><blockquote><p>本文撰寫時在 Windows 10 環境下安裝。  </p></blockquote><h3 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h3><p><strong>1. 安裝 Node.js</strong>  </p><ul><li>建置過程中需要用 NPM 安裝套件，所以要先下載 Node.js (<a href="https://nodejs.org/en/">官網下載</a>)。</li></ul><p><strong>2. 安裝 Git</strong>  </p><ul><li><p>之後會使用 Git 作版本控制並將 Hexo 部署或備份到 Github 上，所以要先安裝 Git (<a href="https://git-scm.com/downloads">官網下載</a>)。  </p></li><li><p>開始初次設定 Git : 設定使用者名稱及電子郵件， Git 的提交會使用這些資訊。  </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 引號內填入使用者名稱</span><br>git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br><span class="hljs-comment"># 引號內填入使用者email</span><br>git config --global user.email <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>完成後可用 <code>git config --global --list</code> 檢查是否有誤，或是到 <code>C:\Users\yourUserName\.gitconfig</code> 確認並修正。</p></li></ul><p><strong>3. 新建Github Repository</strong>  </p><ul><li>開啟 Github 並點選 New Repository</li><li>Repository 名稱為 <code>用戶名.github.io</code><br>  <img src="/../../Blog-image/posts/2021-12-21_001.webp" alt="20211221-001">    <br/></li></ul><h3 id="本地端安裝"><a href="#本地端安裝" class="headerlink" title="本地端安裝"></a>本地端安裝</h3><p><strong>1. 安裝 Hexo</strong>  </p><ul><li>使用 <code>npm install -g hexo-cli</code> 安裝 Hexo 。  </li><li>安裝成功後，輸入 <code>hexo version</code> 指令可查看安裝版本。</li></ul><p><strong>2. Blog 存放資料夾初始化</strong></p><ul><li>開啟命令提示元(CMD) &gt; 前往想存放 Blog 檔案的本地端資料夾。 (ex. 我要在 D 槽新建 Blog 資料夾存放，所以先輸入 <code>D:</code> 讓當前位置移到 D 槽)  </li><li>初始化資料夾(必須是空資料夾，以下方法二選一)  <ul><li>方法一(當前位置 D 槽) –在 D 槽新建 Blog 資料夾並初始化  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init Blog<br></code></pre></td></tr></table></figure></li><li>方法二(已自行新建資料夾，當前位置 D:\Blog) –將 Blog 資料夾初始化  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure></li></ul></li><li>安裝相關套件  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure></li></ul><p><strong>3. 部署設定</strong></p><ul><li>安裝部署用套件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li>修改部署設定 (檔案 <code>根目錄\_config.yml</code> 最下方 # Deployment)  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/用戶名/用戶名.github.io.git</span>  <span class="hljs-comment"># Repository 網址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">分支名稱(可用預設</span> <span class="hljs-string">main</span> <span class="hljs-string">，或自訂如</span> <span class="hljs-string">gh-pages)</span><br>  <span class="hljs-attr">message:</span> <span class="hljs-string">&quot;填入commit訊息&quot;</span>  <span class="hljs-comment"># 本行不用可刪</span><br></code></pre></td></tr></table></figure><br/></li></ul><h3 id="部署到Github-常用指令"><a href="#部署到Github-常用指令" class="headerlink" title="部署到Github (常用指令)"></a>部署到Github (常用指令)</h3><p><strong>1. 本地端預覽</strong><br>使用時機: 當在本地端做完修改後，如果希望看到及時修改結果。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server                <span class="hljs-comment"># 開啟本地端預覽(標準用法)</span><br>hexo s                     <span class="hljs-comment"># 開啟本地端預覽(簡短用法)</span><br>http://localhost:4000      <span class="hljs-comment"># 貼入網址列即可預覽</span><br>Ctrl + C                   <span class="hljs-comment"># 結束本地端預覽</span><br></code></pre></td></tr></table></figure><p><strong>2. 產生靜態檔案</strong><br>使用時機: 編寫完成後，產生要部署的靜態檔案(會產生 <code>根目錄\public</code> 資料夾放入要部署的檔案)。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate             <span class="hljs-comment"># 產生靜態檔案(標準用法)</span><br>hexo g                    <span class="hljs-comment"># 產生靜態檔案(簡短用法)</span><br></code></pre></td></tr></table></figure><p><strong>3. 部署</strong><br>使用時機: 編寫完成後，部署到 Github ( <code>根目錄\public</code> 裡的檔案會被上傳到設定好的 Repository)。部署完成就可以在 <code>github.io</code> 看到自己的 Blog 了!  </p><blockquote><p><font color=#FF6600>Github有時候部署後要等10~20分鐘畫面才會更新</font></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy                  <span class="hljs-comment"># 產生靜態檔案(標準用法)</span><br>hexo d                       <span class="hljs-comment"># 產生靜態檔案(簡短用法)</span><br>https://帳戶名.github.io/     <span class="hljs-comment"># 個人部落格網址</span><br></code></pre></td></tr></table></figure><p><strong>4. 清除快取 &amp; 靜態檔案</strong><br>使用時機: 為了避免出錯，建議在每次 deploy 前，都先清除先前的資料再重新產生靜態檔案(清除快取檔案 <code>db.json</code> 和已產生的靜態檔案 <code>根目錄\public</code>)。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean     <span class="hljs-comment"># 清除快取 &amp; 靜態檔案(標準用法)</span><br>hexo cl        <span class="hljs-comment"># 清除快取 &amp; 靜態檔案(簡短用法)</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 運算子</title>
      <link href="/posts/d403fec1/"/>
      <url>/posts/d403fec1/</url>
      
        <content type="html"><![CDATA[<p>在使用運算子 (Operators) 時，隨著練習題逐漸提高的複雜度，開始發現一些與自己認知不同的地方。這些不明顯的小錯誤，常常是導致程式跑不出來或出現預期外結果的原因。所以在之前筆記的基礎上，把犯過的錯誤一起整理進來，降低下次再犯的可能性。</p><span id="more"></span><blockquote><p>筆記內容為學習過程中的紀錄，內容可能未臻完善，內文可能也會隨著學習過程作增減或修改。<br>如有錯漏，歡迎留言，謝謝!  </p></blockquote><h2 id="算術運算子"><a href="#算術運算子" class="headerlink" title="算術運算子"></a>算術運算子</h2><h3 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h3><p>算術運算子（arithmetic operators）: 四則運算會用到的運算子，負責將變數進行加、減、乘、除。  </p><table><thead><tr><th align="center">運算子</th><th align="center">功能</th><th>範例</th><th align="center">結果</th><th>說明</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td>1 + 2</td><td align="center">3</td><td>也可以用來連接字串</td></tr><tr><td align="center">-</td><td align="center">減</td><td>4 - 3</td><td align="center">1</td><td></td></tr><tr><td align="center">*</td><td align="center">乘</td><td>2 * 4</td><td align="center">8</td><td></td></tr><tr><td align="center">&#x2F;</td><td align="center">除</td><td>9 &#x2F; 3</td><td align="center">3</td><td></td></tr><tr><td align="center">**</td><td align="center">指數</td><td>3 ** 2<br>9 ** (1&#x2F;2)</td><td align="center">9<br>3</td><td>計算 a 的 b 次方</td></tr><tr><td align="center">%</td><td align="center">取餘數</td><td>7 &#x2F; 2</td><td align="center">1</td><td>7 除以 2 結果：商等於 3，餘數等於 1</td></tr><tr><td align="center">++</td><td align="center">將值增加 1</td><td>x &#x3D; 2<br>x++</td><td align="center">3</td><td>同 x &#x3D; x + 1，將 x 原本的值 2 再加 1。</td></tr><tr><td align="center">–</td><td align="center">將值減少 1</td><td>x &#x3D; 5<br>x–</td><td align="center">4</td><td>同 x &#x3D; x - 1，將 x 原本的值 5 再減 1。</td></tr></tbody></table><h3 id="寫在前面的-和"><a href="#寫在前面的-和" class="headerlink" title="寫在前面的 ++ 和 --"></a>寫在前面的 <code>++</code> 和 <code>--</code></h3><p><code>++</code> 和 <code>--</code> 寫在變數的前面或後面作用都是不變的，即「將變數的值再加 1 或再減 1」。但是如果放進 console.log() 裡，執行的順序會不一樣。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>            <span class="hljs-comment">// 宣告並指派 2 的值給 x</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)       <span class="hljs-comment">// 會印出 2</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x++)     <span class="hljs-comment">// 會印出 2 (先印出 x ，然後才加 1)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)       <span class="hljs-comment">// 會印出 3</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(++x)     <span class="hljs-comment">// 會印出 4 (先加 1 ，然後才印出 x)</span><br></code></pre></td></tr></table></figure><h3 id="常見錯誤-型別錯誤"><a href="#常見錯誤-型別錯誤" class="headerlink" title="常見錯誤: 型別錯誤"></a>常見錯誤: 型別錯誤</h3><p>JavaScript 是一個弱型別的語言，意思是說在 JavaScript 裡，型別特別容易自動轉換。進行運算時，如果變數型別不同，有時候 JavaScript 不會報錯，而是直接自動轉換型別，這也很容易造成「出現預期外結果卻很難找出原因」。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;2&#x27;</span>           <span class="hljs-comment">// 型別: string</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span>             <span class="hljs-comment">// 型別: number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b)    <span class="hljs-comment">// 會印出 23 (自動將 b 型別轉換為 string )</span><br></code></pre></td></tr></table></figure><h2 id="賦值運算子"><a href="#賦值運算子" class="headerlink" title="賦值運算子"></a>賦值運算子</h2><h3 id="基本介紹-1"><a href="#基本介紹-1" class="headerlink" title="基本介紹"></a>基本介紹</h3><p>賦值運算子（assignment operators）中最常使用的賦值運算子就是 <code>=</code> ，除了 <code>=</code> 外還有搭配算數運算的其他賦值運算子。  </p><table><thead><tr><th align="center">運算子</th><th>範例</th><th align="center">結果</th><th>說明</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td>x &#x3D; 5<br>y &#x3D; 2</td><td align="center">x &#x3D; 5<br>y &#x3D; 2</td><td>將值 5 賦值給 x<br>將值 2 賦值給 y</td></tr><tr><td align="center">+&#x3D;</td><td>x +&#x3D; y</td><td align="center">x &#x3D; 7</td><td>等同 x &#x3D; x + y 的意思</td></tr><tr><td align="center">-&#x3D;</td><td>x -&#x3D; y</td><td align="center">x &#x3D; 3</td><td>等同 x &#x3D; x - y 的意思</td></tr><tr><td align="center">&#x2F;&#x3D;</td><td>x &#x2F;&#x3D; y</td><td align="center">x &#x3D; 2.5</td><td>等同 x &#x3D; x &#x2F; y 的意思</td></tr><tr><td align="center">%&#x3D;</td><td>x %&#x3D; y</td><td align="center">x &#x3D; 1</td><td>等同 x &#x3D; x % y 的意思</td></tr></tbody></table><h2 id="比較運算子"><a href="#比較運算子" class="headerlink" title="比較運算子"></a>比較運算子</h2><h3 id="基本介紹-2"><a href="#基本介紹-2" class="headerlink" title="基本介紹"></a>基本介紹</h3><p>比較運算子（comparison operators）: 在進行條件設定時，很常用到比較運算子，也是容易出現「粗心的錯誤」的地方。  </p><table><thead><tr><th align="center">運算子</th><th>說明</th><th>範例</th><th>結果</th></tr></thead><tbody><tr><td align="center">&#x3D;&#x3D;</td><td>等於 (<strong>不</strong>檢查型別)</td><td>1 &#x3D;&#x3D; ‘1’<br>0 &#x3D;&#x3D; ‘’</td><td>true<br>true</td></tr><tr><td align="center">&#x3D;&#x3D;&#x3D;</td><td>等於 (檢查型別)</td><td>1 &#x3D;&#x3D; ‘1’<br>0 &#x3D;&#x3D; ‘’</td><td>false<br>false</td></tr><tr><td align="center">!&#x3D;</td><td>不等於 (<strong>不</strong>檢查型別)</td><td>1 !&#x3D; ‘1’<br>0 !&#x3D; ‘’</td><td>false<br>false</td></tr><tr><td align="center">!&#x3D;&#x3D;</td><td>不等於 (檢查型別)</td><td>1 !&#x3D;&#x3D; ‘1’<br>0 !&#x3D;&#x3D; ‘’</td><td>true<br>true</td></tr><tr><td align="center">&gt;</td><td>大於(<strong>不</strong>檢查型別)</td><td>3 &gt; 1<br>3 &gt; 3<br>1 &gt; 3</td><td>true<br>false<br>false</td></tr><tr><td align="center">&lt;</td><td>小於(<strong>不</strong>檢查型別)</td><td>3 &lt; 1<br>3 &lt; 3<br>1 &lt; 3</td><td>false<br>false<br>true</td></tr><tr><td align="center">&gt;&#x3D;</td><td>大於等於(<strong>不</strong>檢查型別)</td><td>3 &gt;&#x3D; 1<br>3 &gt;&#x3D; 3<br>1 &gt;&#x3D; 3</td><td>true<br>true<br>false</td></tr><tr><td align="center">&lt;&#x3D;</td><td>小於等於(<strong>不</strong>檢查型別)</td><td>3 &lt;&#x3D; 1<br>3 &lt;&#x3D; 3<br>1 &lt;&#x3D; 3</td><td>false<br>true<br>true</td></tr></tbody></table><h3 id="常見錯誤1-型別錯誤"><a href="#常見錯誤1-型別錯誤" class="headerlink" title="常見錯誤1: 型別錯誤"></a>常見錯誤1: 型別錯誤</h3><p>除了<strong>等於</strong>和<strong>不等於</strong>可以強制檢查型別，其他的比較運算子都要特別注意<strong>型別轉換</strong>問題。可以用 <code>typeof</code> 來檢查變數的型別。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;2&#x27;</span>             <span class="hljs-comment">// 型別: string</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span>               <span class="hljs-comment">// 型別: number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a &lt; b)      <span class="hljs-comment">// 結果為 true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> a)   <span class="hljs-comment">// 結果為 string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> b)   <span class="hljs-comment">// 結果為 number</span><br></code></pre></td></tr></table></figure><h3 id="常見錯誤2-用錯等於"><a href="#常見錯誤2-用錯等於" class="headerlink" title="常見錯誤2: 用錯等於"></a>常見錯誤2: 用錯等於</h3><p>依照以前學數學的習慣，在做變數比較時，會不小心把 <code>=</code> 當作比較運算子使用。原本要拿來比較的變數不小心被重新賦值了，所以會跑出奇怪的結果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">3</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br><br><span class="hljs-comment">// 正確 </span><br><span class="hljs-keyword">if</span>(a === b) &#123;       <span class="hljs-comment">// 如果 a 和 b 相等，則進行 (a - b)</span><br>  a - b             <span class="hljs-comment">// 因為 a 和 b 不相等，所以不會執行</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a - b)  <span class="hljs-comment">// 會印出 1。此時 a 等於3；b 等於2</span><br><br><span class="hljs-comment">// 錯誤</span><br><span class="hljs-keyword">if</span>(a = b) &#123;         <span class="hljs-comment">// b 的值被指派給 a ，此時 a 等於2</span><br>  a - b             <span class="hljs-comment">// 進行 a - b 運算(2-2)</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a - b)  <span class="hljs-comment">// 會印出 0。此時 a 和 b 都等於2</span><br></code></pre></td></tr></table></figure><h3 id="常見錯誤3-比較變數區間"><a href="#常見錯誤3-比較變數區間" class="headerlink" title="常見錯誤3: 比較變數區間"></a>常見錯誤3: 比較變數區間</h3><p>按照數學邏輯，如果我想知道一個變數的值是否在特定區間裡，可能會把條件這樣寫 <code>3 &lt; x &lt; 10</code> ，然後再丟一個 x 值進行驗證，但是在 JavaScript 裡，這樣做結果會出現異常。  </p><p>這樣寫的效果類似 <code>||</code> 的使用， <code>3 &lt; x &lt; 10</code> 會被拆成兩段 (<code>3 &lt; x</code> 和 <code>x &lt; 10</code>) 進行驗證，只要其中一項符合則傳回 true。  </p><p>正確方式應該要將條件拆開，並用 <code>&amp;&amp;</code> 要求同時符合。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> &lt; x &lt; <span class="hljs-number">10</span>)       <span class="hljs-comment">// 輸出結果為 true (符合 x &lt; 10)</span><br><br><span class="hljs-keyword">let</span> x = <span class="hljs-number">11</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> &lt; x &lt; <span class="hljs-number">10</span>)       <span class="hljs-comment">// 輸出結果為 true (符合 3 &lt; x)</span><br><br><span class="hljs-keyword">let</span> x = <span class="hljs-number">11</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x &gt; <span class="hljs-number">3</span> &amp;&amp; x &lt; <span class="hljs-number">10</span>)  <span class="hljs-comment">// 輸出結果為 false</span><br></code></pre></td></tr></table></figure><h2 id="邏輯運算子"><a href="#邏輯運算子" class="headerlink" title="邏輯運算子"></a>邏輯運算子</h2><h3 id="基本介紹-3"><a href="#基本介紹-3" class="headerlink" title="基本介紹"></a>基本介紹</h3><p>邏輯運算子（logical operators）: 通常用於條件判斷 <code>true</code> or <code>false</code> 。    </p><table><thead><tr><th align="center">運算子</th><th>說明</th><th>範例</th><th>結果</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td>「而且」；前後條件皆相符，則回傳 true</td><td>true &amp;&amp; true<br>true &amp;&amp; false<br>false &amp;&amp; false</td><td>true<br>false<br>false</td></tr><tr><td align="center">||</td><td>「或」；前後條件只要有一邊為 true，則為 true</td><td>true || true<br>true || false<br>false || false</td><td>true<br>true<br>false</td></tr><tr><td align="center">!</td><td>「非」，將後面接的 boolean 轉成相反的值</td><td>!true<br>!false</td><td>false<br>true</td></tr></tbody></table><h3 id="常見錯誤-運算子順序"><a href="#常見錯誤-運算子順序" class="headerlink" title="常見錯誤: 運算子順序"></a>常見錯誤: 運算子順序</h3><p>就像四則運算有「先乘除後加減」的運算順序一樣，邏輯運算子的運算順序是: <code>&amp;&amp;</code> &gt; <code>||</code> ，且由左至右運行。如果要打破原有順序，加上 <code>()</code> 是很好用的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span>)      <span class="hljs-comment">// 結果為 true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>) &amp;&amp; (<span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span>))  <span class="hljs-comment">// 結果為 false</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alpha Camp 學期一結業心得</title>
      <link href="/posts/491e0585/"/>
      <url>/posts/491e0585/</url>
      
        <content type="html"><![CDATA[<p>Alpha Camp的三週學習進度終於結束了，中間除了充斥著被成就感激起的學習熱情，也飽含怎麼都寫不出來的挫敗感。趁著現在給自己留下一篇熱騰騰的記錄，好好回顧這段學習歷程!  </p><span id="more"></span><br/><h2 id="為什麼會報名Alpha-Camp"><a href="#為什麼會報名Alpha-Camp" class="headerlink" title="為什麼會報名Alpha Camp?"></a>為什麼會報名Alpha Camp?</h2><p>在傳產當了幾年的會計，雖然喜歡這種嚴謹又規整的工作，但是又不甘於這種毫無變化的生活。工作中充斥著各種財務報表的編撰和解讀，與人的交流變得少之又少……又由於公司軟體不給力，很多報表都是Excel刻出來的，為了減少人工輸入造成的錯誤，那段時間研究了函數、VBA，力求做到自動極大化。在查資料過程中發現，把一些固定的語法拼在一起，讓他自動提供結果給我，其實這些東西跟寫程式很像，這也成了我接觸程式語言的契機。  </p><p>同時，我也和幾位不同產業的同學&#x2F;前輩聊了聊，發現只要繼續做會計，未來的工作模式也不會有太大的改變。我問了自己:「我能忍受未來20年都過這樣的生活嗎?」 然後我就有了轉職的想法XD  </p><p>在嘗試自學後發現，因為完全沒概念，很難為自己規劃一個明確的方向。做了幾天的功課後，毅然決然的刷了卡，趁著沒有太大的經濟負擔時，試著走一條不一樣的路，希望給自己一個不一樣的未來。</p><h2 id="三週課程感受"><a href="#三週課程感受" class="headerlink" title="三週課程感受"></a>三週課程感受</h2><p>說實話，比我預期的還要好! 其中對我最有幫助的應該是課程制度的設計，有效的把我在自學時發生的問題都解決了! 其中最有感覺的是以下幾點:</p><ol><li><p>進度制<br>  非常有效的解決了拖延症的問題。每週有固定進度，但又可以依照自己的時間安排每天學習時間。給了少許進度壓力的同時，又保持了一定的自由度。另外，因為有一批跟自己一樣進度的同學在，討論、互相激勵也很有幫助!</p></li><li><p>實作練習<br>  學了之後馬上思考要怎麼用，可以檢視自己是不是真的理解了課堂說明。這也是我最喜歡的一部分! 在糾結又糾結之後順利完成，那種成就感真的會讓我很有學習的衝勁!</p></li><li><p>作業觀摩&#x2F;助教回覆<br>  當自己的作業是「成功了」，但同學的作業是「有效率的成功了」，或是助教有任何的點評，看到這些時我都會特別高興，因為又找到了另一種解決問題的方法。跟著別人的思路走一遍，將它內化成自己能理解的知識，這也是對我來說明顯有幫助的學習方式。</p></li></ol><p>跟著AC進度學習的同時，因為有了大方向，所以可以比較清楚的知道還有哪些欠缺的東西可以補足。學習期間<a href="https://www.w3schools.com/">W3school</a>、<a href="https://www.freecodecamp.org/">FreeCodeCamp</a>、<a href="https://developer.mozilla.org/zh-TW/">MDN</a>也作為補充資料給了我很多幫助。藉由閱讀不同的說明方式不斷作複習，不但加強記憶，偶爾看到一些新用法也很有趣。  </p><h2 id="後續規劃"><a href="#後續規劃" class="headerlink" title="後續規劃"></a>後續規劃</h2><p>整體來說，這三週的學習是很愉快的，我也決定繼續進入下學期課程。  </p><p>在下學期開課前，除了先進行課程預習外，希望能把這三週以來的筆記整理一下也放進部落格裡。相信隨著部落格的成長，除了可以檢視自己的曾經犯過的錯誤，也能更直觀的知道自己曾經學過什麼? 有沒有進步? 另外，目前進行到一半的 Ubuntu 及 Command Line 學習也很有趣!  </p><p>終於擺脫了那種工作上原地踏步的無力感，喜歡目前每天都在學習、每時每刻都在進步的自己!</p>]]></content>
      
      
      <categories>
          
          <category> 課程心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AlphaCamp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>開始寫部落格啦!</title>
      <link href="/posts/572b724a/"/>
      <url>/posts/572b724a/</url>
      
        <content type="html"><![CDATA[<p>看了很多轉職分享、技術部落格、Youtube影片…等，有一個對程式新手共通的建議就是:「寫部落格」。<br>寫部落格的好處有什麼呢?  </p><span id="more"></span><p><strong>1. 學習筆記 :</strong><br>  學習的路很長，難免會把學過的東西忘掉。所以把自己曾經遇到的問題、解決過程及方法記錄下來，可以當作之後重新複習的依據。<br><strong>2. 知識再消化 :</strong><br>  把東西背下來很簡單，但要說給別人聽就相對困難。需要先消化、重新整理，再依照別人能懂的方式表達出來，需要一個知識再咀嚼的過程。這對新學到的知識可以有更深入的理解，或是會在跟別人的交流中找到自己忽略的小問題。<br><strong>3. 和別人交流的空間 :</strong><br>  也許會找到跟我相同興趣或遇到相同問題的人，可以超脫地理限制，跟世界各地的人交流。<br><strong>4. 求職參考 :</strong><br>  畢竟我不是本科出身的，在學歷上比不過相關科系的競爭對手。在經歷尚未累積出來之前，至少可以讓人資對我有更多的了解。包含我學過的知識、遇到過的問題，最重要的是我面對問題的解決態度及方法。  </p><p>既然開始了，希望能一直寫下去，也希望最終有一天，這個部落格也能成為其他人遇到問題的參考依據!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
